# Power Automate Interview Prep Template

## Topic: 59. The Finally Scope

**Last Updated:** 2024-05-24  
**Confidence:** ðŸŸ¢ Solid  
**Category:** Patterns | Architecture

## What Is It?

The "Finally Scope" is an architectural pattern in Power Automate where a Scope action is configured using "Configure Run After" settings to execute regardless of whether the preceding actions (typically the "Try" and "Catch" blocks) succeeded, failed, timed out, or were skipped.

**Why It Matters:**  
In enterprise automation, flows must maintain state integrity. The Finally Scope ensures that critical cleanup tasksâ€”such as deleting temporary files, closing database connections, updating a "Processing" status to "Error" or "Complete," or sending a final execution summaryâ€”always occur, preventing "zombie" records or orphaned resources.

## Core Concepts

- **Scope Action** - A container that groups multiple actions together, allowing them to be treated as a single unit for error handling.
- **Configure Run After** - The settings menu that defines the condition under which an action (or Scope) starts, based on the outcome of the immediate predecessor.
- **Terminal State Management** - The practice of ensuring a system returns to a known good state or provides a final notification at the end of a process execution.

## Implementation

### Basic Setup

**The Finally Configuration:**

To create a Finally Scope, you must select all four status options in the "Configure Run After" settings of the Scope action following your Try/Catch blocks.

```json
{
    "runAfter": {
        "Catch_Scope": [
            "Succeeded",
            "Failed",
            "Skipped",
            "TimedOut"
        ]
    }
}
```

> [!TIP]
> Always rename your scopes to "Try", "Catch", and "Finally" to make the logic immediately readable to other developers and to simplify the "Run After" configuration UI.

### Advanced Configuration

Inside a Finally block, you may need to determine if the flow actually failed earlier to send a specific "Failure" vs "Success" notification. You can use the `result()` expression to inspect the status of the Try scope.

```javascript
// Check if any action in the 'Try_Scope' failed
contains(result('Try_Scope'), 'Failed')
```

> [!WARNING]
> If you have a "Catch" block before your "Finally" block, and the "Catch" block succeeds in handling the error, the "Finally" block's predecessor is technically "Succeeded." However, if the "Catch" block is skipped (because the "Try" succeeded), the "Finally" block must be set to run after "Skipped" to execute.

## Common Patterns

### Pattern 1: Standard Try-Catch-Finally

```
[Try Scope] 
    |
    +-- [Catch Scope] (Run after Try: Failed, TimedOut)
    |
    +-- [Finally Scope] (Run after Catch: Succeeded, Failed, Skipped, TimedOut)
```

This is the standard robust error handling pattern. The Finally block runs whether the error was caught or if no error occurred at all.

### Pattern 2: The Cleanup-Only Finally

```
[Main Logic Actions]
    |
    +-- [Finally Scope] (Run after Last_Action: Succeeded, Failed, TimedOut)
```

Used when explicit error "Catching" (like logging to a specific table) isn't required, but resource cleanup (like deleting a temp file from OneDrive) is mandatory before the flow terminates.

## Performance & Limits

> [!IMPORTANT]
> **Scope Limits:**
> - **Nesting:** Scopes can be nested up to 8 levels deep.
> - **Action Count:** Actions inside a Finally scope count toward the 500-action limit per flow.
> - **Execution Time:** The Finally block must complete within the overall flow timeout (default 30 days, but often limited by the calling application).

**Optimization Tips:**
- Keep Finally blocks "lean"; only include essential cleanup or notification logic.
- Use a single "Compose" action to aggregate status messages before entering the Finally block.
- Avoid complex logic inside Finally that could itself fail; if the Finally block fails, the flow status will be marked as Failed.

**When NOT to use:**
- Do not use a Finally scope for logic that *must only* run on success; use a standard sequential action for that.
- Avoid using Finally for long-running approvals, as this keeps the flow instance active and consuming resources.

## Interview Questions

### Beginner

**Q:** What is the purpose of a "Finally" scope in Power Automate?

<details>
<summary>Answer</summary>

A Finally scope is used to ensure that specific actions are executed regardless of whether the previous steps in the flow succeeded or failed. It is primarily used for cleanup tasks, such as closing connections or sending a final status notification, ensuring the flow finishes gracefully.

</details>

---

### Intermediate

**Q:** How do you configure a Scope action to behave as a "Finally" block if it follows a "Catch" scope?

<details>
<summary>Approach</summary>

**Solution:**
You must modify the "Configure Run After" settings of the Scope.

1. Click the three dots (...) on the Scope action.
2. Select "Configure Run After."
3. Check all four boxes: **is successful**, **has failed**, **is skipped**, and **has timed out**.

> [!TIP]
> The "is skipped" option is crucial because if the "Try" block succeeds, the "Catch" block will be skipped. Without "is skipped" checked, the Finally block would not run on a successful execution.

**Follow-up they'll ask:** "What happens to the flow's overall status if the Try block fails but the Catch and Finally blocks succeed?"  
**Answer:** The flow will be marked as **Succeeded** because the last action (the Finally scope) finished successfully. To report a failure, you must use the `Terminate` action at the end of the Catch or Finally block.

</details>

---

### Advanced

**Q:** In a complex flow with a Try-Catch-Finally structure, how can you ensure the flow is still marked as "Failed" in the run history if an error occurred, while still ensuring the Finally block executes?

<details>
<summary>Solution</summary>

**Architecture:**

To achieve this, you must allow the Finally block to run, but explicitly fail the flow at the end of the execution logic.

**Key considerations:**

1. Initialize a boolean variable `varIsSuccessful` to `true`.
2. In the **Catch** block, set `varIsSuccessful` to `false`.
3. In the **Finally** block, perform all cleanup tasks.
4. The very last action inside (or after) the **Finally** block should be a **Condition** checking `varIsSuccessful`.
5. If `false`, use the **Terminate** action with status **Failed**.

**Trade-offs to discuss:**
- **Option A (Terminate in Catch):** Prevents Finally from running unless Finally is parallel or the Terminate is placed after Finally.
- **Option B (Variable + Terminate at end):** Best practice. Ensures cleanup happens but preserves the integrity of the Run History status.

</details>

## Comparison Table

| Feature | Try Scope | Catch Scope | Finally Scope |
|----------|-----------|-----------|---------------|
| **Run After** | Previous Action: Success | Try: Failed/TimedOut | Catch: All Statuses |
| **Primary Goal** | Main Business Logic | Error Logging/Handling | Cleanup/Finalization |
| **Typical Actions** | Connectors, Logic, Data | Email Admin, Log to DB | Delete Temp, Terminate |
| **Mandatory?** | Yes | Recommended | Optional (Best Practice) |

## Real Example

> [!NOTE]
> **Problem:** A flow processes Excel files uploaded to SharePoint. If the processing fails midway, the file remains in the "Processing" folder, blocking future runs.  
> **Solution:** A Finally scope was implemented to move the file to either an "Archive" or "Error" folder regardless of the processing outcome.  
> **Result:** Zero manual interventions required to clear the "Processing" folder, and 100% visibility into failed files.

**Implementation:**
1. **Try:** Read Excel, Update Dataverse.
2. **Catch:** Log error details to a SharePoint list.
3. **Finally:** Move file from `/Processing` to `/Processed` (if success) or `/Failed` (if error).

## Quick Reference

### Result Expression Syntax

```javascript
// Get the status of the Try_Scope to use in logic within Finally
result('Try_Scope')

// Example: Check if Try_Scope failed to determine folder path
if(contains(result('Try_Scope'), 'Failed'), 'ErrorFolder', 'ArchiveFolder')
```

### Common Connector Actions in Finally

| Feature | Purpose | Key Parameter |
|-----------|-----------|-----------------|
| **Terminate** | Sets final flow status | Status (Succeeded/Failed) |
| **Delete File** | Cleans up temp storage | File Identifier |
| **Update Record** | Sets final status flag | Status Reason |

## Practice

**Exercise 1:** Build a flow structure that simulates a Try-Catch-Finally pattern. The "Try" block should contain an action that intentionally fails (e.g., dividing by zero in a Compose action). Ensure the "Finally" block sends you a mobile notification regardless of the failure.

<details>
<summary>Hint</summary>

Use a `Compose` action with `div(1, 0)` to force an error. Remember to check "is skipped" in the Finally block's Run After settings.

</details>

<details>
<summary>Solution</summary>

1. **Scope: Try** -> Compose: `div(1, 0)`
2. **Scope: Catch** (Run After Try: Failed) -> Compose: "Error caught"
3. **Scope: Finally** (Run After Catch: Succeeded, Failed, Skipped, TimedOut) -> Send Notification: "Flow finished execution."

**Key points:**
```javascript
// The Run After for Finally must look like this in the code view:
"runAfter": { "Catch": ["Succeeded", "Failed", "Skipped", "TimedOut"] }
```

</details>

## Troubleshooting Guide

> [!CAUTION]
> **Common Errors:**

| Error | Cause | Fix |
|-------|-------|-----|
| Finally block skipped | "is skipped" was not checked in Run After. | Edit Run After and ensure all four status checkboxes are selected. |
| Flow marked "Succeeded" despite error | The Finally block (the last action) succeeded. | Add a Terminate action at the end of the flow logic if an error was detected. |
| Finally block never runs | An action *between* the Catch and Finally block failed and didn't have its own error handling. | Ensure the Finally block immediately follows the Catch block or that all intermediate actions have "Run After" configured. |

## Tags
#architecture #error-handling #scopes #best-practices #governance

---