# Power Automate Interview Prep Template

## Topic: 56. Building a Try Catch Pattern

**Last Updated:** 2024-05-24  
**Confidence:** ðŸŸ¢ Solid  
**Category:** Patterns

---

## What Is It?

The Try-Catch pattern is a structural design implementation in Power Automate that uses Scopes and "Configure Run After" settings to gracefully handle errors, prevent flow termination, and execute recovery or logging logic.

**Why It Matters:**  
In production environments, flows often interact with volatile external systems (APIs, Databases, Legacy Connectors). Without a Try-Catch pattern, any single action failure causes the entire flow to stop immediately, leaving data in an inconsistent state and triggering generic "Flow Failed" notifications. This pattern allows for automated retries, custom error logging, and "Finally" blocks for resource cleanup.

---

## Core Concepts

- **Scope Action** - A container that groups multiple actions together, allowing them to be treated as a single unit for error handling.
- **Configure Run After** - The logic settings on an action (or Scope) that dictate whether it executes based on the preceding action's status: Succeeded, Failed, Skipped, or Timed Out.
- **The `result()` Expression** - A specialized function that returns an array of JSON objects representing the outcome of every action inside a specified Scope, used to extract specific error messages.

---

## Implementation

### Basic Setup

**Try-Catch Structure:**

```text
1. Scope: Try
   - Action: Get_Data_From_API
   - Action: Update_Database
2. Scope: Catch (Configure Run After: [has failed, has timed out, is skipped])
   - Action: Log_Error_To_SharePoint
   - Action: Terminate (Status: Failed)
```

> [!TIP]
> Always include a "Terminate" action at the end of your Catch block with a status of "Failed" if you want the Flow Run history to still show a red "Failed" status while having performed custom error handling.

---

### Advanced Configuration

**Extracting the Error Message:**
To get the actual error message from the failed action inside the "Try" scope, use a Filter Array on the `result()` expression.

```javascript
// Expression to get the result of the 'Try' scope
result('Try')

// Expression to filter for the failed action's error message
first(filter(result('Try'), x => equals(x['status'], 'Failed')))['error']['message']
```

> [!WARNING]
> If you have nested Scopes, `result()` only returns the top-level actions within the specified Scope. It does not recurse into nested Scopes unless called specifically on them.

---

## Common Patterns

### Pattern 1: Try-Catch-Finally

```
[Scope: Try] -> (Contains main logic)
      |
[Scope: Catch] -> (Runs if Try Fails/Times out; Handles Logging)
      |
[Scope: Finally] -> (Configure Run After: Succeeded, Failed, Skipped, Timed Out)
```

Use this when you need a "Cleanup" phase (e.g., deleting a temporary file) that must run regardless of whether the main logic succeeded or failed.

---

### Pattern 2: Parallel Error Branching

```
       [Action: Risky_Step]
      /                 \
[Action: Success]     [Action: Error_Handler]
(Run after: Success)  (Run after: Failure)
```

Use this for simple, single-action error handling where a full Scope might be overkill. It allows the flow to diverge immediately based on the result of one specific action.

---

## Performance & Limits

> [!IMPORTANT]
> **Scope Limits:**
> - **Nesting Depth:** You can nest Scopes up to 8 levels deep.
> - **Action Count:** There is no specific limit to actions inside a Scope, but large Scopes can make the designer sluggish.
> - **Run After Complexity:** Complex "Run After" configurations can make debugging difficult as the visual path in the designer may skip several blocks.

**Optimization Tips:**
- Keep the "Try" block as small as possible to pinpoint exactly where failures occur.
- Use a "Global Error Handler" child flow to process errors from the Catch block to keep your main flow clean.
- Use the `result()` expression inside the Catch block to avoid hardcoding error messages.

**When NOT to use:**
- Do not use for expected logic branching (e.g., checking if a file exists). Use "Condition" actions for expected logic.
- Avoid for transient network issues where the connector's built-in "Retry Policy" is sufficient.

---

## Interview Questions

### Beginner

**Q:** What are the four "Run After" options available for any action in Power Automate?

<details>
<summary>Answer</summary>

The four options are:
1. **Is successful:** The default state; runs if the previous action succeeded.
2. **Has failed:** Runs if the previous action encountered any error (except a timeout).
3. **Is skipped:** Runs if the previous action was not executed (usually due to a condition or a previous failure).
4. **Has timed out:** Runs if the previous action hit the execution time limit.

To build a standard Catch block, you typically select **Has failed**, **Is skipped**, and **Has timed out**.

</details>

---

### Intermediate

**Q:** If a "Try" scope fails and the "Catch" scope runs successfully to log the error, what will the final status of the Flow Run be in the history? How do you change it?

<details>
<summary>Approach</summary>

**Solution:**
By default, if the "Catch" scope finishes successfully, the Flow Run will be marked as **Succeeded**. This is because the error was "caught" and the final action in the flow finished without error.

To ensure the flow is marked as **Failed** in the dashboard (so admins see it), you must add a **Terminate** action at the end of the Catch block.

```json
{
    "inputs": {
        "status": "Failed",
        "code": "InternalError",
        "message": "The process failed but was logged by the Catch block."
    }
}
```

> [!TIP]
> Use the "Message" field in the Terminate action to pass the dynamic error message extracted via the `result()` expression.

**Follow-up they'll ask:** "Why would you want it to show as Succeeded?"  
**Answer:** If the Catch block successfully performed a 'Plan B' that completed the business requirement (e.g., failing over to a secondary database), the flow technically fulfilled its purpose.

</details>

---

### Advanced

**Q:** How would you implement a robust error handling pattern for a flow that processes 1000 items in a "For Each" loop, ensuring one failure doesn't stop the loop but still reports all errors at the end?

<details>
<summary>Solution</summary>

**Architecture:**

```
1. Initialize Variable: ErrorList (Array)
2. Apply to Each (Sequential or Parallel)
   - Scope: Try
     - [Process Item]
   - Scope: Catch (Run After: Failed, Timed Out)
     - Append to Variable: ErrorList (Item ID and Error Message)
3. Condition: If ErrorList is not empty
   - Send Summary Email
   - Terminate as Failed
```

**Key considerations:**

```javascript
// Inside the Catch block, use this to get the error:
result('Try')[0]['error']['message']
```

**Trade-offs to discuss:**
- **Concurrency:** If the loop is parallel, you must ensure the "Append to variable" action is thread-safe (Power Automate handles this, but it can cause slight bottlenecks).
- **Variable vs. Compose:** Using a variable is necessary to aggregate errors across loop iterations.

</details>

---

## Comparison Table

| Feature | Condition Action | Try-Catch (Scope) |
|----------|-----------|---------------|
| **Primary Use** | Expected logic branching (If/Else) | Unexpected error handling |
| **Trigger** | Boolean expression evaluation | Action status (Fail/Timeout) |
| **Complexity** | Simple binary paths | Can handle groups of actions |
| **Granularity** | High (checks specific values) | Broad (checks if any action in block failed) |

---

## Real Example

> [!NOTE]
> **Problem:** A Daily Currency Sync flow failed whenever the external API was down, leaving the Finance team with outdated rates and no notification.  
> **Solution:** Wrapped the API call in a "Try" scope and added a "Catch" scope that sends a high-priority Teams notification to the IT On-call channel.  
> **Result:** Reduced "silent failures" to zero and improved MTTR (Mean Time To Repair) by 4 hours.

**Implementation:**
```text
[Scope: Try_Sync]
   - HTTP: Get Exchange Rates
   - Parse JSON: Rates
[Scope: Catch_Failure] (Run After: Failed)
   - Post Message (Teams): "Currency Sync Failed: @{body('Parse_JSON')?['message']}"
   - Terminate: Failed
```

**Key learnings:**
- Always parse the error body of the failed HTTP request to provide context in the notification.
- Use the "Skipped" run-after setting if the Try block is inside a condition that might not run.

---

## Quick Reference

### Result() Expression Syntax

```javascript
// Get all action details from a scope named 'Main_Process'
result('Main_Process')

// Filter for only failed actions (Commonly used in Catch blocks)
filter(result('Main_Process'), x => equals(x['status'], 'Failed'))
```

### Run After Configuration

| Status | Meaning | Use Case |
|-----------|-----------|-----------------|
| Succeeded | Action finished with 2xx code | Standard flow progression |
| Failed | Action crashed or returned 4xx/5xx | Triggering the Catch block |
| Skipped | Action was bypassed | Handling logic in complex branches |
| Timed Out | Action exceeded duration limit | Handling API/Gateway timeouts |

---

## Practice

**Exercise 1:** Create a flow that attempts to divide a number by zero using the `div()` expression. Implement a Try-Catch pattern to catch the failure and post the error message to a Compose action.

<details>
<summary>Hint</summary>

Put the Compose action containing the `div(10, 0)` expression inside a Scope. Create a second Scope after it and change its "Configure Run After" settings.

</details>

<details>
<summary>Solution</summary>

1. **Scope: Try**
   - Action: Compose (Inputs: `@div(10, 0)`)
2. **Scope: Catch** (Run After: Failed)
   - Action: Compose_Error_Msg (Inputs: `result('Try')[0]['error']['message']`)

**Key points:**
```javascript
// The div by zero will trigger the 'Failed' status
// result('Try') will capture the 'Division by zero' error message.
```

</details>

---

## Troubleshooting Guide

> [!CAUTION]
> **Common Errors:**

| Error | Cause | Fix |
|-------|-------|-----|
| Catch block never runs | "Run After" is still set to default "Succeeded". | Click the three dots (...) on the Catch scope -> Configure Run After -> Check "Has Failed". |
| Flow shows "Succeeded" despite errors | Catch block finished successfully without a Terminate action. | Add a "Terminate" action with status "Failed" at the end of the Catch block. |
| `result()` expression fails | The Scope name in the expression doesn't match the actual Scope name. | Ensure the string inside `result('Scope_Name')` matches the Scope name exactly (replace spaces with underscores if necessary, though Power Automate usually handles this). |

---

## Tags
#patterns #error-handling #scopes #governance #architecture #interview-prep