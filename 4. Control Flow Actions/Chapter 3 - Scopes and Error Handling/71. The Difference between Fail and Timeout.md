# Power Automate Interview Prep Template

## Topic: 71. The Difference between Fail and Timeout

**Last Updated:** 2024-05-24  
**Confidence:** ðŸŸ¢ Solid  
**Category:** Architecture | Error Handling

## What Is It?

A **Fail** occurs when an action returns an explicit error response or encounters a logical error, whereas a **Timeout** occurs when an action fails to complete within a defined temporal limit.

**Why It Matters:**  
Distinguishing between these two is critical for building resilient "Try-Catch" logic. A failure often requires a fix to data or logic, while a timeout often requires a retry strategy, a change in concurrency settings, or an asynchronous pattern.

## Core Concepts

- **Failure (Failed Status):** Triggered when a connector returns a 4xx or 5xx status code (excluding 408/504 in some contexts) or when an expression cannot be evaluated (e.g., dividing by zero).
- **Timeout (Timed Out Status):** Triggered when an action exceeds its `timeout` duration. For most synchronous HTTP actions in Power Automate, this is 120 seconds by default; for the entire flow, it is 30 days.
- **Run After Configuration:** The mechanism used to intercept these states. By default, actions only run if the previous action "Succeeded," but they can be configured to run if the previous action "Failed" or "Timed Out."

## Implementation

### Basic Setup

**Run After Configuration (JSON View):**

```json
"Next_Action": {
    "runAfter": {
        "Previous_Action": [
            "Failed",
            "TimedOut"
        ]
    },
    "type": "Wait"
}
```

> [!TIP]
> You can configure "Run After" visually by clicking the three dots (...) on an action and selecting "Configure run after."

### Advanced Configuration

**Custom Timeout Policy:**
You can limit how long an action should wait before timing out by modifying the action's settings. This is useful for "failing fast."

```javascript
// Example: Setting a custom timeout in the Action Settings (UI)
// Duration is defined in ISO 8601 format
PT10M // Limits the action to 10 minutes
```

> [!WARNING]
> If you do not check both "Has failed" and "Has timed out" in your error handling block, your flow may skip the error handling logic entirely if the specific error type occurs that you didn't account for.

## Common Patterns

### Pattern 1: The Try-Catch-Finally Scope

```
Scope: Try
    |-- Action 1 (API Call)
    |-- Action 2 (Data Processing)
Scope: Catch (Run After: Try has Failed OR Timed Out)
    |-- Send Error Notification
Scope: Finally (Run After: Catch is Succeeded OR Skipped)
    |-- Clean up temporary files
```

This pattern ensures that whether the "Try" block fails due to a logic error (Fail) or a network delay (Timeout), the "Catch" block executes.

### Pattern 2: Specific Timeout Retry

```
Action: Call Legacy API (Timeout set to PT30S)
Action: Handle Timeout (Run After: Call Legacy API has Timed Out)
    |-- Action: Call Backup API
```

Used when a specific service is known to hang. Instead of waiting the default 120 seconds, we force a timeout at 30 seconds to switch to a secondary system.

## Performance & Limits

> [!IMPORTANT]
> **Relevant Limit Type:**
> - **HTTP Request Limit:** 120 seconds (Standard connector limit).
> - **Flow Run Duration:** 30 days maximum.
> - **Approval Timeout:** 30 days (Hard limit; approvals will "TimedOut" after this).

**Optimization Tips:**
- Use **Custom Timeouts** to prevent flows from hanging for the full 120s/30d limit.
- Use **Retry Policies** (Default, None, or Fixed Interval) to handle transient failures before the action officially "Fails."
- For long-running processes (over 120s), use an **Asynchronous Pattern** (Webhook or Polling).

**When NOT to use:**
- Do not rely on "Timeout" for logic that should be handled by "Failure" (e.g., checking if a file exists).
- Do not set timeouts too short for services with high latency, as this creates "False Failures."

## Interview Questions

### Beginner

**Q:** What is the main difference between an action failing and an action timing out?

<details>
<summary>Answer</summary>

A **Fail** means the service responded with a specific error message (like "File Not Found" or "Unauthorized") or the Power Automate engine encountered a logic error. A **Timeout** means the service took too long to respond, and Power Automate stopped waiting.

In "Run After" settings, these are two distinct checkboxes because a timeout often implies a connectivity or performance issue, while a failure implies a logic or data issue.

</details>

### Intermediate

**Q:** You have a flow that calls an external API. Sometimes the API is slow, and sometimes it returns a 500 error. How do you ensure your flow sends an alert in both cases?

<details>
<summary>Approach</summary>

**Solution:**
Use a Scope or a specific action and configure the "Run After" settings of the subsequent notification action.

1. Add the notification action after the API call.
2. Open "Configure run after."
3. Select both **"has failed"** (for the 500 error) and **"has timed out"** (for the slowness).
4. Uncheck **"is successful"**.

```json
"Send_Alert": {
    "runAfter": {
        "Call_External_API": ["Failed", "TimedOut"]
    }
}
```

> [!TIP]
> If you want the flow to continue normally after the alert, ensure the action *after* the alert runs if the alert is "Succeeded" or "Skipped."

**Follow-up they'll ask:** "What happens if the API call is successful?"  
**Answer:** The "Send Alert" action will be skipped because "is successful" was not selected in its Run After configuration.

</details>

### Advanced

**Q:** How would you design a flow to handle a 30-day timeout limit for a business process that might take 45 days?

<details>
<summary>Solution</summary>

**Architecture:**

```
Main Flow -> Start Approval -> Store Approval ID in Dataverse -> Terminate
Watcher Flow -> Recurrence (Daily) -> Check Dataverse for pending IDs -> If > 29 days -> Re-initialize Approval
```

**Key considerations:**

```javascript
// Use a 'Status' column in Dataverse to track if the process is 'Pending', 'Completed', or 'TimedOut_Restarted'
```

**Trade-offs to discuss:**
- **Option A (Parent/Child):** Use a parent flow to loop, but this still hits the 30-day limit.
- **Option B (State Machine):** Store the state in a database (Dataverse/SQL). This is the most robust way to bypass the 30-day timeout by effectively "restarting" the clock with a new flow run.

</details>

## Comparison Table

| Aspect | Fail (Failure) | Timeout | When to Use |
|----------|-----------|-----------|---------------|
| **Cause** | Explicit Error (4xx, 5xx, Logic) | Duration Exceeded | N/A |
| **Default HTTP Limit** | Immediate upon response | 120 Seconds | Use Timeout for slow APIs |
| **Retry Policy** | Can trigger on 5xx/429 | Usually triggers after retries fail | Use Retry for transient Fails |
| **Run After Setting** | `has failed` | `has timed out` | Check both for robust Catch blocks |

## Real Example

> [!NOTE]
> **Problem:** An ERP connector frequently timed out during peak hours, causing the flow to stop and leaving records unsynced.  
> **Solution:** Implemented a "Run After: Timed Out" block that added the record ID to an Azure Service Bus queue for later processing.  
> **Result:** 100% data consistency; peak hour delays no longer required manual flow restarts.

**Implementation:**
```
Action: Create ERP Record
Action: Add to Queue (Run After: Create ERP Record has Timed Out)
Action: Notify Admin (Run After: Create ERP Record has Failed)
```

**Key learnings:**
- Timeouts are often transient; failures are often permanent.
- Handling them separately allows for different recovery strategies (Retry vs. Alert).

## Quick Reference

### Timeout Duration Syntax (ISO 8601)

```javascript
PT1M  // 1 Minute
PT120S // 120 Seconds
P1D   // 1 Day
PT2H  // 2 Hours
```

### Common Connector Actions or Related Features

| Feature | Purpose | Key Parameter |
|-----------|-----------|-----------------|
| **Retry Policy** | Automatically retries on Fail/Timeout | Count, Interval |
| **Configure Run After** | Defines branching logic based on status | Failed, TimedOut, Skipped |
| **Scope** | Groups actions for collective error handling | N/A |

## Practice

**Exercise 1:** Create a flow that simulates a timeout and handles it.

<details>
<summary>Hint</summary>

Use the "HTTP" action pointing to a delay service (like `httpstat.us/200?sleep=130000`) and set a custom timeout in the action settings to `PT10S`.

</details>

<details>
<summary>Solution</summary>

1. Add **HTTP Action**: Method GET, URI `https://httpstat.us/200?sleep=5000`.
2. Go to **Settings** -> **Timeout** -> Enter `PT2S` (2 seconds).
3. Add a **Compose Action** below it named "Handle_Timeout".
4. Set **Run After** for "Handle_Timeout" to "has timed out".
5. Run the flow. The HTTP action will time out at 2s, and the Compose will run.

**Key points:**
```javascript
// Action Setting: Timeout = PT2S
// Run After: ["TimedOut"]
```

</details>

## Troubleshooting Guide

> [!CAUTION]
> **Common Errors:**

| Error | Cause | Fix |
|-------|-------|-----|
| **ActionFailed** | The previous action returned a 4xx/5xx error. | Check input data or API permissions. |
| **ActionTimedOut** | The action exceeded 120s or the custom timeout. | Increase timeout settings or use an async pattern. |
| **FlowRunTimeout** | The flow exceeded the 30-day limit. | Redesign using a state-machine/database approach. |

## Tags
#architecture #error-handling #governance #best-practices