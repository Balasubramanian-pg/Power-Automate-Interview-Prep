# Power Automate Interview Prep Template

## Topic: 61. Parsing Error JSON in Catch Blocks

**Last Updated:** 2024-05-24  
**Confidence:** ðŸŸ¢ Solid  
**Category:** Patterns | Expressions

---

## What Is It?

Parsing Error JSON in Catch Blocks is the technique of extracting structured data from the output of a failed action or scope to identify the specific cause of failure and drive conditional error-handling logic.

**Why It Matters:**  
Without parsing error JSON, flows can only react to the fact *that* a failure occurred. By parsing the error, a flow can distinguish between a transient error (e.g., a 429 Rate Limit), a data error (e.g., a 400 Bad Request), and a system error (e.g., a 500 Internal Server), allowing for automated retries, specific notifications, or data corrections.

---

## Core Concepts

- **RunAfter Configuration** - The setting that allows a "Catch" scope or action to execute only if the preceding "Try" scope has failed, skipped, or timed out.
- **The `actions()` Expression** - A function used to retrieve the full output (including the error body) of a specific action by its name.
- **The `result()` Expression** - A function that returns an array of JSON objects representing the outcome of every action within a specified Scope, used for bulk error analysis.

---

## Implementation

### Basic Setup

**Accessing Error Details via Expression:**

To get the error message from a failed action named "Get_Customer_Data", use the following expression in a Compose action within your Catch block:

```json
{
  "ErrorCode": "@actions('Get_Customer_Data')?['outputs']?['body']?['error']?['code']",
  "ErrorMessage": "@actions('Get_Customer_Data')?['outputs']?['body']?['error']?['message']"
}
```

> [!TIP]
> Always use the "Safe Navigation" operator (`?`) when traversing error JSON, as the structure of the error body can vary significantly between different connectors.

---

### Advanced Configuration

**Dynamic Error Extraction from a Scope:**

If you have multiple actions inside a "Try_Scope", you can use the `result()` expression to find the specific action that failed and parse its JSON.

```javascript
// Filter the result of the scope to find the failed action
filter(result('Try_Scope'), x => equals(x['status'], 'Failed'))

// Extract the error message from the first failed action found
first(body('Filter_Array'))?['outputs']?['body']?['error']?['message']
```

> [!WARNING]
> If an action fails due to a timeout or a connection loss, the `outputs` property might be null or missing. Your logic must account for cases where the JSON body is not present.

---

## Common Patterns

### Pattern 1: The Specific Action Catch

```
[Try Scope]
   â””â”€ [HTTP Request] (May fail)
[Catch Scope] (RunAfter: Has Failed)
   â””â”€ [Parse JSON] (Input: actions('HTTP_Request')?['outputs']?['body'])
   â””â”€ [Condition] (If ErrorCode is 'RateLimitExceeded')
```

Used when a single, critical action is the primary point of failure and you need to handle its specific API error codes.

---

### Pattern 2: The Generic Scope Logger

```
[Try Scope]
   â””â”€ [Action A]
   â””â”€ [Action B]
[Catch Scope] (RunAfter: Has Failed)
   â””â”€ [Filter Array] (Input: result('Try_Scope'), Status == 'Failed')
   â””â”€ [Apply to Each] (On Filtered Array)
       â””â”€ [Log Error to DB] (CurrentItem()?['name'], CurrentItem()?['error']?['message'])
```

Used for complex flows where any one of several actions might fail. This pattern centralizes error logging without needing to know which action failed beforehand.

---

## Performance & Limits

> [!IMPORTANT]
> **Expression Limits:**
> - The `result()` function only works on Scopes, not the entire flow.
> - The `actions()` function cannot reference actions inside a different loop iteration unless handled carefully.
> - Error bodies are subject to the standard action output size limit (usually 100MB), though error messages are rarely this large.

**Optimization Tips:**
- Use `Parse JSON` with a schema only if you need to reference multiple fields; otherwise, use direct expressions to save an action step.
- Use a "Finally" scope (RunAfter: Succeeded, Failed, Skipped, Timed Out) to clean up resources regardless of the error parsing outcome.
- Rename your actions early; if you rename an action after writing `actions('Old_Name')`, the expression will break.

**When NOT to use:**
- Do not use complex parsing for "Expected" failures (e.g., checking if a file exists). Use a dedicated "Check if exists" action or a condition instead.
- Avoid parsing error JSON if the connector provides a "Status Code" output natively.

---

## Interview Questions

### Beginner

**Q:** How do you configure an action to run only when a previous action fails?

<details>
<summary>Answer</summary>

You use the **"Configure Run After"** setting. By clicking the three dots (...) on an action or scope, you can select "Configure run after" and check the box for "has failed" (and optionally "has timed out" or "is skipped") while unchecking "is successful".

</details>

---

### Intermediate

**Q:** If a Scope fails, how can you programmatically determine which specific action inside that scope caused the failure?

<details>
<summary>Approach</summary>

**Solution:**
Use the `result('Scope_Name')` expression. This returns an array of all action outputs within that scope. You can then use a **Filter Array** action to find the item where `status` is equal to `Failed`.

```json
// Expression for Filter Array
@result('My_Try_Scope')
// Condition in Filter Array
@equals(item()?['status'], 'Failed')
```

> [!TIP]
> The `result()` function is the most robust way to handle errors in large scopes because it captures the metadata of the failure even if the action didn't return a standard body.

**Follow-up they'll ask:** "What if multiple actions failed?"  
**Answer:** The `result()` array will contain all of them. You can loop through the filtered array to log every error or use `first()` to handle only the initial failure.

</details>

---

### Advanced

**Q:** How would you handle a scenario where an API returns an error in a non-standard format (e.g., HTML instead of JSON) during a 502 Bad Gateway error?

<details>
<summary>Solution</summary>

**Architecture:**

1.  **Try/Catch Scope** structure.
2.  **Check Content-Type:** Before parsing, check the headers of the failed action output.
3.  **Conditional Parsing:** Use an `if()` expression or Switch to determine if the body is JSON.

**Key considerations:**

```javascript
// Check if the output is JSON before parsing
if(startsWith(actions('MyAction')?['headers']?['Content-Type'], 'application/json'), 
   json(actions('MyAction')?['outputs']?['body']), 
   'Non-JSON Error Received'
)
```

**Trade-offs to discuss:**
- **Option A (Strict Schema):** Using `Parse JSON` with a strict schema. Pros: Easy to use downstream. Cons: Fails the Catch block itself if the error format changes.
- **Option B (Direct Expressions):** Using `actions('Action')?['outputs']?['body']?['message']`. Pros: More resilient to schema changes. Cons: Harder to read/maintain in complex flows.

</details>

---

## Real Example

> [!NOTE]
> **Problem:** A flow syncing data to an external ERP was failing intermittently due to "Locking" errors (SQL 409). Standard failure alerts were annoying the IT team because these errors were temporary.  
> **Solution:** Implemented a Catch block that parses the Error JSON. If the `error/code` is `409`, the flow waits 2 minutes and retries. If it's any other code, it sends a high-priority alert.  
> **Result:** Reduced manual intervention by 85% and eliminated "false alarm" notifications.

**Implementation:**
```
Scope: Try_Sync
   â””â”€ SQL: Update_Record
Scope: Catch_Errors (RunAfter: Failed)
   â””â”€ Compose: GetErrorCode -> actions('Update_Record')?['outputs']?['body']?['error']?['code']
   â””â”€ Condition: If GetErrorCode == '409'
       â””â”€ Delay (2 mins)
       â””â”€ SQL: Update_Record (Retry)
```

---

## Quick Reference

### Common Error Paths

| Connector Type | Common JSON Path to Message |
|----------------|-----------------------------|
| **Standard APIs** | `actions('Name')?['outputs']?['body']?['error']?['message']` |
| **Dataverse** | `actions('Name')?['outputs']?['body']?['error']?['message']` |
| **HTTP Action** | `body('Action_Name')?['message']` (Depends on API) |
| **SQL Server** | `actions('Name')?['outputs']?['body']?['status']` |

---

## Practice

**Exercise 1:** Create a flow that attempts to get a file from SharePoint that doesn't exist. In the Catch block, extract the "Status Code" and the "Message" from the failure and send them in an email.

<details>
<summary>Hint</summary>

Use the `Get file properties` action and point it to a non-existent ID. In the Catch block, use a Compose action with the `actions()` expression to find the `statusCode` inside the `outputs`.

</details>

<details>
<summary>Solution</summary>

1. Create a **Scope** named `Try_Scope`.
2. Inside, add **Get file properties** (SharePoint). Use a dummy ID like `99999`.
3. Outside, add a **Scope** named `Catch_Scope`. Set **Configure Run After** to "has failed".
4. Inside `Catch_Scope`, add a **Compose** action:
```javascript
{
  "Status": "@outputs('Get_file_properties')?['statusCode']",
  "Message": "@outputs('Get_file_properties')?['body']?['message']"
}
```
5. Add an **Email** action using the outputs of the Compose.

</details>

---

## Troubleshooting Guide

> [!CAUTION]
> **Common Errors:**

| Error | Cause | Fix |
|-------|-------|-----|
| `The action 'ActionName' could not be found` | The action was renamed, but the expression `actions('ActionName')` was not updated. | Update the string inside the `actions()` or `outputs()` function to match the current action name (replace spaces with underscores). |
| `The expression is invalid... property 'body' doesn't exist` | The action failed so severely (e.g., Timeout) that no output body was generated. | Use the `?` operator (e.g., `outputs('Action')?['body']`) to prevent the Catch block itself from failing. |
| `Parse JSON failed: Required property 'x' is missing` | The error JSON returned by the API does not match the schema provided in the Parse JSON action. | Make the schema properties optional by removing them from the `"required": []` array in the JSON schema. |

---

## Tags
#error-handling #expressions #json #governance #architecture #catch-blocks