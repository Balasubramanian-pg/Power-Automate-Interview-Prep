# Power Automate Interview Prep Template

## Topic: 65. Resume Flow from Failure Points

**Last Updated:** 2024-05-24  
**Confidence:** ðŸŸ¢ Solid  
**Category:** Patterns | Architecture

## What Is It?

Resuming flow from failure points is a design strategy and platform capability that allows an automation to recover from errors by either re-executing specific failed actions or restarting the process from a recorded "checkpoint" to avoid redundant processing of successful upstream steps.

**Why It Matters:**  
In complex enterprise integrationsâ€”such as processing a multi-stage financial approval or syncing thousands of recordsâ€”a failure at the final step should not require restarting the entire process. Resuming from failure prevents data duplication, respects API rate limits, and ensures high availability for mission-critical workflows.

## Core Concepts

- **Configure Run After** - The foundational setting that allows an action to execute only if the preceding action has a specific status (Succeeded, Failed, Skipped, or Timed Out).
- **State Management (Checkpoints)** - The architectural practice of updating a "Status" or "Stage" field in an external data source (SQL, Dataverse) after each major block of logic to track progress.
- **Try-Catch-Finally Pattern** - A structural approach using Scope actions to group logic (Try), handle errors (Catch), and perform cleanup (Finally), enabling controlled recovery paths.

## Implementation

### Basic Setup

**Configure Run After (JSON Logic):**

While configured in the UI, the underlying workflow definition uses the `runAfter` property to determine execution flow.

```json
"Next_Action_Name": {
    "runAfter": {
        "Previous_Action_Name": [
            "Failed",
            "TimedOut"
        ]
    },
    "type": "OpenApiConnection",
    "inputs": { ... }
}
```

> [!TIP]
> To create a "Catch" block, add a Scope action immediately after your main logic Scope, and set its "Configure Run After" to only run if the main logic Scope has **Failed** or **Timed Out**.

### Advanced Configuration

**State-Based Resumption Logic:**

To resume a flow from a specific point after a manual restart, use a "Switch" or "Condition" block that checks a "CurrentStep" variable retrieved from your data source.

```javascript
// Expression to check if a specific step should be skipped based on stored state
// If storedState is 'Step3', this returns true for Step1 and Step2
greater(variables('StepOrder'), variables('StoredStateOrder'))
```

> [!WARNING]
> When using the "Resubmit" feature in the Power Automate portal, the flow uses the *original* trigger data. If the failure was caused by bad input data that has since been corrected in the source system, a simple Resubmit will fail again because it does not fetch the updated trigger record.

## Common Patterns

### Pattern 1: The Scope-Based Try-Catch

```
[Scope: Try]
   |-- Action 1 (Create Record)
   |-- Action 2 (Upload File)
[Scope: Catch] (RunAfter: Failed/TimedOut)
   |-- Action 3 (Log Error to SharePoint)
   |-- Action 4 (Notify Admin)
[Scope: Finally] (RunAfter: Succeeded/Failed/Skipped/TimedOut)
   |-- Action 5 (Update Status to 'Processed')
```

This pattern is used for immediate error handling and notification within a single run.

### Pattern 2: The Checkpoint Pattern (State Machine Lite)

```
[Trigger: Item Modified]
   |-- [Condition: Is Status 'Step 2 Failed'?]
         |-- YES: Jump to Step 2 Logic
         |-- NO: Start from Step 1
[Action: Step 1]
   |-- Update Status: 'Step 1 Complete'
[Action: Step 2]
   |-- Update Status: 'Step 2 Complete'
```

This pattern is used for long-running processes where a user might need to fix data and then "Retry" the flow by toggling a status field.

## Performance & Limits

> [!IMPORTANT]
> **Execution Limits:**
> - **Resubmit Window:** You can only resubmit a flow run within 90 days of the original execution.
> - **Retry Policy:** The default retry policy is "Exponential Interval" (4 retries), but this only handles transient 429/5xx errors, not logic failures.
> - **Nesting Limit:** Scopes can be nested, but excessive nesting (beyond 8 levels) makes "Run After" logic difficult to debug.

**Optimization Tips:**
- Use **Side-by-Side (Parallel) Branches** to handle errors for specific actions without stopping the entire flow.
- Use the `result('Scope_Name')` expression in your Catch block to filter for the specific action that failed within that scope.
- Implement **Idempotency**: Ensure that if an action (like "Create Invoice") runs twice, it checks for existence first to avoid duplicates.

**When NOT to use:**
- Do not use complex resume logic for simple, read-only flows (e.g., sending a notification) where a full restart has no negative side effects.
- Avoid "Run After" loops that could lead to infinite execution cycles if not properly terminated.

## Interview Questions

### Beginner

**Q:** What are the four "Run After" options available for any action in Power Automate?

<details>
<summary>Answer</summary>

The four options are:
1. **Is successful:** The default state; runs if the previous action succeeded.
2. **Has failed:** Runs if the previous action had a code error or logic failure.
3. **Is skipped:** Runs if the previous action was not executed (e.g., inside a false condition).
4. **Has timed out:** Runs if the previous action hit the infrastructure timeout limit (usually 120 seconds for HTTP).

Example: You might set a "Send Email" action to run only if a "Generate Report" action **Has failed**.

</details>

### Intermediate

**Q:** You have a flow that updates a SQL database and then sends an approval. If the approval times out, how do you ensure the flow can be restarted without creating a duplicate SQL record?

<details>
<summary>Approach</summary>

**Solution:**
Implement a "Check-Before-Write" or "Upsert" strategy combined with a Status field.

1. Before the SQL action, add a "Get Rows" action to check if the record already exists using a unique identifier.
2. Use a Condition: If record exists, Update; if not, Insert.
3. After the SQL action, update a `FlowStatus` column in SQL to 'DB_Updated'.
4. If the flow fails at the Approval stage and is resubmitted, the "Check-Before-Write" logic will see the 'DB_Updated' status or the existing record and skip the creation step.

> [!TIP]
> Using a "GUID" generated at the start of the flow and stored in the database is the most reliable way to track a specific execution's impact.

**Follow-up they'll ask:** "What if the SQL connector itself fails?"  
**Answer:** Use a Retry Policy on the SQL action and a Catch scope to notify the user that the database is unreachable.

</details>

### Advanced

**Q:** Describe how to build a "Self-Healing" flow for a high-volume integration that handles 503 (Service Unavailable) errors from a legacy API.

<details>
<summary>Solution</summary>

**Architecture:**

```
[Main Logic Scope]
   |-- [HTTP Action to Legacy API] (Retry Policy: None)
[Catch Scope] (RunAfter: Failed)
   |-- [Filter Array: result('Main_Logic_Scope')] (Find status == 503)
   |-- [Condition: If 503 found]
         |-- [Wait 5 minutes]
         |-- [HTTP Action: Retry API Call]
         |-- [Update Checkpoint Table]
```

**Key considerations:**

```javascript
// Expression to find the failed action in the Catch block
filter(result('Main_Logic_Scope'), x => equals(x['status'], 'Failed'))
```

**Trade-offs to discuss:**
- **Option A (In-flow Retries):** Good for short outages, but consumes flow run duration (max 30 days).
- **Option B (External Queue):** Move the failed item to an "Error Queue" (Service Bus) and have a separate flow process the queue. This is more scalable for high-volume failures.

</details>

## Comparison Table

| Feature | Run After Logic | Manual Resubmit | State-Based Checkpoints |
|----------|-----------|-----------|---------------|
| **Automation** | Fully Automated | Manual Intervention | Hybrid |
| **Complexity** | Low | None | High |
| **Data Integrity** | Moderate | Low (Risk of duplicates) | High |
| **When to Use** | Simple error handling/logging | One-off ad-hoc failures | Mission-critical, multi-step processes |

## Real Example

> [!NOTE]
> **Problem:** A flow processing monthly payroll failed halfway through 500 employees due to a temporary banking API outage. Restarting the flow would have resulted in the first 250 employees being paid twice.  
> **Solution:** Implemented a "PaymentStatus" column in the source list. The flow was wrapped in a loop that only processed employees where "PaymentStatus" was not 'Paid'.  
> **Result:** When the flow was resubmitted after the outage, it automatically skipped the 250 'Paid' records and finished the remaining 250, ensuring 100% accuracy.

**Implementation:**
```
[Get Items: Filter Query: PaymentStatus ne 'Paid']
[Apply to Each]
   |-- [Process Payment]
   |-- [Update Item: PaymentStatus = 'Paid']
```

**Key learnings:**
- Always filter data at the source (OData) based on completion status.
- Status updates should be the very next action after the critical success point.

## Quick Reference

### Result() Expression Syntax

```javascript
// Get the output of all actions in a scope to find which one failed
result('Scope_Name')

// Check if a specific action failed
equals(outputs('Action_Name')?['statusCode'], 500)
```

### Common Connector Actions for Resumption

| Feature | Purpose | Key Parameter |
|-----------|-----------|-----------------|
| **Scope** | Groups actions for Try/Catch | Run After Configuration |
| **Terminate** | Ends flow with 'Succeeded' or 'Failed' status | Status, Code, Message |
| **Wait** | Delays retry attempts | Duration (ISO 8601) |

## Practice

**Exercise 1:** Build a flow that simulates a failure. Create a Scope called "Try" containing an HTTP action to an invalid URL. Create a Scope called "Catch" that only runs if "Try" fails. Inside "Catch," use the `result()` expression to compose a message containing the error code of the failed HTTP action.

<details>
<summary>Hint</summary>

Use `first(result('Try'))?['error']?['message']` to extract the error details from the array returned by the result function.

</details>

<details>
<summary>Solution</summary>

1. Add **Scope** "Try".
2. Inside "Try", add **HTTP** action (Method: GET, URI: `https://thisisafakeurl12345.com`).
3. Add **Scope** "Catch" below "Try".
4. Click "..." on "Catch" -> **Configure Run After** -> Select "has failed" and "has timed out" (uncheck "is successful").
5. Inside "Catch", add a **Compose** action with: `result('Try')`.
6. Add another **Compose** to get the specific error: `first(filter(result('Try'), x => equals(x['status'], 'Failed')))?['outputs']?['body']`.

</details>

## Troubleshooting Guide

> [!CAUTION]
> **Common Errors:**

| Error | Cause | Fix |
|-------|-------|-----|
| **ActionNotStarted** | A downstream action didn't run because the "Run After" was still set to "Succeeded" but the parent failed. | Check the "Configure Run After" settings of the specific action that didn't fire. |
| **Infinite Loop** | A flow triggered by "Item Modified" updates the same item in its "Catch" block, triggering itself again. | Add a condition at the start to check if the update was made by the Flow Service Account or use a specific "Trigger Window" column. |
| **Result() Empty** | Calling `result('Scope')` from outside the scope or before it finishes. | Ensure the `result()` expression is inside a block that runs *after* the target scope has completed. |

## Tags
#error-handling #resumption #try-catch #architecture #reliability

---