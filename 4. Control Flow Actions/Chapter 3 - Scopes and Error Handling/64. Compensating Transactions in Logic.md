# Power Automate Interview Prep Template

## Topic: 64. Compensating Transactions in Logic

**Last Updated:** 2024-05-24  
**Confidence:** ðŸŸ¢ Solid  
**Category:** Patterns | Architecture

---

## What Is It?

A compensating transaction is a logic pattern used to undo or "offset" the effects of previously completed actions when a subsequent step in a multi-stage business process fails.

**Why It Matters:**  
In distributed cloud environments, traditional ACID (Atomicity, Consistency, Isolation, Durability) transactions are often impossible because flows interact with multiple independent systems (e.g., SQL, ERP, SharePoint). If a flow updates a database but fails to charge a credit card, the compensating transaction ensures the database update is reverted or neutralized to maintain data integrity.

---

## Core Concepts

- **Saga Pattern** - A design pattern that manages long-lived transactions by breaking them into a sequence of smaller, local transactions, each with a corresponding compensation action.
- **Backward Recovery** - The strategy of restoring a system to a consistent state by reversing the operations that have already been performed.
- **Idempotency** - The requirement that a compensation action can be executed multiple times without causing unintended side effects, which is critical if a compensation flow is retried.

---

## Implementation

### Basic Setup

**Scope-Based Try/Catch:**

```json
{
  "type": "Scope",
  "actions": {
    "Step_1_Create_Record": { ... },
    "Step_2_Update_Inventory": { ... }
  },
  "runAfter": {}
},
{
  "type": "Scope",
  "actions": {
    "Compensate_Step_2": { ... },
    "Compensate_Step_1": { ... }
  },
  "runAfter": {
    "Main_Scope": ["Failed", "TimedOut"]
  }
}
```

> [!TIP]
> Always name your scopes clearly (e.g., `Try_Scope` and `Catch_Scope`) to make the "Configure Run After" logic easy to read in the designer.

---

### Advanced Configuration

**Dynamic Compensation Log:**
For complex flows, initialize an array variable `varCompensationLog`. After every successful action in the "Try" block, append the necessary "Undo" metadata to this array. In the "Catch" block, iterate through the array in **reverse order** to execute the compensation.

```javascript
// Example of a compensation object appended to the log
{
    "ActionType": "DeleteRecord",
    "TargetSystem": "Dataverse",
    "RecordId": "outputs('Create_Record')?['body/id']"
}
```

> [!WARNING]
> Compensation logic can also fail. Ensure your "Catch" block has its own error handling or alerting mechanism, otherwise, you may end up with "Zombie" data (partially processed records).

---

## Common Patterns

### Pattern 1: The "Try-Catch" Scope

```
[Try Scope]
    |-- Action A (Success)
    |-- Action B (Fails)
[Catch Scope] (RunAfter: Failed)
    |-- Undo Action A
    |-- Terminate (Failed)
```

This is the standard approach for linear flows where the number of steps is small and fixed.

---

### Pattern 2: The Saga (State Machine)

```
[Action 1: Update System A] -> Set Status: 'Pending_A'
[Action 2: Update System B] -> Set Status: 'Pending_B'
[Failure Occurs]
[Check Status] -> If 'Pending_B', Undo B then Undo A.
```

Used for long-running processes that might span days. The state is stored in a database, allowing the flow to know exactly where to resume or what to undo if a failure occurs after a long delay.

---

## Performance & Limits

> [!IMPORTANT]
> **Execution Limits:**
> - **Run After:** You must explicitly configure "Configure Run After" for the compensation block to include "Has Failed," "Is Skipped," or "Has Timed Out."
> - **Nesting:** Power Automate supports up to 8 levels of nested scopes.
> - **Timeout:** The default run duration is 30 days; compensation must occur within this window.

**Optimization Tips:**
- **Parallel Compensation:** If undoing actions are independent, use a "Parallel Branch" in the Catch block to speed up recovery.
- **Idempotent Deletes:** Use "Delete" actions that do not fail if the record is already gone (e.g., check for existence first).
- **Minimal Logging:** Only store the minimum data required to perform the undo operation in your compensation variables.

**When NOT to use:**
- When the operation is inherently atomic (e.g., a single SQL stored procedure that handles its own transaction).
- When the "Undo" action is physically impossible (e.g., sending an email or printing a physical label).

---

## Interview Questions

### Beginner

**Q:** What is the difference between a "Rollback" in a database and a "Compensating Transaction" in Power Automate?

<details>
<summary>Answer</summary>

A **Rollback** is an automatic feature of a database engine that reverts changes to a previous state using logs before the transaction is committed. 

A **Compensating Transaction** is a manual logic pattern in a flow. Because the flow interacts with different systems, there is no single "undo" button. You must explicitly build the logic to delete a record or reverse a status if a later step fails.

</details>

---

### Intermediate

**Q:** How do you ensure that your compensation logic doesn't run if the "Try" block was successful?

<details>
<summary>Approach</summary>

**Solution:**
Use the "Configure Run After" settings on the action or scope following the "Try" block.

1. Create a `Catch_Scope`.
2. Click the three dots (...) on the `Catch_Scope`.
3. Select **Configure Run After**.
4. Uncheck **is successful** and check **has failed**, **is skipped**, and **has timed out**.

> [!TIP]
> To ensure the flow still reports a failure to the run history, add a "Terminate" action with a status of "Failed" at the end of your Catch block.

**Follow-up they'll ask:** "What happens if the compensation action itself fails?"  
**Answer:** You should wrap the compensation action in its own error handling or use a secondary alerting system (like an Admin email or log table) to flag the record for manual intervention.

</details>

---

### Advanced

**Q:** Describe how you would implement a compensating transaction for a flow that interacts with five different legacy systems that do not support transactions.

<details>
<summary>Solution</summary>

**Architecture:**

I would implement a **Routing Slip** or **Compensation Log** pattern.

1. **Initialize an Array:** `varCompensationStack`.
2. **Execution:** For each system update, I use a Scope. If successful, I `Append to array variable` a JSON object containing the `UndoActionType` and the `RecordID`.
3. **Error Handling:** A final `Compensation_Scope` is set to run only if the main process fails.
4. **Logic:** Inside the `Compensation_Scope`, I use the `reverse()` expression on `varCompensationStack` and a `For Each` loop.
5. **Switch Case:** Inside the loop, a `Switch` statement executes the specific "Undo" action based on the `UndoActionType`.

**Trade-offs to discuss:**
- **Complexity vs. Reliability:** The array approach is more complex to build but highly scalable if the number of steps changes.
- **State Storage:** For extremely critical data, I would store the compensation log in an external table (Dataverse/SQL) rather than a flow variable to ensure recovery is possible even if the flow run is lost.

</details>

---

## Comparison Table

| Feature | Database Transaction (ACID) | Compensating Transaction (Saga) |
|----------|-----------|-----------|
| **Scope** | Single Database | Multiple Distributed Systems |
| **Mechanism** | Locking and Log files | Logic-based "Undo" actions |
| **Isolation** | High (others can't see partial changes) | Low (partial changes are visible until undone) |
| **Complexity** | Low (handled by Engine) | High (handled by Developer) |

---

## Real Example

> [!NOTE]
> **Problem:** A travel booking flow reserves a hotel room, then attempts to book a flight. If the flight booking fails, the hotel room remains reserved, costing the company money.  
> **Solution:** Implemented a Scope-based compensation. If the Flight API returns an error, the "Catch" scope triggers a "Cancel Hotel Reservation" API call using the ID from the first step.  
> **Result:** Reduced "ghost" reservations by 99% and automated the refund process.

**Implementation:**
```
Try_Scope:
  - HTTP: Reserve Hotel (Returns ReservationID)
  - HTTP: Book Flight (Fails)
Catch_Scope (RunAfter: Failed):
  - HTTP: Cancel Hotel Reservation (using ReservationID)
  - Terminate: Failed
```

---

## Quick Reference

### Configure Run After Settings

| Setting | Behavior |
|-----------|-----------|
| **Is Successful** | Runs if the previous action finished without error. |
| **Has Failed** | Runs if the previous action threw an error or timed out. |
| **Is Skipped** | Runs if the previous action was not executed (due to a prior failure). |
| **Has Timed Out** | Runs if the previous action hit the execution duration limit. |

---

## Practice

**Exercise 1:** Create a flow that creates a "Project Folder" in SharePoint and then creates a "Project Entry" in a SQL Table. If the SQL entry fails (e.g., due to a duplicate key), the SharePoint folder must be deleted.

<details>
<summary>Hint</summary>

Use two Scopes. In the first scope, perform the SharePoint and SQL actions. Configure the second scope to run only if the first scope fails. Use the "ID" or "Path" from the SharePoint action in the "Delete Folder" action inside the second scope.

</details>

<details>
<summary>Solution</summary>

1. **Scope: Try_Block**
   - Action: SharePoint - Create new folder.
   - Action: SQL Server - Insert row.
2. **Scope: Catch_Block** (Run After: Try_Block has failed)
   - Action: SharePoint - Delete folder (using ID from Try_Block).
   - Action: Terminate (Status: Failed).

**Key points:**
```javascript
// Ensure the Delete action uses the output from the specific Create action
outputs('Create_new_folder')?['body/ID']
```

</details>

---

## Troubleshooting Guide

> [!CAUTION]
> **Common Errors:**

| Error | Cause | Fix |
|-------|-------|-----|
| **ActionNotStarted** | The compensation block is set to run after "Success" but the previous block failed. | Change "Configure Run After" to include "Has Failed". |
| **Infinite Loop** | The compensation action fails and triggers itself (if using certain recursive patterns). | Ensure compensation actions are outside the scope they are compensating. |
| **404 Not Found** | The compensation logic tried to delete a record that was never actually created. | Add a condition to check if the `RecordID` variable is null before attempting compensation. |

---

## Tags
#architecture #patterns #error-handling #reliability #distributed-systems #saga-pattern

---