# Power Automate Interview Prep Template

**Topic:** [74. Exception Handling Best Practices](4. Control Flow Actions/Chapter 3 - Scopes and Error Handling/74. Exception Handling Best Practices.md)

**Last Updated:** 2024-05-24  
**Confidence:** ðŸŸ¢ Solid  
**Category:** Patterns | Architecture

**What Is It?**

Exception handling in Power Automate is the strategic implementation of logic to detect, manage, and recover from runtime errors, ensuring that automated processes fail gracefully rather than leaving data in an inconsistent state.

**Why It Matters:**  
Without robust exception handling, a flow might stop mid-process (e.g., after charging a customer but before updating the inventory), leaving no audit trail or notification. Proper handling ensures data integrity, provides actionable alerts to admins, and allows for automated recovery or "cleanup" operations.

**Core Concepts**

*   **Configure Run After** - The fundamental setting on every action that determines if it should execute based on the preceding action's status (Succeeded, Failed, Skipped, or Timed Out).
*   **Scope Action** - A container used to group multiple actions together, allowing a single "Run After" configuration to handle errors for the entire group (simulating a Try/Catch block).
*   **The result() Expression** - A powerful expression used to retrieve the status and error details of all actions within a specific Scope, enabling detailed error logging.

**Implementation**

### Basic Setup

**Configure Run After:**

To create a basic "Catch" block, you configure an action (or Scope) to run only if the previous action has failed.

```json
{
  "runAfter": {
    "Update_Record_Action": [
      "Failed",
      "TimedOut"
    ]
  }
}
```

> [!TIP]
> Always include "TimedOut" in your error handling logic. Many API-based connectors will time out before they technically "fail," and ignoring this state will cause your error handler to be skipped.

### Advanced Configuration

**Extracting Specific Error Messages:**

Using the `result()` expression inside a "Catch" scope allows you to filter for the specific action that caused the failure and extract its message.

```javascript
// Filter the result of 'Try_Scope' to find the failed action
filter(result('Try_Scope'), x => equals(x['status'], 'Failed'))[0]?['outputs']?['body']?['error']?['message']
```

> [!WARNING]
> If you use a "Catch" scope, the Flow run will technically be marked as "Succeeded" because the error was "handled." You must use a **Terminate** action with a status of "Failed" at the end of your catch block if you want the run history to reflect a failure.

**Common Patterns**

### Pattern 1: Try-Catch-Finally

```
Scope: Try (Main Logic)
    |
Scope: Catch (Run After: Try Failed/TimedOut)
    |-- Log Error to SharePoint/Dataverse
    |-- Send Admin Notification
    |-- Terminate (Status: Failed)
    |
Scope: Finally (Run After: Try Succeeded/Skipped/Failed/TimedOut)
    |-- Close Connections
    |-- Update Audit Log
```

This is the gold standard for enterprise flows. The "Finally" block always runs, ensuring cleanup occurs regardless of success or failure.

### Pattern 2: The "Sidecar" Notification

```
Main Action (e.g., HTTP Request)
    |
    |-- (Run After: Success) --> Continue Flow
    |
    |-- (Run After: Failed) --> Post to Microsoft Teams (Adaptive Card)
```

Used for non-critical failures where the flow doesn't necessarily need to stop, but an observer needs to be notified immediately.

**Performance & Limits**

> [!IMPORTANT]
> **Retry Policy Limits:**
> - Default: 4 retries over 20 seconds (Exponential Interval).
> - Maximum: 90 retries over a maximum of 30 days.
> - Fixed Interval: Minimum 5 seconds, Maximum 1 day.

**Optimization Tips:**
- **Use Scopes Sparingly:** While great for organization, deeply nested scopes can make the "Run After" logic difficult to visualize in the designer.
- **Custom Retry Policies:** For flaky legacy APIs, increase the retry count and interval in the action "Settings" rather than building a manual loop.
- **Static Results:** Use "Static Results" (Mocking) during development to test how your Catch block handles specific error codes (e.g., 404 vs 500).

**When NOT to use:**
- **High-Volume Trivial Errors:** If an error is expected and non-impactful (e.g., "Check if folder exists" failing), use a Condition or a simple "Run After" instead of a full Try-Catch architecture.
- **Infinite Loops:** Never place an action inside a Catch block that could trigger the same flow again without a termination condition.

**Interview Questions**

### Beginner

**Q:** What are the four "Run After" options available for any action in Power Automate?

<details>
<summary>Answer</summary>

The four options are:
1. **Is successful:** The default state; runs if the previous action worked.
2. **Has failed:** Runs if the previous action had a runtime error or returned an error code.
3. **Is skipped:** Runs if the previous action was bypassed (usually due to a condition).
4. **Has timed out:** Runs if the action hit the infrastructure or connector timeout limit.

Example: To create an error handler, you check **Has failed** and **Has timed out**.

</details>

### Intermediate

**Q:** If a flow catches an error using a Scope and sends an email notification, why does the Flow Run History still show "Succeeded"? How do you fix this?

<details>
<summary>Approach</summary>

**Solution:**
Power Automate considers a run "Succeeded" if the final action executed successfully. If your "Catch" block handles the error and finishes, the engine assumes the problem is resolved.

To fix this:
1. Add a **Terminate** action at the end of your Catch scope.
2. Set the Status to **Failed**.
3. Provide a custom **Code** and **Message** using the `result()` expression to pass the original error details upward.

```json
{
  "inputs": {
    "status": "Failed",
    "code": "UserDefinedError",
    "message": "The process failed at the ERP update step."
  }
}
```

> [!TIP]
> This is critical for reporting and for Parent/Child flow architectures where the Parent needs to know the Child failed.

**Follow-up they'll ask:** "What happens to the 'Finally' block if you terminate in the 'Catch' block?"  
**Answer:** The "Finally" block will not run if the "Terminate" action is triggered before it. You should place the Terminate action *after* the Finally block or inside it.

</details>

### Advanced

**Q:** How would you implement a centralized error logging system for 50+ different flows without duplicating the Catch logic in every single flow?

<details>
<summary>Solution</summary>

**Architecture:**

1. **Child Flow (Error Handler):** Create a dedicated "Global Error Handler" flow triggered by an HTTP request or "Run a Child Flow" trigger.
2. **Standardized Schema:** The Child Flow should accept parameters: `FlowName`, `Environment`, `ErrorDetails`, and `UserEmail`.
3. **Parent Implementation:** In every production flow, implement a standard Try/Catch scope. In the Catch block, call the "Global Error Handler" child flow.

**Key considerations:**

```javascript
// In the Parent Flow Catch Block:
// Use result() to get the error and pass it to the Child Flow
body('Call_Global_Error_Handler')?['ErrorDetails']
```

**Trade-offs to discuss:**
- **Option A (Child Flow):** Pros: Centralized updates (change the notification logic in one place). Cons: Slight overhead in execution time and API calls.
- **Option B (Azure Application Insights):** Pros: Professional telemetry and querying (KQL). Cons: Requires Azure subscription and more complex setup.

</details>

**Comparison Table**

| Feature | Default Retry | Configure Run After | Try-Catch (Scopes) |
|----------|-----------|-----------|---------------|
| **Granularity** | Action-level | Action-level | Group-level |
| **Complexity** | Low (Toggle) | Medium | High |
| **Best Use Case** | Transient network blips | Simple branching | Enterprise-grade error recovery |
| **Visibility** | Hidden in settings | Visible in designer | Highly structured |

**Real Example**

> [!NOTE]
> **Problem:** A daily flow syncing SQL Server data to Salesforce was failing silently due to duplicate record errors, causing data drift.  
> **Solution:** Wrapped the Salesforce "Create Record" in a Try/Catch scope. If it fails, the Catch block parses the error message for the string "DUPLICATE_VALUE" and sends a specific Adaptive Card to the data steward.  
> **Result:** Reduced data drift by 95% and decreased IT support tickets by allowing business users to fix their own data entry errors.

**Implementation:**
```
Scope: Try_Sync
  |-- Salesforce: Create Record
Scope: Catch_Errors (Run After: Failed)
  |-- Filter Array: result('Try_Sync')
  |-- Condition: If error contains 'DUPLICATE'
      |-- Post Adaptive Card to User
  |-- Terminate: Failed
```

**Key learnings:**
- Not all failures are "system" failures; some are "business logic" failures.
- Using `result()` is the only way to distinguish between a 404 (Not Found) and a 500 (Server Error) programmatically.

**Quick Reference**

### Common Status Expressions

```javascript
// Get all actions from a scope
result('Scope_Name')

// Check if a specific action failed
equals(outputs('Action_Name')?['status'], 'Failed')

// Get the error message from a failed action
actions('Action_Name')?['error']?['message']
```

### Common Connector Status Codes

| Feature | Purpose | Key Parameter |
|-----------|-----------|-----------------|
| **400** | Bad Request | Check your syntax/schema |
| **401/403** | Unauthorized | Check Connection/Permissions |
| **404** | Not Found | Item likely deleted |
| **429** | Too Many Requests | Throttling (Increase Retry) |
| **500/502** | Server Error | Target system is down |

**Practice**

**Exercise 1:** Create a flow that attempts to get a file from OneDrive that doesn't exist. Implement a Try-Catch-Finally structure that:
1. Catches the error.
2. Posts the error message to a Compose action.
3. Always posts "Process Complete" to a second Compose action regardless of the outcome.

<details>
<summary>Hint</summary>

Use three Scope actions. Set the "Catch" scope to Run After the "Try" scope has Failed. Set the "Finally" scope to Run After the "Catch" scope has Succeeded, Failed, or been Skipped.

</details>

<details>
<summary>Solution</summary>

1. **Scope: Try** -> Action: Get File Metadata (use a fake path).
2. **Scope: Catch** -> Configure Run After: `Try` has **Failed** or **Timed Out**.
   - Action: Compose (Error Message): `result('Try')[0]?['outputs']?['body']?['message']`
3. **Scope: Finally** -> Configure Run After: `Catch` is **Succeeded**, **Failed**, or **Skipped**.
   - Action: Compose (Status): "Process Complete".

**Key points:**
```javascript
// Ensure the Finally block runs even if Catch is skipped (which happens if Try succeeds)
runAfter: { "Catch": ["Succeeded", "Failed", "Skipped"] }
```

</details>

**Troubleshooting Guide**

> [!CAUTION]
> **Common Errors:**

| Error | Cause | Fix |
|-------|-------|-----|
| **ActionBranchingConditionNotSatisfied** | An action was skipped because its "Run After" condition wasn't met. | Check the "Run After" settings of the action mentioned in the error. |
| **Infinite Loop** | The Catch block triggers a process that restarts the same flow. | Add a condition to check the trigger source or use a Terminate action. |
| **Result() function empty** | The Scope name in the expression is misspelled or the scope hasn't run. | Ensure the string in `result('Scope_Name')` exactly matches the Scope's name. |

**Tags**
#governance #error-handling #best-practices #architecture #reliability