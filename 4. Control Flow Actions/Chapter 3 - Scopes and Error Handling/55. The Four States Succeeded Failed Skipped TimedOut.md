# Power Automate Interview Prep: The Four States

**Last Updated:** 2024-05-24  
**Confidence:** ðŸŸ¢ Solid  
**Category:** Architecture | Error Handling

## What Is It?

The Four States (Succeeded, Failed, Skipped, and TimedOut) represent the possible execution outcomes of a Power Automate action, which determine whether subsequent actions execute based on "Configure Run After" settings.

**Why It Matters:**  
Without understanding these states, flows are fragile. Mastering them allows developers to implement "Try-Catch-Finally" logic, ensuring that if a critical step (like a database update) fails, the system can gracefully recover, notify administrators, or roll back changes rather than simply stopping.

## Core Concepts

- **Run After Configuration** - The mechanism that allows an action to check the status of the preceding action before executing. By default, actions are set to run only if the previous action "Succeeded."
- **Terminal State** - Once an action reaches one of these four states, it is considered complete for that specific run instance.
- **Scope Logic** - Scopes aggregate the states of the actions within them. If any action inside a scope fails, the entire scope is marked as "Failed," which is the foundation of advanced error handling.

## Implementation

### Basic Setup

**Configure Run After (JSON Representation):**

In the underlying code of a Power Automate flow, the "Run After" logic is defined in the `runAfter` property of an action.

```json
"Send_an_email_notification": {
    "runAfter": {
        "Update_a_row": [
            "Failed",
            "TimedOut"
        ]
    },
    "type": "ApiConnection",
    "inputs": { ... }
}
```

> [!TIP]
> You can select multiple states for a single action. For example, a "Cleanup" action should often be configured to run if the previous step Succeeded, Failed, OR TimedOut.

### Advanced Configuration

**Try-Catch-Finally Pattern using Scopes:**

```javascript
// Logic for a "Catch" Scope
// This scope should be configured to 'Run After' the "Try" scope 
// only if the "Try" scope has:
["Failed", "TimedOut"]

// Logic for a "Finally" Scope
// This scope should be configured to 'Run After' the "Catch" scope 
// regardless of outcome:
["Succeeded", "Failed", "Skipped", "TimedOut"]
```

> [!WARNING]
> If an action is skipped, any subsequent actions set to run only on "Succeeded" will also be skipped, potentially creating a "silent failure" chain where the flow reports success but didn't actually perform the work.

## Common Patterns

### Pattern 1: The Try-Catch Block

```
[Scope: Try]
    |-- Action: Create File
    |-- Action: Update Metadata
[Scope: Catch] (Run After: Try has Failed or Timed Out)
    |-- Action: Send Error Email
    |-- Action: Terminate (Status: Failed)
```

This pattern ensures that if any step inside the "Try" scope fails, the "Catch" scope executes to handle the error.

### Pattern 2: The Parallel Error Logger

```
[Action: Main Task]
       |
-----------------------
|                     |
[Action: Success Path] [Action: Error Log]
(Run After: Succeeded) (Run After: Failed, TimedOut)
```

This allows the flow to branch immediately upon failure without nesting everything inside scopes, useful for simple logging.

## Performance & Limits

> [!IMPORTANT]
> **State Constraints:**
> - **Default Timeout:** Most HTTP actions and connectors have a default timeout (often 120 seconds), after which they transition to the "TimedOut" state.
> - **Run Duration:** A flow run can stay in progress for up to 30 days before the entire run transitions to a "TimedOut" state.
> - **Evaluation:** "Run After" conditions are evaluated at runtime; they do not add latency to the flow execution.

**Optimization Tips:**
- Use **Scopes** to group actions so you don't have to configure "Run After" for every single individual action.
- Always use a **Terminate** action at the end of a "Catch" block to ensure the overall Flow Run status reflects a failure if a critical error occurred.
- Use the `result()` expression to inspect the errors of all actions within a failed scope.

**When NOT to use:**
- Do not use "Run After: Failed" for expected logic branching (e.g., checking if a file exists). Use a **Condition** action instead for cleaner logic.
- Avoid complex "Run After" chains in very large flows, as they can become difficult to visualize in the designer.

## Interview Questions

### Beginner

**Q:** What is the difference between the "Failed" state and the "Skipped" state?

<details>
<summary>Answer</summary>

**Failed:** The action attempted to run but encountered an error (e.g., a 404 Not Found, a 500 Server Error, or a required field being null).

**Skipped:** The action never attempted to run because the "Run After" conditions of the previous action were not met, or it was inside a branch of a Condition/Switch that was not executed.

</details>

### Intermediate

**Q:** You have a flow that sends an approval. If the approver doesn't respond within 30 days, the flow fails. How do you handle this specifically?

<details>
<summary>Approach</summary>

**Solution:**
Configure the action following the Approval to run after the "TimedOut" state.

1. Add an action (e.g., "Send Reminder" or "Escalate").
2. Click the three dots (...) on that action -> **Configure run after**.
3. Uncheck "is successful" and check **"has timed out"**.

> [!TIP]
> For Approvals, "TimedOut" is the specific state triggered when the 30-day limit is reached.

**Follow-up they'll ask:** "What happens to the flow status if you handle a Timeout but don't use a Terminate action?"  
**Answer:** The flow will be marked as "Succeeded" because the failure/timeout was successfully 'caught' and handled by a subsequent action.

</details>

### Advanced

**Q:** How can you retrieve the specific error message from a failed Scope to include it in a notification?

<details>
<summary>Solution</summary>

**Architecture:**
Use the `result()` expression in a "Catch" scope.

**Key considerations:**
Inside the Catch scope, use a "Filter Array" or a "Compose" action with the following expression:
```javascript
result('Try_Scope_Name')
```
Then, filter the array to find items where the `status` is equal to 'Failed'. You can then extract the `error/message` property from the object.

**Trade-offs to discuss:**
- **Option A (Individual Actions):** Hardcoding error messages for each action. (Pros: Specificity. Cons: High maintenance).
- **Option B (result() expression):** Dynamic error extraction. (Pros: Scalable, catches any error. Cons: Requires complex expressions to parse the JSON).

</details>

## Comparison Table

| State | Triggered By | Typical Scenario | Flow Status Impact |
|----------|-----------|-----------|---------------|
| **Succeeded** | 2xx Response / Logic Pass | Standard execution | Positive |
| **Failed** | 4xx/5xx Response / Invalid Schema | API down, missing data | Negative (unless caught) |
| **Skipped** | Run After logic not met | Condition branch not taken | Neutral |
| **TimedOut** | Execution exceeded limit | Approval expired (30 days) | Negative (unless caught) |

## Real Example

> [!NOTE]
> **Problem:** An automated ERP integration was failing silently when the ERP API was down, leading to missed orders.  
> **Solution:** Implemented a Try-Catch scope. The "Catch" scope was set to run after "Failed" or "TimedOut".  
> **Result:** The team received instant Teams notifications with the exact error code, reducing MTTR (Mean Time To Repair) from 24 hours to 15 minutes.

**Implementation:**
1. **Scope: ProcessOrder** (Contains HTTP Request to ERP).
2. **Scope: HandleError** (Run After: ProcessOrder has failed).
3. **Action: Post Message to Teams** (Inside HandleError).
4. **Action: Terminate** (Inside HandleError, set to Failed).

## Quick Reference

### Run After JSON Syntax

```json
"runAfter": {
    "Previous_Action_Name": [
        "Succeeded",
        "Failed",
        "Skipped",
        "TimedOut"
    ]
}
```

### Common Status Expressions

| Expression | Purpose |
|-----------|-----------|
| `actions('ActionName')?['status']` | Gets the status of a specific action |
| `result('ScopeName')` | Returns an array of all action results in a scope |

## Practice

**Exercise 1:** Create a flow that attempts to get a file from SharePoint. If the file is not found (Failed), the flow should post a message to Teams. If the file is found (Succeeded), it should email the file. Regardless of what happens, the flow should log the attempt in an Excel row.

<details>
<summary>Hint</summary>

You will need to use "Configure Run After" on three different actions. One for the "Success" path, one for the "Failure" path, and one for the "Finally" path (Succeeded + Failed).

</details>

<details>
<summary>Solution</summary>

1. **Get file content** (SharePoint).
2. **Send an email** (Run After: Get file content is **Succeeded**).
3. **Post message to Teams** (Run After: Get file content is **Failed**).
4. **Add a row into a table** (Run After: Send an email is **Succeeded** OR **Skipped**). 

*Note: Step 4 runs after the email step because if the email is skipped (due to failure), we still want the log to happen.*

</details>

## Troubleshooting Guide

> [!CAUTION]
> **Common Errors:**

| Error | Cause | Fix |
|-------|-------|-----|
| Flow shows "Succeeded" but data is missing | An action failed but a subsequent action was set to run after "Failed," and no "Terminate" action was used. | Add a "Terminate" action with status "Failed" at the end of your error handling path. |
| "ActionSkipped" error in a chain | A middle action in a sequence was skipped, causing all subsequent "Run After: Succeeded" actions to skip. | Check the "Run After" settings of the first skipped action to see why its requirements weren't met. |
| Infinite Loop / Logic Hang | Two actions are set to run after each other in a circular "Failed" dependency. | Ensure your error handling logic flows in one direction (downward). |

## Tags
#architecture #error-handling #governance #best-practices #try-catch