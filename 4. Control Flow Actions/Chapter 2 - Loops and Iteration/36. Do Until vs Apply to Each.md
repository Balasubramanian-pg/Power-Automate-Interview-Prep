# 10. Revision Tags
- `#low-code` `#automation` `#logic-flow` `#optimization`
- **Last Reviewed**: 2023-10-27
- **Confidence Level**: ðŸŸ¢ High

---

## **1. Topic Overview (The "What & Why")**
- **Definition**: **Apply to Each** is a deterministic loop used to iterate over a pre-existing collection of items, while **Do Until** is a non-deterministic loop that repeats actions until a specific logical condition is met.
- **Why It Matters**: Choosing the wrong loop type leads to inefficient processing, unnecessary API calls, or "infinite loop" scenarios that exhaust platform request limits and stall business processes.
- **Common Interview Angle**: "How do you decide between a collection-based loop and a condition-based loop when designing a workflow?"

## **2. Core Concepts (The Foundation)**
- **Apply to Each (The Iterator)**: Processes every item in a known list. 
    - *Analogy*: A mailman delivering a letter to every house on a specific street.
- **Do Until (The Poller)**: Processes actions repeatedly until a state change occurs. 
    - *Analogy*: A child in the backseat asking "Are we there yet?" until the answer is "Yes."
- **How They Relate**: Both are control-flow structures used for repetition, but **Apply to Each** is driven by *data volume*, whereas **Do Until** is driven by *state change*.

## **3. Technical Deep Dive (The Meat)**

### **A. Syntax/Implementation (Pseudo-Logic)**
```yaml
# Apply to Each: Iterating over an array
foreach item in Get_Items_Output:
  Update_Record(item.ID)
  # Parallelism can be enabled here (e.g., Degree of Parallelism: 20)

# Do Until: Waiting for a status change
do:
  Check_Status = Get_External_System_Status(RecordID)
  Delay(60 seconds)
until:
  Check_Status == "Completed" OR Loop_Index > 60
# Limits: Usually constrained by a Timeout (PT1H) or Count (60)
```

### **B. Common Patterns**
- **Pattern 1: Batch Processing (Apply to Each)**: Used when you fetch 100 overdue invoices and need to send an email for each one.
- **Pattern 2: The Polling Pattern (Do Until)**: Used when you trigger a long-running report in a 3rd party system and must wait for the "Ready" flag before downloading the file.
- **Pattern 3: Pagination (Do Until)**: Used when an API returns a "NextPageToken." You loop *until* the token is null.

### **C. Gotchas & Edge Cases**
- **The Infinite Loop**: If the exit condition in a *Do Until* is never met, the flow will run until it hits the platform's hard limit (e.g., 5,000 iterations or 30 days).
- **Concurrency Hazards**: In *Apply to Each*, enabling parallelism can cause "Race Conditions" if you are updating the same variable or resource inside the loop.
- **Variable Initialization**: You cannot initialize a variable inside either loop; it must be initialized at the root level.

## **4. Performance Considerations**
- **Time Complexity**: Both are effectively **O(n)**, but the "n" in *Do Until* is often unknown at runtime.
- **Optimization Tips**:
    1. **Apply to Each**: Enable "Concurrency Control" to process items in parallel if the actions are independent.
    2. **Do Until**: Always include a "Timeout" or "Count" limit in the settings to prevent runaway executions.
- **When NOT to Use**: 
    - Don't use *Apply to Each* if you can use an "Update Multiple" or "Filter Array" action (Set-based operations are faster than Row-based loops).
    - Don't use *Do Until* for simple delays; use a "Delay" or "Delay Until" action instead.

## **5. Interview Question Bank**

### **Beginner Level**
- Q1: What happens if the array passed to an *Apply to Each* is empty?
  - **Expected Answer**: The loop is skipped entirely, and the flow moves to the next action.
  - **Follow-up**: How would you handle a null check before the loop?

### **Intermediate Level**
- Q2: You need to send a reminder email every 24 hours until a manager approves a request. Which loop do you use?
  - **Approach**: Use a *Do Until*. 
  - **Logic**: Set the condition to `Status == 'Approved'`. Inside the loop, add a "Delay" action for 24 hours followed by a "Get Status" action.

### **Advanced Level**
- Q3: How do you optimize an *Apply to Each* loop that is processing 1,000 items too slowly?
  - **Considerations**: API Throttling vs. Sequential execution.
  - **Solution**: 1. Increase Concurrency (Parallelism). 2. Use "Filter Array" before the loop to reduce the number of items. 3. Check if the connector supports "Batch" operations to avoid the loop entirely.

## **6. Comparison Table**

| Feature | Apply to Each | Do Until |
|------------|------------|-------------|
| **Driving Force** | A collection/array | A logical condition |
| **Execution** | Can be Parallel or Sequential | Strictly Sequential |
| **Exit Strategy** | Ends when list is exhausted | Ends when condition is True |
| **Best For** | Data transformation/Bulk updates | Polling, Retries, Pagination |
| **Risk** | Slow performance if sequential | Infinite loops / Timeout |

## **7. Real-World Example (The "Aha!" Moment)**
- **Problem**: A client needed to upload large files to a legacy system that processed them asynchronously. We couldn't proceed to the next step until the legacy system finished.
- **Solution**: We used a **Do Until** loop. Inside, we called a "Check Status" API and added a 30-second delay. We set the exit condition to `Status is equal to 'Success'`.
- **Outcome**: The flow became resilient. It didn't matter if the legacy system took 1 minute or 10 minutes; the **Do Until** managed the wait time dynamically.

## **8. Quick Reference Card**
- **Use Apply to Each when**: You have a list (e.g., "Get Rows", "Get Emails").
- **Use Do Until when**: You are waiting for something to happen (e.g., "Wait for Status", "Retry until Success").
- **Pro-Tip**: In *Apply to Each*, use `@item()` to reference the current object. In *Do Until*, ensure the variable used in the condition is updated *inside* the loop.

## **9. Practice Exercises**
- **Exercise 1**: Create a logic flow that takes an array of numbers `[1, 2, 3, 4, 5]` and calculates the sum using an *Apply to Each*.
  - Difficulty: Easy
  - Time: 10 min
- **Exercise 2**: Create a "Retry Logic" using *Do Until* that attempts to call a failing API up to 3 times with a 10-second delay between attempts.
  - Difficulty: Medium
  - Time: 20 min

---

### **Mental Model Section**
- **The "Explain it to a 5-year-old" version**: 
    - *Apply to Each*: You have a bag of 10 cookies. You give one to each of your 10 friends until the bag is empty.
    - *Do Until*: You keep jumping on the trampoline until your mom yells "Dinner is ready!"

### **Interviewer Perspective**
- **What they're really testing**: They want to see if you understand **resource management**. A *Do Until* without a limit is a red flag for a junior developer. A sequential *Apply to Each* on a massive dataset shows a lack of performance awareness.