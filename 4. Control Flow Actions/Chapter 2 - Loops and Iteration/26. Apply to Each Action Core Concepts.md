# [26. Apply to Each Action Core Concepts](4. Control Flow Actions/Chapter 2 - Loops and Iteration/26. Apply to Each Action Core Concepts.md)

#automation #power-automate #logic-apps #iterative-logic
**Last Reviewed**: 2023-10-27
**Confidence Level**: ðŸŸ¢ High

---

## **1. Topic Overview (The "What & Why")**
- **Definition**: An "Apply to Each" action is a control flow loop that iterates over an array (collection) of data, executing a defined sequence of inner actions for every individual element in that array.
- **Why It Matters**: In modern automation, data rarely arrives as a single object; it arrives as lists (e.g., rows from an Excel sheet, a list of unread emails, or records from a database). This action is the primary mechanism for bulk processing and data transformation.
- **Common Interview Angle**: Interviewers focus on **performance optimization** (concurrency), **error handling** within loops, and knowing when to avoid a loop entirely in favor of a "Filter Array" or "Select" action.

---

## **2. Core Concepts (The Foundation)**
- **The Array (The Input)**: A structured list of items (JSON objects, strings, or integers) that serves as the trigger for the loop.
    - *Analogy*: A stack of 50 envelopes that need to be stamped.
- **The Current Item (`item()`)**: A dynamic reference to the specific piece of data currently being processed in the active iteration.
    - *Analogy*: The specific envelope currently in your hand.
- **Concurrency Control**: The ability to process multiple items in the array simultaneously rather than one after another.
    - *Analogy*: Hiring 10 people to stamp the envelopes at the same time instead of doing it yourself.
- **Iteration Index**: The numerical position (starting at 0) of the current item within the array.

---

## **3. Technical Deep Dive (The Meat)**

### **A. Syntax/Implementation**
While often represented in a UI, the underlying logic follows a JSON structure (Common Workflow Definition Language):

```json
"Apply_to_each_Invoice": {
    "type": "Foreach",
    "foreach": "@outputs('Get_Pending_Invoices')?['body/value']", // The input array
    "actions": {
        "Send_Email": {
            "type": "ApiConnection",
            "inputs": {
                "body": {
                    "To": "@item()?['CustomerEmail']", // Referencing the current item
                    "Subject": "Reminder: Invoice @{item()?['ID']}"
                }
            }
        }
    },
    "runtimeConfiguration": {
        "concurrency": { "repetitions": 20 } // Parallel processing enabled
    }
}
```

### **B. Common Patterns**
- **The Filter-then-Process Pattern**: Always use a "Filter Array" action *before* the "Apply to Each" to reduce the number of iterations.
- **The Batch Update Pattern**: Collecting IDs into an array during the loop and performing a single batch update outside the loop (if the API supports it).
- **The Nested Loop**: Using an "Apply to Each" inside another "Apply to Each" (e.g., iterating through Folders, then iterating through Files in each folder).

### **C. Gotchas & Edge Cases**
- **Variable Initialization**: You **cannot** initialize a variable inside an "Apply to Each" loop. Variables must be initialized at the root level.
- **Race Conditions**: If Concurrency is turned on, multiple iterations might try to "Set Variable" at the same time, leading to unpredictable results. Use "Append to Array" or keep concurrency at 1 (sequential) when updating variables.
- **Null Inputs**: If the input array is null or empty, the loop is skipped. This can cause downstream errors if subsequent actions expect data that was supposed to be generated inside the loop.

---

## **4. Performance Considerations**
- **Time Complexity**: O(n), where n is the number of items in the array.
- **Optimization Tips**:
    1. **Enable Concurrency**: By default, loops run sequentially. Increasing the degree of parallelism (up to 50 in many engines) can reduce execution time from minutes to seconds.
    2. **Avoid "Get" Actions Inside Loops**: If you need data from another table, try to fetch it all at once before the loop rather than calling "Get Row" 100 times inside the loop.
- **When NOT to Use**: If you only need to change the shape of the data (e.g., renaming keys in a JSON), use the **Select** action. If you only need to remove items, use **Filter Array**. These are "set-based" operations and are significantly faster than loops.

---

## **5. Interview Question Bank**

### **Beginner Level**
- Q1: What happens if the "Apply to Each" receives an empty array?
  - **Expected Answer**: The action is marked as successful, but it performs zero iterations and moves to the next step in the workflow.
  - **Follow-up**: How do you prevent a flow from failing if a later step depends on loop output? (Answer: Use a Condition to check `length(array)` before the loop).

### **Intermediate Level**
- Q2: You are updating a "Total Price" variable inside a loop with Concurrency enabled. Why is the final total incorrect?
  - **Approach**: Identify the "Race Condition."
  - **Explanation**: When multiple threads update the same variable simultaneously, they overwrite each other. To fix this, either disable concurrency or use a "Compose" action and an "Intersection/Union" method outside the loop.

### **Advanced Level**
- Q3: How do you handle a scenario where the "Apply to Each" exceeds the 100,000 item limit or the timeout duration?
  - **Considerations**: API Throttling, memory limits, and execution timeouts.
  - **Solution**: Implement a "Pagination" strategy at the data source level or split the data into smaller batches (chunking) and process them via child flows/sub-processes.

---

## **6. Comparison Table**

| Feature | Apply to Each | Select Action | Filter Array |
|------------|------------|-------------|-------------|
| **Purpose** | Execute actions (Email, DB Update) | Transform data shape | Reduce list size |
| **Speed** | Slower (Iterative) | Very Fast (Set-based) | Very Fast (Set-based) |
| **Side Effects** | Can call external APIs | Internal data only | Internal data only |
| **Complexity** | High (Supports multiple steps) | Low (Mapping only) | Low (Logical check only) |

---

## **7. Real-World Example (The "Aha!" Moment)**
- **Problem**: A client needed to send 500 personalized PDF certificates via email. Initially, the flow took 45 minutes because it processed one by one.
- **Solution**: We enabled **Concurrency Control** and set it to 20. We also moved the "Get Template Content" action *outside* the loop so it only ran once.
- **Outcome**: The execution time dropped from 45 minutes to under 3 minutes. The "Aha!" moment was realizing that the bottleneck wasn't the email sending, but the sequential "Get" actions inside the loop.

---

## **8. Quick Reference Card**
- **Access Current Item**: `item()`
- **Access Specific Property**: `item()?['PropertyName']`
- **Check Array Length**: `length(outputs('Action_Name')?['body/value'])`
- **Decision Tree**:
    - Need to send emails? â†’ **Apply to Each**
    - Need to change JSON keys? â†’ **Select**
    - Need to remove items from a list? â†’ **Filter Array**
    - Need to calculate a sum? â†’ **Select** then **join** or use a **Math Expression**.

---

## **9. Practice Exercises**
- **Exercise 1**: Create a flow that takes a JSON array of 5 users, filters out those who are "Inactive," and appends the "Email" of the active users to a string variable.
  - Difficulty: Medium
  - Time: 15 min
  - **Solution**: 1. Initialize String Variable. 2. Filter Array (Status eq 'Active'). 3. Apply to Each (Input: Output of Filter Array). 4. Append to String Variable (`item()?['Email'];`).

---

### **Interviewer Perspective**
- **What they're really testing**: Do you understand the difference between *procedural* programming (looping) and *functional/set-based* processing?
- **Red flags**: Using a loop to find a single item in an array (instead of a filter expression) or failing to mention concurrency when discussing performance.