# Power Automate Interview Prep: Managing Long Running Flows (30-Day Limit)

**Last Updated:** 2024-05-22  
**Confidence:** ðŸŸ¢ Solid  
**Category:** Architecture | Patterns

## What Is It?

Managing Long Running Flows refers to the architectural patterns and techniques used to execute business processes that exceed the hard 30-day execution limit imposed on Power Automate cloud flows.

**Why It Matters:**  
Standard cloud flows time out and fail automatically after 30 days. Many enterprise processesâ€”such as quarterly audits, long-term project approvals, or employee probation periodsâ€”require durations far exceeding this limit. Without a "long-running" strategy, these processes will terminate prematurely, leading to lost data and broken workflows.

## Core Concepts

- **30-Day Run Limit** - The non-configurable maximum duration a single flow instance can remain "In Progress" before being cancelled by the platform.
- **State Persistence** - The practice of saving the current progress of a workflow (variables, current step, approver) into an external data source (Dataverse, SQL, SharePoint) so it can be resumed by a new flow instance.
- **Dehydration and Rehydration** - The process of "pausing" a workflow by terminating the current run (dehydrating) and "resuming" it later by triggering a new run based on the stored state (rehydrating).

## Implementation

### Basic Setup

**State-Based Triggering (Dataverse):**

To manage flows longer than 30 days, avoid using "Delay" actions. Instead, use a status-based trigger.

```json
{
    "trigger": {
        "type": "OpenApiConnectionWebhook",
        "inputs": {
            "parameters": {
                "entityName": "cr_approval_tasks",
                "scope": "Organization",
                "filteringAttributes": "cr_status"
            },
            "host": {
                "apiId": "/providers/Microsoft.PowerApps/apis/shared_commondataserviceforapps"
            }
        }
    }
}
```

> [!TIP]
> Always use a "Status" or "Stage" column in your data source. When one flow finishes its 30-day window or a specific milestone, update the column to trigger the next phase of the process in a fresh flow instance.

### Advanced Configuration

**Calculating Expiry for Approvals:**

When using the "Create an approval" action, you should set a custom timeout or handle the 30-day limit by checking the `request_date` against the current time.

```javascript
// Expression to check if we are approaching the 29th day to trigger a 'renewal' flow
if(greater(daysAgo(-29), body('Get_Item')?['CreatedDate']), 'ApproachingLimit', 'Safe')
```

> [!WARNING]
> If a flow is waiting on an "Approval" action and that approval is not completed within 30 days, the flow will fail with a `TimedOut` error, and the approval record will remain orphaned in the system.

## Common Patterns

### Pattern 1: The "Check-In" Scheduled Pattern

```
[Scheduled Trigger (Daily)] -> [List Records where Status='Pending' AND FollowUpDate <= Today] -> [Apply to Each] -> [Execute Business Logic/Send Reminder] -> [Update Record Next FollowUpDate]
```

This pattern is ideal for long-term reminders. Instead of one flow waiting for 60 days, a scheduled flow runs every day and "picks up" tasks that are due.

### Pattern 2: The Parent-Child State Machine

```
[Parent Flow] -> [Create Record in Dataverse (Status: Phase 1)]
[Child Flow 1 (Trigger: Status=Phase 1)] -> [Do Work] -> [Update Status: Phase 2]
[Child Flow 2 (Trigger: Status=Phase 2)] -> [Do Work] -> [Update Status: Completed]
```

This breaks a 90-day process into three 30-day segments. Each segment is a fresh flow run with its own 30-day clock.

## Performance & Limits

> [!IMPORTANT]
> **Hard Limits:**
> - **Flow Run Duration:** 30 days (Strict).
> - **Approval Timeout:** 30 days (Strict).
> - **Wait for Item Change:** 30 days.
> - **License Requirement:** Per User or Per Flow plans apply; high-frequency polling in long-running scenarios may impact Request Limits (Power Platform Requests).

**Optimization Tips:**
- Use **Dataverse** as the state engine; it is more robust for lookups and status changes than SharePoint.
- Implement **Child Flows** for repeatable logic to keep the main architectural "state machine" clean.
- Use **Terminated** status with a "Succeeded" code to end a flow segment gracefully before the 30-day mark.

**When NOT to use:**
- Do not use this for high-volume, short-lived tasks (under 24 hours); standard flows are more efficient.
- Avoid using "Delay" actions for anything longer than 24 hours if reliability is a concern; a service interruption could cause the delay to fail.

## Interview Questions

### Beginner

**Q:** What happens to a Power Automate flow that has been running for 31 days?

<details>
<summary>Answer</summary>

The flow will automatically time out and its status will be marked as **Failed** (specifically with a `TimedOut` error code). Any actions that were pending, such as an Approval or a Delay, will stop immediately, and no subsequent actions in that flow will execute.

</details>

### Intermediate

**Q:** You need to design a flow for a 45-day legal review process. How do you bypass the 30-day limit?

<details>
<summary>Approach</summary>

**Solution:**
Use a **State Machine pattern** with an external data source (like Dataverse or SharePoint).

1.  Store the process start date and current status in a list/table.
2.  The first flow performs the initial actions and updates the status to "In Review".
3.  Use a **Scheduled Flow** that runs daily to check the "In Review" items.
4.  If the current date is 45 days after the start date, the scheduled flow performs the "Review Overdue" logic.
5.  Alternatively, use a second flow triggered by a status change to handle the second half of the process.

> [!TIP]
> This approach is more resilient because if a flow fails, the data remains in the table, allowing you to restart the process from the last known state.

**Follow-up they'll ask:** "How do you handle the Approval action specifically if it takes 40 days?"  
**Answer:** Set the Approval to timeout at 29 days using the "Settings" menu. Catch the timeout using "Configure Run After," then create a *new* approval and link it to the same record.

</details>

### Advanced

**Q:** Describe the architecture for a multi-stage approval process that could potentially last 6 months, involving multiple departments.

<details>
<summary>Solution</summary>

**Architecture:**

A **Metadata-Driven State Machine**.

1.  **Central Registry:** A Dataverse table storing `ProcessID`, `CurrentStage`, `AssignedTo`, `LastUpdated`, and `PayloadData`.
2.  **The Router Flow:** A single flow triggered by "When a row is added or modified." It uses a `Switch` statement based on the `CurrentStage`.
3.  **Stage Logic:** Each branch of the Switch performs the logic for that stage. At the end of the stage, it updates the `CurrentStage` column.
4.  **Persistence:** Because each stage update triggers a *new* flow run, the 30-day timer resets at every stage transition.

**Key considerations:**

```javascript
// Use a 'Correlation ID' to link multiple flow runs together in logs
triggerOutputs()?['body/cr_correlationid']
```

**Trade-offs to discuss:**
- **Option A (Single Flow with Delays):** Simple to build but impossible for >30 days.
- **Option B (State Machine):** Complex to build and debug, but infinitely scalable and supports processes of any duration.

</details>

## Comparison Table

| Feature | Standard Flow (Delay) | Scheduled Polling | State Machine (Trigger-based) |
|----------|-----------|-----------|---------------|
| **Max Duration** | 30 Days | Unlimited | Unlimited |
| **Complexity** | Low | Medium | High |
| **Reliability** | Low (Single point of failure) | High | Very High |
| **Best Use Case** | Short tasks (< 7 days) | Reminders/Batch updates | Complex, multi-stage enterprise apps |

## Real Example

> [!NOTE]
> **Problem:** A construction company needed a flow to manage a 90-day "Warranty Inspection" period after a house was sold.  
> **Solution:** Instead of a 90-day delay, the flow creates a record in Dataverse with an "Inspection Date." A daily scheduled flow queries for records where `InspectionDate eq today`.  
> **Result:** 100% reliability over 2 years, with the ability to manually adjust the inspection date in Dataverse if neededâ€”something impossible with a hard-coded "Delay" action.

**Implementation:**
```
Trigger: Recurrence (Daily)
Action: List Rows (Dataverse) -> Filter: cr_inspectiondate eq 'utcNow(yyyy-MM-dd)'
Action: Apply to Each -> Send Notification to Inspector
```

## Quick Reference

### Date Expressions for Long Running Flows

```javascript
// Calculate if a date is more than 30 days ago
greater(timestamp(addDays(utcNow(), -30)), timestamp(items('Apply_to_each')?['CreatedDate']))

// Get a date 29 days from now to set a deadline
addDays(utcNow(), 29, 'yyyy-MM-dd')
```

### Related Features

| Feature | Purpose | Key Parameter |
|-----------|-----------|-----------------|
| **Configure Run After** | Catch timeouts of Approvals | Set to "has timed out" |
| **Child Flows** | Encapsulate logic for re-use | Run a Child Flow |
| **Terminated Action** | End a flow segment as "Succeeded" | Status: Succeeded |

## Practice

**Exercise 1:** Design a logic flow that waits for a "Contract End Date" which could be 1 year in the future, then sends an email.

<details>
<summary>Hint</summary>

Do not use the "Wait for a date" action, as it will time out at 30 days. Think about how to use a daily check.

</details>

<details>
<summary>Solution</summary>

1.  **Data Source:** Store the Contract in SharePoint/Dataverse with a `ContractEndDate` column.
2.  **Flow:** Create a **Scheduled Cloud Flow**.
3.  **Frequency:** Set to run once per day.
4.  **Logic:**
    - `List rows` where `ContractEndDate` is equal to `addDays(utcNow(), 0, 'yyyy-MM-dd')`.
    - `Apply to each` result: Send an email to the account owner.

**Key points:**
```javascript
// Filter Query (OData)
cr_contractenddate eq '@{utcNow('yyyy-MM-dd')}'
```

</details>

## Troubleshooting Guide

> [!CAUTION]
> **Common Errors:**

| Error | Cause | Fix |
|-------|-------|-----|
| `ActionTimedOut` | An Approval or Delay reached the 30-day limit. | Implement a State Machine or use "Run After" to catch the timeout and restart. |
| `FlowRunLongerThan30Days` | The flow logic itself took too long to complete. | Break the flow into smaller, trigger-based segments. |
| `RequestLimitExceeded` | Scheduled flow polling too many records every hour. | Optimize OData filter queries to only return necessary rows. |

## Tags
#architecture #long-running #30-day-limit #state-machine #approvals