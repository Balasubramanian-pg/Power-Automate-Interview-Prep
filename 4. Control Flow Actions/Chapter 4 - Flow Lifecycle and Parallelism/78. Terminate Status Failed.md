# Power Automate Interview Prep: Terminate Status Failed

**Last Updated:** 2024-05-24  
**Confidence:** ðŸŸ¢ Solid  
**Category:** Actions | Control | Error Handling

## What Is It?

The Terminate action with a "Failed" status is a control flow mechanism that immediately halts the execution of a flow run and explicitly marks the run's final status as "Failed" in the environment's run history.

**Why It Matters:**  
It is the cornerstone of professional error handling. Without it, a flow that encounters a logical error (like a missing file or a failed validation) might either continue incorrectly or end with a "Succeeded" status, making it impossible for administrators to monitor failures or for the Center of Excellence (CoE) toolkit to track health metrics.

## Core Concepts

- **Terminal State** - Unlike the "Scope" or "Condition" actions, Terminate is an end-point; no actions placed after it in the same execution path will ever run.
- **Custom Error Code** - A user-defined string (e.g., `INV_001`) that allows for programmatic filtering and categorization of failures in the run history.
- **Error Message** - A descriptive string, often dynamic, that provides context to the failure (e.g., "The user 'John Doe' does not have sufficient permissions to approve this expense").

## Implementation

### Basic Setup

**Terminate Action Configuration:**

```json
{
    "inputs": {
        "status": "Failed",
        "code": "USER_VALIDATION_FAILED",
        "message": "The requested item was not found in the SharePoint list."
    }
}
```

> [!TIP]
> Always use a dynamic expression in the "Message" field to include the specific ID or Name of the record that caused the failure to speed up debugging.

### Advanced Configuration

Using the `result()` expression to pass the actual error from a failed Scope into the Terminate action:

```javascript
// Example expression to extract the error message from a failed Scope named 'Main_Logic'
first(filter(result('Main_Logic'), equals(item()?['status'], 'Failed')))?['error']?['message']
```

> [!WARNING]
> If you place a Terminate action inside a branch, only that specific run instance stops. However, if you have parallel branches, the Terminate action will stop the entire flow run immediately, regardless of what other branches are doing.

## Common Patterns

### Pattern 1: The Try-Catch Block

```
Scope: Try
   |-- Action 1
   |-- Action 2
Scope: Catch (Configure Run After: Has Failed)
   |-- Send Notification
   |-- Terminate (Status: Failed)
```

This is the standard pattern for enterprise flows. The Terminate action ensures that even though the "Catch" scope succeeded in handling the error, the overall flow run is still marked as a failure for monitoring purposes.

### Pattern 2: Guard Clauses (Validation)

```
Trigger: When an item is created
Condition: Is 'Price' greater than 0?
   |-- No: Terminate (Status: Failed, Code: INVALID_DATA)
   |-- Yes: Continue processing...
```

Used to stop the flow early if business prerequisites are not met, preventing unnecessary API calls or downstream logic execution.

## Performance & Limits

> [!IMPORTANT]
> **Execution Limits:**
> - **Immediate Stop:** Terminate is near-instantaneous; it does not wait for asynchronous child flows unless they are called synchronously.
> - **Run History:** Marking a flow as "Failed" triggers any environment-level alerts or Power Platform Admin Center notifications.
> - **License:** Available on all Power Automate plans as a standard Control action.

**Optimization Tips:**
- Use specific **Error Codes** to enable easy filtering in the Power Automate Management connector.
- Combine Terminate with **Post-failure notifications** (Teams/Email) so the team is alerted before the run ends.
- Do not use Terminate if you want the flow to be retried automatically; "Failed" status usually stops the retry policy.

**When NOT to use:**
- Do not use "Failed" if the flow reached a logical conclusion that isn't an error (use "Succeeded" or "Cancelled" instead).
- Do not use it inside a loop if you want the loop to continue processing other items after one failure.

## Interview Questions

### Beginner

**Q:** What is the difference between the "Failed" status and the "Cancelled" status in a Terminate action?

<details>
<summary>Answer</summary>

**Failed:** Indicates the flow encountered an error or a business rule violation that prevented completion. It is flagged as an error in analytics.

**Cancelled:** Indicates the flow was stopped intentionally, often by a user or a timeout, but not necessarily because of a system error. It is often used in long-running approvals.

</details>

---

### Intermediate

**Q:** If you have a "Catch" scope that sends an email when an error occurs, and the flow ends there, what will the run status be in the history? How do you fix it?

<details>
<summary>Approach</summary>

**Solution:**
The run status will be **Succeeded** because the last action (sending the email) completed successfully. To fix this, you must add a **Terminate** action with the status **Failed** as the very last step inside the Catch scope.

```json
{
  "runAfter": {
    "Send_Error_Email": ["Succeeded"]
  },
  "type": "Terminate",
  "inputs": { "status": "Failed" }
}
```

> [!TIP]
> This is a common "gotcha" in Power Automate development. Always terminate with failure after handling an exception if you want the run history to be accurate.

**Follow-up they'll ask:** "Can you still see the error message if you don't use Terminate?"  
**Answer:** Only by manually digging into the "Try" scope; the high-level dashboard will misleadingly show a green checkmark.

</details>

---

### Advanced

**Q:** How would you implement a global error handling strategy for a Parent Flow that calls multiple Child Flows, ensuring the Parent fails if any Child fails?

<details>
<summary>Solution</summary>

**Architecture:**

1.  **Child Flow:** Must contain its own Try/Catch. If an error occurs, the Catch block should use the **Respond to a Power App or flow** action to send a "Success" flag (false) and an "ErrorMessage" back to the parent, then **Terminate (Succeeded)**.
2.  **Parent Flow:** Checks the "Success" flag returned by the Child Flow.
3.  **Logic:** If `Success == false`, the Parent Flow calls a **Terminate (Failed)** action, passing the "ErrorMessage" from the child.

**Key considerations:**
If the Child Flow uses **Terminate (Failed)**, the Parent Flow's "Run After" for that action must be set to "Has Failed" to catch the error, otherwise, the Parent will simply crash at that step.

**Trade-offs to discuss:**
- **Option A (Child Fails):** Parent must use "Run After" configurations. Harder to maintain but more "native" feeling.
- **Option B (Child Returns Error Object):** Parent uses standard Conditions. Easier to read and allows for more graceful cleanup in the Parent.

</details>

## Comparison Table

| Feature | Terminate (Failed) | Terminate (Cancelled) | Terminate (Succeeded) |
|----------|-----------|-----------|---------------|
| **Run History Color** | Red | Grey | Green |
| **Analytics Impact** | Counted as Failure | Counted as Cancelled | Counted as Success |
| **Use Case** | Try/Catch, Logic Errors | Timeouts, Manual Stop | Early Exit (Valid) |
| **Custom Code** | Supported | Supported | Not Supported |

## Real Example

> [!NOTE]
> **Problem:** A financial processing flow was completing with "Succeeded" even when the bank API rejected the transaction, leading to missed payments.  
> **Solution:** Implemented a condition to check the API response code. If not 200, the flow sends a Teams alert to the Treasury team and triggers a Terminate action with status "Failed".  
> **Result:** 100% visibility into failed transactions via the Power BI Flow Health dashboard.

**Implementation:**
```text
Action: HTTP Call to Bank
Condition: If Status Code != 200
   |-- True: 
       |-- Action: Post Teams Message (Error Details)
       |-- Action: Terminate (Status: Failed, Code: BANK_API_ERR)
```

## Quick Reference

### Common Expressions for Terminate Messages

```javascript
// Get the error message from the previous failed action
actions('Action_Name')?['error']?['message']

// Get the current environment name for context
workflow()?['tags']?['environmentName']

// Get the run URL to include in the error message
concat('https://make.powerautomate.com/environments/', workflow()?['tags']?['environmentName'], '/flows/', workflow()?['name'], '/runs/', workflow()?['run']?['name'])
```

## Practice

**Exercise 1:** Create a flow that accepts a number via manual trigger. If the number is less than 10, the flow should end with a "Failed" status and a custom message. If it is 10 or greater, it should succeed.

<details>
<summary>Hint</summary>

Use a "Condition" action. In the "If no" (or "If yes" depending on your logic) branch, search for the "Terminate" action and set the dropdown to "Failed".

</details>

<details>
<summary>Solution</summary>

1. **Trigger:** Manually trigger a flow (Input: `UserNumber`).
2. **Condition:** `UserNumber` is less than 10.
3. **True Branch:**
   - Add **Terminate** action.
   - Status: **Failed**.
   - Code: `VALUE_TOO_LOW`.
   - Message: `concat('The value ', triggerBody()?['number'], ' is below the minimum threshold of 10.')`.
4. **False Branch:**
   - Add **Compose** (Message: "Success").

**Key points:**
The `concat` expression ensures the error message is helpful for debugging.

</details>

## Troubleshooting Guide

> [!CAUTION]
> **Common Errors:**

| Error | Cause | Fix |
|-------|-------|-----|
| **ActionNotReached** | The Terminate action is inside a branch where the "Run After" settings of a previous action were not met. | Check the "Configure Run After" settings of the Terminate action or the Scope containing it. |
| **InvalidTemplate** | Using a dynamic expression in the "Code" field that returns a non-string value. | Wrap your expression in the `string()` function. |
| **Flow shows Succeeded** | The Terminate action was skipped because a Condition evaluated to the wrong branch. | Use the "Run History" to trace the path and verify your logic operators (e.g., using "less than" instead of "greater than"). |

## Tags
#ErrorHandling #Governance #ControlFlow #BestPractices #Architecture