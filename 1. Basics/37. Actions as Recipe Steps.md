# 37. Actions as Recipe Steps

Canonical documentation for 37. Actions as Recipe Steps. This document defines concepts, terminology, and standard usage.

## Purpose
The concept of "Actions as Recipe Steps" addresses the need for modularity, reusability, and abstraction in automated workflows. By decomposing complex processes into discrete, repeatable units (Actions) and organizing them into a structured sequence (a Recipe), systems can achieve higher levels of maintainability and scalability. This approach separates the *logic of execution* (the Action) from the *logic of orchestration* (the Recipe).

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative.

## Scope
**In scope:**
* The abstraction of discrete tasks into standardized units.
* The relationship between individual actions and the overarching workflow.
* Data flow and state management between steps.
* Execution lifecycle of a step within a recipe.

**Out of scope:**
* Specific syntax for third-party automation platforms (e.g., YAML for GitHub Actions, JSON for AWS Step Functions).
* Hardware-specific execution details.
* Programming language-specific implementation of action handlers.

## Definitions
| Term | Definition |
|------|------------|
| **Action** | A discrete, atomic unit of work that performs a specific task (e.g., "Send Email," "Update Database"). |
| **Recipe** | A declarative or imperative sequence of Actions designed to achieve a specific outcome. |
| **Step** | The specific instantiation or invocation of an Action within a Recipe, including its configuration and input mapping. |
| **Input Mapping** | The process of passing data from the Recipe context or previous Steps into the current Action. |
| **Output Mapping** | The process of capturing the result of an Action and making it available to the Recipe context. |
| **Provider** | The underlying engine or service responsible for executing the logic defined by an Action. |

## Core Concepts

### 1. Atomicity
An Action should ideally perform one task and one task only. This ensures that the Action is predictable, testable, and reusable across different Recipes. If an Action becomes too complex, it should be decomposed into multiple Steps.

### 2. Encapsulation
The Recipe should not need to know the internal implementation details of an Action. It only interacts with the Action through a defined interface: Inputs, Outputs, and Status Codes.

### 3. Idempotency
In a robust system, an Action as a Recipe Step should ideally be idempotent. This means that executing the same Step multiple times with the same inputs should result in the same state, preventing unintended side effects during retries or failures.

### 4. Context Awareness
While Actions are independent, Steps are context-aware. A Step exists within the lifecycle of a Recipe and has access to the "Recipe Context"â€”a shared data space containing configuration, environment variables, and outputs from preceding Steps.

## Standard Model

The standard model for Actions as Recipe Steps follows a linear or branched lifecycle:

1.  **Initialization:** The Recipe engine identifies the next Step and resolves its input requirements from the Context.
2.  **Validation:** The engine ensures all required inputs are present and meet the Action's schema.
3.  **Invocation:** The Action is triggered via its Provider.
4.  **Execution:** The Provider performs the work. The Recipe engine monitors for completion, timeout, or failure.
5.  **Output Capture:** Upon completion, the Action returns data. The Recipe engine maps this data back to the Context.
6.  **Transition:** The engine determines the next Step based on the outcome (Success, Failure, or Conditional logic).

## Common Patterns

### The Chain Pattern
Steps are executed sequentially, where the output of Step A is the direct input for Step B. This is the most common pattern for data processing pipelines.

### The Fan-Out/Fan-In Pattern
A single Step triggers multiple instances of an Action in parallel (Fan-Out). A subsequent Step waits for all parallel actions to complete before aggregating the results (Fan-In).

### The Guard Pattern
A Step is preceded by a conditional check. The Action is only executed if specific criteria in the Recipe Context are met, preventing unnecessary resource consumption.

### The Compensation Pattern
If a Step fails, a specific "Undo" Action is triggered to revert the system to its previous state, ensuring transactional integrity across the Recipe.

## Anti-Patterns

### The God Step
An Action that attempts to perform the entire logic of the Recipe within a single unit. This defeats the purpose of modularity and makes debugging nearly impossible.

### Hardcoded Dependencies
Configuring a Step with hardcoded values that should be dynamic. This prevents the Recipe from being reused in different environments (e.g., staging vs. production).

### Silent Failures
Actions that do not return explicit success or failure signals. This leads to "zombie" Recipes that appear to be running but have actually stalled or failed internally.

### Circular References
A Recipe where Step A triggers Step B, which eventually triggers Step A again without a termination condition, leading to infinite loops and resource exhaustion.

## Edge Cases

*   **Long-Running Actions:** Actions that exceed the standard timeout of the Recipe engine. These require asynchronous "callback" or "polling" mechanisms to update the Step status.
*   **Partial Success:** An Action that performs multiple sub-tasks where some succeed and others fail. The Recipe must define whether this constitutes a "Success" or "Failure" state.
*   **Context Bloat:** When a Recipe contains hundreds of Steps, the shared Context can become excessively large, leading to performance degradation in data mapping.
*   **Orphaned Steps:** When a Recipe is terminated prematurely, some Actions (especially those involving external infrastructure) may remain in a "running" state without a controller.

## Related Topics
*   **Workflow Orchestration:** The broader management of complex task sequences.
*   **State Machines:** The mathematical model often used to govern Recipe transitions.
*   **Event-Driven Architecture:** Where Recipes are triggered by external events rather than manual invocation.
*   **Error Handling and Retry Policies:** Standardized methods for managing Step failures.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-16 | Initial AI-generated canonical documentation |