# 62. Connectors as Bridges to Services

Canonical documentation for 62. Connectors as Bridges to Services. This document defines concepts, terminology, and standard usage.

## Purpose
The concept of "Connectors as Bridges" addresses the fundamental challenge of interoperability in distributed computing. In modern architectures, applications rarely exist in isolation; they must interact with a diverse ecosystem of external services, legacy databases, and third-party APIs. 

Connectors serve as an abstraction layer that decouples the core business logic of a host system from the technical specificities of external services. By acting as a bridge, a connector standardizes communication, manages security contexts, and translates data formats, allowing the host system to interact with disparate services through a uniform interface. This reduces architectural rigidity and minimizes the "integration debt" associated with direct, point-to-point coupling.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative. It focuses on the architectural role of connectors rather than specific software development kits (SDKs) or vendor-specific integration platforms.

## Scope
Clarify what is in scope and out of scope for this topic.

**In scope:**
* **Abstraction Mechanisms:** How connectors hide the complexity of underlying protocols.
* **Interface Standardization:** The role of connectors in providing a consistent API to the host system.
* **Lifecycle and State:** Management of connections, sessions, and authentication states.
* **Data Transformation:** The translation of data between host-native formats and service-specific schemas.

**Out of scope:**
* **Specific Vendor Implementations:** Detailed guides for specific platforms (e.g., MuleSoft, Zapier, Azure Logic Apps).
* **Network Layer Engineering:** Deep dives into TCP/IP, DNS, or physical networking, except where they intersect with connector logic.
* **General API Design:** While related, this document focuses on the *bridge* between systems, not the design of the services themselves.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **Connector** | A specialized software component that facilitates communication between a host application and an external service by providing an abstraction layer. |
| **Host System** | The primary environment or application that utilizes a connector to reach an external service. |
| **Target Service** | The external system, API, or resource that the connector provides access to. |
| **Protocol Translation** | The process of converting requests from the host's internal protocol (e.g., gRPC) to the target service's protocol (e.g., SOAP). |
| **Schema Mapping** | The translation of data structures from the host's domain model to the target service's data model. |
| **Credential Passthrough** | A security pattern where the connector forwards the host's identity tokens to the target service. |
| **Connection Pooling** | The maintenance of a cache of reusable connections to improve performance and resource utilization. |

## Core Concepts

### 1. The Abstraction Layer
The primary function of a connector is to shield the host system from the "how" of a service. The host system should only need to know "what" it wants to achieve. The connector handles the underlying complexities such as retries, circuit breaking, and header management.

### 2. Protocol and Data Normalization
Services use various protocols (REST, GraphQL, AMQP, WebSockets) and data formats (JSON, XML, Avro). Connectors normalize these into a standard format understood by the host system, ensuring that the business logic remains agnostic of the external service's technical stack.

### 3. Security and Context Propagation
Connectors act as the enforcement point for security. They manage authentication (OAuth2, API Keys, mTLS) and ensure that the security context of the request is either mapped, translated, or securely passed through to the target service.

### 4. Connectivity Lifecycle
A connector manages the lifecycle of a connection, including initialization (handshaking), maintenance (keep-alives), and graceful termination. This prevents resource leaks in the host system.

## Standard Model
The standard model for a Connector as a Bridge consists of three distinct layers:

1.  **Host Interface Layer:** The "Northbound" interface. It exposes a standardized set of methods or events to the host system.
2.  **Logic & Transformation Layer:** The "Bridge" core. This layer performs data mapping, applies business rules for the connection, handles error mapping, and manages stateful operations like caching or pooling.
3.  **Service Adapter Layer:** The "Southbound" interface. This layer contains the specific drivers and protocol logic required to communicate with the target service.

## Common Patterns

### The Proxy Pattern
The connector acts as a transparent intermediary. The host system sends a request that looks very similar to the target service's requirements, and the connector adds necessary headers, authentication, and logging.

### The Wrapper Pattern
The connector wraps a complex or "chatty" API into a single, simplified call for the host system. This is often used when a single logical action in the host requires multiple sequential calls to the target service.

### The Event-Bridge Pattern
Used in asynchronous architectures. The connector listens for events in the target service (via webhooks or polling) and translates them into internal events for the host system's event bus.

### The Sidecar Pattern
In microservices, the connector resides in a separate process or container alongside the host application, handling all external service traffic to offload networking concerns from the application code.

## Anti-Patterns

### Leaky Abstractions
Occurs when the connector fails to hide the underlying service's complexities, forcing the host system to handle service-specific errors, status codes, or data structures.

### Hardcoded Coupling
Embedding service-specific logic directly into the host system's core business logic instead of isolating it within the connector. This makes it difficult to swap services or update versions.

### The "God" Connector
Creating a single connector that attempts to bridge too many unrelated services. This leads to a bloated, fragile component that is difficult to maintain and deploy.

### Ignoring Backpressure
Failing to implement flow control within the connector. If the target service is slow, a poorly designed connector may allow the host system to overwhelm it, leading to cascading failures.

## Edge Cases

*   **Version Mismatch:** When the target service updates its API but the connector has not yet been updated. Robust connectors should implement version negotiation or graceful degradation.
*   **Partial Failures:** In a multi-step bridge operation, some calls to the target service succeed while others fail. The connector must decide whether to roll back, retry, or return a partial success to the host.
*   **Large Payload Streaming:** When the data being bridged exceeds the memory limits of the connector. The connector must implement streaming or chunking mechanisms rather than buffering the entire payload.
*   **Transient Network Partitions:** Handling scenarios where the "bridge" is physically intact but the target service is unreachable due to intermittent network issues, requiring sophisticated retry and jitter logic.

## Related Topics
*   **API Gateway:** Often acts as a collection of connectors for external consumers.
*   **Service Mesh:** Provides infrastructure-level bridging and observability.
*   **Middleware:** The broader category of software that connects disparate systems.
*   **Adapter Design Pattern:** The software engineering pattern that underpins connector development.

## Change Log

| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-16 | Initial AI-generated canonical documentation |