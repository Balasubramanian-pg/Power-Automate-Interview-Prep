# 75. Common Expression Functions

Canonical documentation for 75. Common Expression Functions. This document defines concepts, terminology, and standard usage.

## Purpose
Common Expression Functions provide a standardized library of operations used to transform, evaluate, and manipulate data within an expression language or runtime environment. They exist to bridge the gap between raw data storage and application logic, allowing for declarative data processing. By providing a consistent set of functional primitives, systems can ensure predictable behavior across different modules, reduce the need for custom imperative code, and facilitate data interoperability.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative.

## Scope
Clarify what is in scope and out of scope for this topic.

**In scope:**
*   Functional categories (String, Numeric, Temporal, Logical, etc.).
*   Input/Output behavior and type expectations.
*   The concept of determinism in expression evaluation.
*   Standardized error handling paradigms for functions.

**Out of scope:**
*   Specific syntax variations (e.g., `LEN()` vs `LENGTH()`).
*   Performance benchmarks for specific database engines or programming languages.
*   Vendor-specific proprietary extensions.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| Expression | A combination of one or more values, constants, variables, and functions that the host environment evaluates to produce a result. |
| Function | A named, reusable unit of logic that accepts zero or more arguments and returns a single value. |
| Argument | An input value passed to a function that influences its output. |
| Determinism | A property of a function where the same input values always produce the exact same output value. |
| Arity | The number of arguments or operands that a function takes. |
| Coalescence | The process of selecting the first non-null value from a list of expressions. |
| Casting | The explicit conversion of a value from one data type to another within an expression. |

## Core Concepts

### Evaluation Context
Functions do not exist in a vacuum; they operate within an evaluation context. This context provides the necessary state, such as the current record, global variables, or system metadata (e.g., current timestamp), which functions may reference as implicit inputs.

### Data Type Constraints
Every function has a defined signature consisting of expected input types and a guaranteed return type. Type safety in expressions ensures that operations (e.g., mathematical addition) are not attempted on incompatible types (e.g., strings) unless an implicit or explicit conversion occurs.

### Functional Purity
In the context of expression languages, most common functions are "pure." They do not modify the state of the system or the input variables (no side effects). They simply return a new value based on the inputs provided.

## Standard Model

The standard model for expression functions categorizes them by the data types they manipulate:

### 1. String Functions
Used for the manipulation of character data.
*   **Transformation:** Converting case (Upper/Lower), trimming whitespace, or padding.
*   **Extraction:** Substring retrieval, character indexing, or regex matching.
*   **Analysis:** Calculating length or counting occurrences.

### 2. Numeric and Mathematical Functions
Used for arithmetic and statistical operations.
*   **Arithmetic:** Basic operations (Add, Subtract, Multiply, Divide, Modulo).
*   **Rounding:** Ceiling, Floor, Round (to nearest integer or decimal place).
*   **Advanced Math:** Absolute values, square roots, powers, and logarithmic functions.

### 3. Temporal (Date/Time) Functions
Used for handling points in time and durations.
*   **Retrieval:** Getting the current system date or time.
*   **Arithmetic:** Adding or subtracting intervals (days, months, years) from a date.
*   **Extraction:** Isolating components (Year, Month, Day, Hour, Minute).
*   **Formatting:** Converting date objects into specific string representations.

### 4. Logical and Conditional Functions
Used for flow control and boolean evaluation.
*   **Comparison:** Equality, inequality, and range checks (Greater than, Less than).
*   **Boolean Logic:** AND, OR, NOT.
*   **Branching:** If-Then-Else logic or Case/Switch structures.

### 5. Null and Error Handling Functions
Used to manage missing or invalid data.
*   **Null Check:** Identifying if a value is null.
*   **Defaulting:** Providing a fallback value when a primary value is null (Coalesce).

## Common Patterns

### Chaining and Nesting
Functions are frequently nested to perform complex transformations in a single evaluation cycle. The output of an inner function serves as the input for an outer function (e.g., `ROUND(SQRT(value))`).

### Predicate Evaluation
Functions are often used within predicates to filter data sets. A function evaluates a property of a record, and the resulting boolean determines the record's inclusion in a result set.

### Type Normalization
A common pattern involves wrapping raw inputs in conversion functions (Casting) to ensure that subsequent mathematical or string operations do not fail due to type mismatches.

## Anti-Patterns

### Over-Nesting (The "Pyramid of Doom")
Deeply nesting functions (e.g., 10+ levels) makes expressions unreadable and difficult to debug. It is often better to break these into intermediate calculated fields if the host environment allows.

### Ignoring Null Propagation
Assuming that a function will return a valid value even if one of its arguments is null. In many systems, `Function(NULL)` returns `NULL`, which can lead to unexpected "silent" failures in complex expressions.

### Using Non-Deterministic Functions in Keys
Using functions like `CURRENT_TIMESTAMP()` or `RANDOM()` in logic that requires stability (such as indexing or unique identifier generation) leads to inconsistent data states.

## Edge Cases

### Division by Zero
While mathematically undefined, different implementations handle this differently (e.g., returning NULL, returning Infinity, or throwing a fatal error). Canonical expressions should include defensive logic to handle zero denominators.

### Timezone Ambiguity
Temporal functions often rely on the system's local time. When expressions are evaluated across distributed systems in different timezones, the "Current Date" may vary, leading to inconsistent results.

### Floating Point Precision
Mathematical functions involving floating-point numbers may encounter precision errors (e.g., `0.1 + 0.2 != 0.3`). This is a critical edge case for financial or scientific calculations.

### Character Encoding
String functions (like Length or Substring) may behave differently depending on whether they count bytes or characters, especially when dealing with multi-byte UTF-8 characters or emojis.

## Related Topics
*   **Data Typing and Schema:** The underlying structures that functions operate upon.
*   **Regular Expressions:** A specialized subset of string functions for pattern matching.
*   **Aggregate Functions:** Functions that operate on sets of data rather than individual values (e.g., SUM, AVG).
*   **Lazy Evaluation:** An optimization technique where expressions are only evaluated when their result is strictly required.

## Change Log

| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-16 | Initial AI-generated canonical documentation |