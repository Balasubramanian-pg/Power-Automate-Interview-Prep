# 65. Standard Connector Examples

Canonical documentation for 65. Standard Connector Examples. This document defines concepts, terminology, and standard usage.

## Purpose
The purpose of Standard Connector Examples is to provide a conceptual framework for the pre-built, reusable interfaces used to facilitate communication between disparate software systems. In modern architecture, connectors serve as the abstraction layer that decouples the core logic of an application from the specificities of external protocols, data formats, and authentication mechanisms. By defining standard examples, organizations can ensure interoperability, reduce development overhead, and maintain a consistent security posture across integrated environments.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative. It focuses on the architectural archetypes of connectors rather than specific vendor products.

## Scope
Clarify what is in scope and out of scope for this topic.

**In scope:**
* **Protocol-based Connectors:** Standardized methods for data exchange over networks.
* **Data Store Connectors:** Interfaces for interacting with structured and unstructured data repositories.
* **Messaging and Event Connectors:** Patterns for asynchronous communication.
* **File-based Connectors:** Mechanisms for handling bulk data transfer via file systems.
* **Structural Requirements:** The necessary components that constitute a "standard" connector.

**Out of scope:**
* Specific vendor implementations (e.g., Salesforce, SAP, or AWS-specific SDKs).
* Programming language-specific library syntax.
* Hardware-level physical connectors (e.g., USB, Ethernet).

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| Connector | A specialized software component that mediates communication between an application and an external resource. |
| Protocol | A standardized set of rules that determine how data is transmitted between different devices or applications. |
| Abstraction Layer | A way of hiding the implementation details of a particular set of functionality, allowing the system to be used independently of its underlying complexity. |
| Schema | The formal definition of the data structure expected or returned by a connector. |
| Authentication Provider | The mechanism within a connector responsible for managing identity and access tokens (e.g., OAuth2, Basic Auth). |
| Sink | The destination system or component where data is delivered by a connector. |
| Source | The origin system or component from which a connector retrieves data. |

## Core Concepts
The fundamental ideas behind standard connectors revolve around **Encapsulation** and **Normalization**.

### 1. Encapsulation of Complexity
A standard connector encapsulates the technical details of an external system—such as retry logic, connection pooling, and header management—presenting a simplified interface to the developer.

### 2. Data Normalization
Connectors often perform a translation layer function, converting system-specific data formats (e.g., a proprietary binary format) into a standardized format (e.g., JSON or XML) that the consuming application can process.

### 3. Lifecycle Management
Standard connectors manage the lifecycle of a connection, including initialization (handshake), active state maintenance (keep-alive), and graceful termination.

## Standard Model
The standard model for a connector consists of four primary layers:

1.  **Transport Layer:** Defines the physical or logical path (e.g., HTTP/S, TCP, FTP).
2.  **Security Layer:** Handles credentials, encryption (TLS), and authorization.
3.  **Transformation Layer:** Maps external data structures to internal canonical models.
4.  **Interaction Layer:** Defines the operations available (e.g., GET, POST, PUSH, SUBSCRIBE).

## Common Patterns
Standard connectors typically fall into one of the following recurring patterns:

### 1. The Request-Response Connector (Synchronous)
Used for real-time interactions where the system waits for a confirmation or data return.
*   *Example:* A RESTful API connector using HTTP methods to query a remote database.

### 2. The Pub/Sub Connector (Asynchronous)
Used for event-driven architectures where the connector listens for messages on a topic or queue.
*   *Example:* An AMQP or MQTT connector that triggers logic upon the arrival of a new message.

### 3. The Batch/Bulk Connector
Designed for high-volume data movement, often involving file compression and chunking.
*   *Example:* An SFTP or Cloud Storage connector that moves large datasets on a scheduled interval.

### 4. The Database Connector
Provides a bridge between application code and structured query languages.
*   *Example:* A standard JDBC or ODBC-compliant interface for relational data access.

## Anti-Patterns
Common mistakes or discouraged practices in connector implementation:

*   **The "God" Connector:** Creating a single connector that attempts to handle multiple unrelated protocols or business domains, leading to high fragility.
*   **Hardcoded Credentials:** Embedding authentication secrets directly within the connector logic rather than using a secure vault or environment variables.
*   **Ignoring Backpressure:** Failing to implement flow control, which allows a fast source to overwhelm a slow sink.
*   **Passthrough Error Blindness:** Passing raw, unmapped errors from the external system directly to the end-user without logging or sanitization.

## Edge Cases
Explain unusual, ambiguous, or boundary scenarios.

*   **Schema Drift:** When the external system changes its data structure without notice, the connector must handle the mismatch gracefully (e.g., via "dead letter" queues or strict validation).
*   **Large Payload Fragmentation:** Handling files or messages that exceed the maximum transmission unit (MTU) or memory limits of the connector host.
*   **Zombie Connections:** Scenarios where a connection remains "open" in the connector state but has been severed at the network layer, requiring robust heartbeat checks.
*   **Pagination Exhaustion:** When a connector requests data from a source that returns millions of records, the connector must manage stateful pagination to avoid timeouts.

## Related Topics
*   **64. Integration Patterns:** The broader architectural strategies for connecting systems.
*   **66. API Gateway Standards:** How connectors are managed and exposed at the edge.
*   **70. Authentication Frameworks:** Deep dive into the security protocols used by connectors.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-16 | Initial AI-generated canonical documentation |