# 47. Send Push Notification

Canonical documentation for 47. Send Push Notification. This document defines concepts, terminology, and standard usage.

## Purpose
The "Send Push Notification" process exists to facilitate asynchronous, server-initiated communication with a client application. It addresses the need for real-time information delivery to users who are not actively interacting with an application, or to update application state in the background without requiring a polling mechanism. This capability is fundamental to user engagement, time-sensitive alerting, and cross-device synchronization.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative.

## Scope
Clarify what is in scope and out of scope for this topic.

**In scope:**
* The lifecycle of a push notification from server initiation to client receipt.
* The architectural relationship between the Application Server, the Push Service Provider (Gateway), and the Client Device.
* Payload structures and delivery semantics.
* Consent and registration management.

**Out of scope:**
* Specific vendor API specifications (e.g., FCM, APNs, WebPush).
* UI/UX design guidelines for notification appearance.
* SMS or Email delivery mechanisms.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **Push Token** | A unique identifier issued by a push service to a specific app instance on a specific device, used as the routing address for notifications. |
| **Push Service (Gateway)** | An intermediary platform (usually managed by the OS vendor) that routes notifications from application servers to end-user devices. |
| **Payload** | The data packet sent to the client, typically consisting of a display component (title/body) and/or a data component (key-value pairs). |
| **Time-to-Live (TTL)** | A duration specifying how long a push service should attempt to deliver a message if the destination device is offline. |
| **Silent Push** | A notification that does not trigger a user-facing alert, used instead to wake the application to perform background tasks. |
| **Registration** | The process by which a client application obtains a Push Token and transmits it to the Application Server. |

## Core Concepts
### The Push Lifecycle
The push notification process follows a distinct lifecycle:
1.  **Registration:** The client app requests a token from the Push Service and sends it to the Application Server.
2.  **Trigger:** An event on the Application Server determines that a notification must be sent.
3.  **Dispatch:** The Application Server sends the payload and the target Push Token to the Push Service.
4.  **Routing:** The Push Service identifies the device and transmits the data over a persistent connection.
5.  **Receipt:** The device OS receives the data and determines whether to display a notification or wake the app.

### Delivery Guarantees
Push notifications are generally "best-effort" delivery. They are not intended for high-durability messaging where 100% delivery is legally or technically required without fallback mechanisms. Factors such as network stability, battery optimization, and user-revoked permissions can prevent delivery.

### Trust and Security
Security in push notifications relies on two pillars:
*   **Server Authentication:** The Application Server must prove its identity to the Push Service (usually via JWT or SSL certificates).
*   **Token Integrity:** The Push Token must be treated as a sensitive credential, as it allows the holder to send data to a specific user device.

## Standard Model
The standard model for push notifications is a **Triangular Architecture**:

1.  **The Client (Subscriber):** Requests a token and listens for incoming signals.
2.  **The Application Server (Publisher):** Stores tokens and initiates the push request based on business logic.
3.  **The Push Service (Intermediary):** Acts as the post office, maintaining the persistent socket connection to the device and managing the queue for offline devices.

## Common Patterns
*   **Transactional:** Notifications triggered by a specific user action or account event (e.g., "Your order has shipped").
*   **Broadcast/Marketing:** Sending the same message to a large segment of the user base simultaneously.
*   **Data-Only (Silent):** Used to trigger background synchronization, such as updating a local database or clearing a cache, without notifying the user.
*   **Localized Push:** Sending a generic key in the payload that the client app translates into the user's local language upon receipt.

## Anti-Patterns
*   **Payload Overloading:** Including large amounts of data or sensitive PII (Personally Identifiable Information) in the push payload. Payloads should be lightweight and pointers to data, not the data itself.
*   **Token Hoarding:** Failing to implement a "feedback loop" to remove expired or invalid tokens from the Application Server database.
*   **Frequency Exhaustion:** Sending too many notifications, leading to "notification fatigue" and causing users to disable permissions at the OS level.
*   **Synchronous Dispatch:** Attempting to send thousands of push notifications in a single synchronous request thread rather than using an asynchronous message queue.

## Edge Cases
*   **Token Rotation:** Push Services may rotate tokens periodically. The application must be able to detect a token change and update the Application Server accordingly.
*   **Offline/Airplane Mode:** If a device is offline longer than the TTL, the message is discarded by the Push Service.
*   **App Uninstallation:** The Push Service may not immediately know an app is uninstalled; delivery failure feedback is often delayed.
*   **Permission Revocation:** A user may revoke notification permissions at the OS level without the Application Server being notified, resulting in "successful" dispatches that are never displayed.
*   **Device Throttling:** OS-level power management (e.g., Doze mode) may delay the delivery of non-high-priority notifications to preserve battery.

## Related Topics
*   **48. Device Token Management:** The lifecycle of storing and validating push tokens.
*   **12. User Consent Framework:** Managing legal and technical permissions for communication.
*   **85. Real-time WebSockets:** An alternative for active-session communication.
*   **92. Background Task Scheduling:** How apps handle data received via silent pushes.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-16 | Initial AI-generated canonical documentation |