# 36. Understanding Actions

Canonical documentation for 36. Understanding Actions. This document defines concepts, terminology, and standard usage.

## Purpose
The concept of an **Action** exists to provide a formal mechanism for expressing intent within a system. By decoupling the *declaration* of what should happen from the *logic* of how it is executed, systems achieve greater modularity, traceability, and predictability. Actions serve as the primary interface for state transitions and side-effect orchestration, transforming external stimuli or internal requirements into structured data packets or executable units.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative.

## Scope
Clarify what is in scope and out of scope for this topic.

**In scope:**
* The theoretical definition of an Action as a discrete unit of intent.
* The lifecycle of an action from dispatch to resolution.
* Structural requirements for action objects/messages.
* The relationship between actions, state, and side effects.

**Out of scope:**
* Specific syntax for frameworks (e.g., Redux, Vuex, GitHub Actions, or specific CLI implementations).
* Language-specific implementation details (e.g., TypeScript interfaces vs. Python classes).

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **Action** | A discrete, structured representation of an intended change or operation. |
| **Payload** | The supplemental data required by an action to perform its intended task. |
| **Dispatcher** | The mechanism or registry responsible for routing an action to its appropriate handler. |
| **Handler** | The logic or function that consumes an action to produce a state change or side effect. |
| **Side Effect** | Any observable change or interaction with an external system (I/O, API calls) resulting from an action. |
| **Idempotency** | The property where an action can be applied multiple times without changing the result beyond the initial application. |
| **Metadata** | Contextual information about the action (e.g., timestamp, source, correlation ID) that is not part of the primary payload. |

## Core Concepts

### 1. Intent vs. Execution
The fundamental principle of an Action is the separation of "what" from "how." An action describes a desired outcome (e.g., `UPDATE_USER_EMAIL`), while the system's underlying architecture determines how that update is persisted to a database or reflected in a UI.

### 2. Declarative Nature
Actions are ideally declarative. They should describe an event that has occurred or a command to be performed, rather than containing the imperative logic to perform it. This allows the system to log, undo, or retry actions without needing to understand their internal mechanics.

### 3. Atomicity
An action should represent the smallest logical unit of work that maintains system integrity. While an action may trigger multiple sub-tasks, the action itself is treated as a single entry point into the system's processing logic.

### 4. Traceability
Because actions are discrete objects, they provide an audit trail. By recording the sequence of actions, developers can reconstruct the state of a system at any point in time (often referred to as Event Sourcing in specific contexts).

## Standard Model

The standard model for Action processing follows a unidirectional flow:

1.  **Trigger:** An internal or external event (user input, timer, webhook) initiates the process.
2.  **Creation:** An Action object is constructed, containing a unique identifier (Type/Name) and an optional Payload.
3.  **Dispatch:** The Action is sent to a Dispatcher or Bus.
4.  **Middleware/Interception:** (Optional) The Action is inspected, logged, or transformed before reaching the handler.
5.  **Handling:** The Handler receives the Action, performs logic, and either updates the state or triggers side effects.
6.  **Resolution:** The system confirms the action is complete, potentially returning a result or updating a status log.

## Common Patterns

### The Command Pattern
Actions are treated as "Commands" that encapsulate all information needed to perform an action at a later time, allowing for features like undo/redo and queuing.

### The Document Action
The action carries the entire state of the object to be modified, rather than just the delta. This is common in distributed systems to ensure eventual consistency.

### Asynchronous Orchestration
Actions that trigger long-running processes. These often involve a "Request" action, followed by "Success" or "Failure" actions dispatched by the handler upon completion.

### Optimistic Updates
The system assumes an action will succeed and updates the state immediately, providing a responsive experience, while maintaining the ability to roll back if the actual execution fails.

## Anti-Patterns

*   **Fat Actions:** Including complex business logic or UI-specific code inside the action object itself. Actions should remain data-centric.
*   **Ambiguous Naming:** Using generic names like `DATA_CHANGE` instead of specific intents like `RENAME_PROJECT`.
*   **Action Chaining:** Having one action handler directly dispatch another action as its primary function. This creates "spaghetti logic" that is difficult to debug. Logic should be handled by an orchestrator or middleware.
*   **Payload Overload:** Including unnecessary or redundant data in the payload that the handler can retrieve from the current state.

## Edge Cases

*   **Race Conditions:** When two actions are dispatched simultaneously and their handlers attempt to modify the same resource. Systems must implement locking or reconciliation strategies.
*   **Circular Dependencies:** Action A triggers Action B, which in turn triggers Action A. Without guardrails, this leads to stack overflows or infinite loops.
*   **Partial Failures:** In multi-step actions, if the third step fails but the first two succeeded, the system must define whether to roll back (atomicity) or flag the state as "Incomplete."
*   **Stale Data:** An action dispatched based on an old version of the system state. Handlers must validate that the action is still relevant upon execution.

## Related Topics
*   **State Management:** How the results of actions are persisted.
*   **Event-Driven Architecture:** Systems where actions are the primary drivers of communication.
*   **Asynchronous Programming:** Patterns for handling actions that do not resolve immediately.
*   **Observability and Logging:** Techniques for monitoring action flow.

## Change Log

| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-16 | Initial AI-generated canonical documentation |