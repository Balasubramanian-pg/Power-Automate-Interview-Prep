# 60. Common Action Patterns

Canonical documentation for 60. Common Action Patterns. This document defines concepts, terminology, and standard usage.

## Purpose
Common Action Patterns provide a standardized framework for defining how systems and users initiate, process, and finalize state changes. In complex software environments, actions are the primary mechanism for interaction. Without standardized patterns, systems become unpredictable, difficult to audit, and prone to race conditions or data inconsistency. This topic addresses the structural organization of these interactions to ensure reliability, scalability, and a consistent user experience.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative.

## Scope
Clarify what is in scope and out of scope for this topic.

**In scope:**
*   The lifecycle of an action from intent to completion.
*   Structural patterns for handling synchronous and asynchronous operations.
*   Strategies for maintaining data integrity during state transitions.
*   Abstract interaction models between actors (users/systems) and processors.

**Out of scope:**
*   Specific programming language syntax or library-specific implementations (e.g., Redux, Vuex, or specific SDKs).
*   UI/UX design aesthetics (colors, button placement).
*   Hardware-level interrupt handling.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **Action** | A discrete unit of intent that describes a desired change or operation within a system. |
| **Payload** | The data associated with an action required to execute the requested operation. |
| **Idempotency** | The property of an action where multiple identical requests have the same effect as a single request. |
| **Side Effect** | Any change to the state of the system or an external system that occurs as a result of an action. |
| **Optimistic Update** | A pattern where the system predicts the success of an action and updates the state before confirmation is received. |
| **Atomicity** | The guarantee that an action is treated as a single unit, which either succeeds completely or fails completely. |
| **Reconciliation** | The process of synchronizing the local state with the authoritative state after an action is processed. |

## Core Concepts
The fundamental ideas behind action patterns revolve around the separation of **Intent** from **Execution**.

1.  **Intent-Based Modeling:** Actions should describe *what* should happen (e.g., `UpdateUserEmail`) rather than *how* the state should be modified (e.g., `SetField("email", "val")`).
2.  **State Transition:** Every action represents a transition from State A to State B. Patterns define how this transition is managed, especially in distributed systems.
3.  **Predictability:** Given a specific initial state and a specific action, the resulting state should be deterministic, barring external environmental failures.
4.  **Observability:** Actions should be traceable, providing a clear audit trail of who initiated the change, when it occurred, and what the outcome was.

## Standard Model
The standard model for an action follows a linear lifecycle:

1.  **Dispatch:** The actor triggers the action with a payload.
2.  **Validation:** The system checks the action for authorization, schema correctness, and business logic viability.
3.  **Processing:** The system executes the logic associated with the action.
4.  **Persistence:** Changes are committed to the authoritative data store.
5.  **Notification:** The system informs the actor (and other interested parties) of the result (Success/Failure).

## Common Patterns

### 1. Synchronous Request-Response
The simplest pattern where the actor waits for the action to complete before proceeding. This is ideal for low-latency operations where immediate feedback is critical.

### 2. Asynchronous Task (Fire and Forget / Polling)
Used for long-running operations. The system acknowledges receipt of the action immediately, providing a "Task ID." The actor later checks the status (Polling) or is notified via a callback (Webhook) when the action is complete.

### 3. Optimistic UI Pattern
To improve perceived performance, the system updates the local state immediately upon dispatch. If the server-side execution fails, the system performs a **Rollback** to the previous known good state.

### 4. The Command Pattern (Undo/Redo)
Actions are encapsulated as objects containing both the logic to execute the change and the logic to reverse it. This allows for a history of actions that can be traversed forward or backward.

### 5. Batching and Bulk Actions
Grouping multiple actions into a single request to reduce network overhead and ensure that a set of operations are processed in a specific sequence or within a single transaction.

### 6. Compensating Transaction Pattern
In distributed systems where traditional ACID transactions are impossible, this pattern uses a series of actions. If one action in the sequence fails, "compensating" actions are triggered to undo the effects of the previous successful actions.

## Anti-Patterns

*   **The "God" Action:** Creating a single action type that handles too many disparate responsibilities, leading to fragile validation logic.
*   **Silent Failures:** Swallowing errors during action processing without notifying the actor or logging the failure, leading to "Zombie States."
*   **Non-Idempotent Retries:** Automatically retrying an action (like a financial transfer) that does not have a unique idempotency key, resulting in duplicate side effects.
*   **State Leakage:** Allowing the internal implementation details of the data store to dictate the structure of the action payload.

## Edge Cases

*   **Race Conditions:** When two actions targeting the same state are dispatched simultaneously. This is typically handled via optimistic locking (versioning) or pessimistic locking (mutexes).
*   **Partial Success in Batches:** When a batch of 10 actions is sent, and 7 succeed while 3 fail. Systems must define whether the entire batch rolls back or if partial success is acceptable.
*   **Network Partitioning:** When an action is successfully processed by the server, but the "Success" notification never reaches the actor due to a network drop. This requires idempotency to safely retry.
*   **Stale Data Overwrites:** When an actor performs an action based on an outdated view of the state.

## Related Topics
*   **Event Sourcing:** A pattern where state is derived by replaying a sequence of actions (events).
*   **CQRS (Command Query Responsibility Segregation):** Separating the models for reading data from the models for updating data (actions).
*   **Distributed Transactions:** Managing actions across multiple independent databases or services.

## Change Log

| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-16 | Initial AI-generated canonical documentation |