# 87. Legacy System Automation

Canonical documentation for 87. Legacy System Automation. This document defines concepts, terminology, and standard usage.

## Purpose
Legacy System Automation addresses the technical debt and operational friction inherent in maintaining business processes that rely on aging, monolithic, or "closed" software architectures. These systems—often characterized by a lack of modern Application Programming Interfaces (APIs), proprietary data formats, and terminal-based interfaces—frequently serve as the "System of Record" for critical enterprise data.

The primary objective of Legacy System Automation is to bridge the gap between modern, agile digital workflows and stable but rigid legacy environments. By programmatically interacting with these systems, organizations can achieve operational efficiency, reduce human error, and extend the lifecycle of high-value assets without the immediate risk and cost of a full system replacement.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative.

## Scope
Clarify what is in scope and out of scope for this topic.

**In scope:**
* **Non-Invasive Integration:** Methods for interacting with systems via existing User Interfaces (UI) or terminal emulators.
* **Data Extraction and Injection:** Techniques for reading from and writing to legacy data stores (e.g., flat files, legacy databases).
* **State Management:** Maintaining session integrity across asynchronous or high-latency legacy environments.
* **Abstraction Layers:** Creating modern interfaces (API-fication) on top of legacy logic.

**Out of scope:**
* **Specific Vendor Implementations:** Detailed guides for specific RPA (Robotic Process Automation) software or proprietary integration platforms.
* **Hardware Maintenance:** Physical upkeep of legacy mainframe or server hardware.
* **System Migration:** The process of decommissioning legacy systems in favor of modern SaaS or cloud-native replacements (though automation may assist in the transition).

## Definitions
| Term | Definition |
|------|------------|
| **Legacy System** | An information system that remains in use despite being based on outdated technology, often lacking standard modern interfaces (REST/GraphQL). |
| **Surface Automation** | A technique that interacts with the visual elements of a user interface (pixels, images, or UI trees) rather than the underlying code or data layer. |
| **Terminal Emulation** | Software that mimics the functionality of a "dumb terminal" to communicate with a mainframe or minicomputer (e.g., TN3270, VT100). |
| **Screen Scraping** | The process of programmatically capturing and parsing data displayed on a visual interface for use by another application. |
| **Non-Invasive Automation** | Automation that interacts with a system through its existing interfaces without requiring changes to the legacy system's source code. |
| **API-fication** | The process of wrapping legacy functionality in a modern API (Application Programming Interface) layer to make it accessible to modern services. |

## Core Concepts

### 1. The Integration Gap
Legacy systems often exist as "islands of data." The gap between these systems and modern cloud environments is characterized by incompatible protocols (e.g., COBOL-based logic vs. JSON/REST). Automation serves as the translation layer across this gap.

### 2. Non-Invasive vs. Invasive Interaction
*   **Non-Invasive:** Interacting with the system exactly as a human would (UI/Terminal). This minimizes risk to the legacy system's stability but increases sensitivity to UI changes.
*   **Invasive:** Modifying the legacy system (e.g., adding database triggers or custom code hooks) to facilitate automation. This is more robust but carries higher risk of system failure.

### 3. Determinism and Latency
Legacy systems often operate with unpredictable response times or asynchronous processing. Automation logic must account for "state-readiness"—ensuring the system has finished a task before the automation attempts the next step.

### 4. Semantic Mapping
Because legacy systems often use cryptic codes or abbreviated field names (e.g., `FLD_001` instead of `CustomerName`), automation requires a semantic mapping layer to translate legacy data into meaningful business objects.

## Standard Model

The standard model for Legacy System Automation follows a **Layered Abstraction Architecture**:

1.  **Presentation/Interface Layer:** The legacy UI or Terminal.
2.  **Automation Driver:** The component that performs the interaction (e.g., a virtual keyboard/mouse driver or a terminal connector).
3.  **Abstraction/Wrapper Layer:** Converts the raw interactions into structured data or service calls. This layer handles error logic and retries.
4.  **Consumption Layer:** The modern application or workflow engine that utilizes the legacy data/functionality.

In this model, the **Abstraction Layer** is the most critical, as it isolates the modern environment from the idiosyncrasies of the legacy system.

## Common Patterns

### 1. The "Sidecar" API
A modern microservice is deployed alongside the legacy system. It handles all "scraping" or terminal logic and exposes a clean REST API to the rest of the enterprise.

### 2. Batch Synchronization
Instead of real-time interaction, automation extracts data in bulk (e.g., via flat-file exports) during off-peak hours, processes it, and pushes updates back to the legacy system in a controlled batch.

### 3. UI-to-Data Bridge
An automation bot monitors a specific folder or queue. When a modern system drops a request, the bot logs into the legacy UI, performs the data entry, and returns a confirmation.

## Anti-Patterns

*   **Hard-coded Coordinates:** Relying on fixed X/Y pixel coordinates for UI interaction. This fails if screen resolution, font scaling, or UI elements shift.
*   **Ignoring Error States:** Failing to account for legacy-specific error pop-ups or system "hangs." This can lead to "zombie" processes that continue to input data into a crashed system.
*   **Over-Automation:** Attempting to automate highly complex, exception-heavy legacy processes that are better suited for human intervention or full system replacement.
*   **Bypassing Business Logic:** Interacting directly with a legacy database in a way that bypasses the system's built-in validation rules, leading to data corruption.

## Edge Cases

*   **Hidden Modality:** A legacy system may enter a "modal" state (a pop-up or blocking alert) that is not visible to the automation driver but prevents all input.
*   **Character Encoding Mismatches:** Legacy systems using EBCDIC or other non-UTF-8 encodings can cause data corruption during extraction if not properly translated.
*   **Session Hijacking/Timeout:** If a human user logs into the legacy system using the same credentials as the automation, the automation session may be terminated abruptly.
*   **Mainframe "X Clock" States:** In terminal emulation, the system may enter a "busy" state where the keyboard is locked. Automation must detect this state to avoid "buffer overrun" errors.

## Related Topics
*   **8. Robotic Process Automation (RPA):** The primary tooling category used for legacy UI automation.
*   **24. Data Transformation and ETL:** Techniques for moving and reformatting legacy data.
*   **52. API Management:** Governing the modern interfaces created to wrap legacy systems.
*   **91. Technical Debt Management:** The broader strategic context for why legacy systems persist.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-16 | Initial AI-generated canonical documentation |