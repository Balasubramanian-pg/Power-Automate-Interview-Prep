# 18. One Trigger Per Flow Rule

Canonical documentation for 18. One Trigger Per Flow Rule. This document defines concepts, terminology, and standard usage.

## Purpose
The "One Trigger Per Flow" rule is an architectural principle designed to ensure determinism, maintainability, and resource efficiency within automated workflow systems. It addresses the problem of "execution chaos" that occurs when multiple independent automated processes are initiated by the same event on the same object or entity. 

By consolidating logic into a single entry point, organizations can precisely control the order of operations, prevent race conditions, and simplify the debugging process. This rule serves as a governance framework for managing complex business logic in event-driven environments.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative.

## Scope
Clarify what is in scope and out of scope for this topic.

**In scope:**
* Architectural strategies for consolidating event-driven logic.
* Management of execution order and predictability.
* Theoretical frameworks for "Dispatcher" or "Master" flow patterns.
* Impact on system performance and governor limits.

**Out of scope:**
* Specific vendor implementations (e.g., Salesforce Flow, Power Automate, Zapier).
* Syntax-level coding instructions.
* UI/UX design of automation builders.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| Trigger | The specific event (e.g., Create, Update, Delete) that initiates an automated process. |
| Flow | A sequence of automated steps or logic executed in response to a trigger. |
| Determinism | The property where a specific set of inputs and events always produces the same, predictable output and execution order. |
| Race Condition | A situation where the outcome depends on the uncontrollable timing or sequence of multiple independent processes. |
| Dispatcher Pattern | A design pattern where a single primary flow receives a trigger and delegates tasks to secondary sub-processes. |
| Execution Order | The sequential priority in which logic blocks are processed by the system engine. |

## Core Concepts

### 1. Deterministic Execution
In systems where multiple flows exist for a single trigger, the engine may not guarantee which flow runs first. The One Trigger Per Flow rule eliminates this ambiguity by forcing all logic into a single, linear, or branched path where the sequence is explicitly defined by the architect.

### 2. Centralized Governance
Consolidating logic into one flow provides a "Single Source of Truth" for what happens when an event occurs. This reduces the cognitive load on developers and administrators, as they only need to inspect one location to understand the full lifecycle of an event.

### 3. Resource Optimization
Every triggered process incurs a system overhead (initialization, metadata lookups, etc.). By using a single trigger, the system minimizes the "startup cost" of automation, leading to better performance and fewer hits against platform-specific governor limits or API quotas.

## Standard Model
The standard model for this rule is the **Dispatcher-Handler Model**.

1.  **The Dispatcher (The "One" Flow):** This is the only flow configured to listen to the specific event (e.g., "On Update of Record X"). Its primary responsibility is to evaluate entry criteria and route the execution.
2.  **Decision Logic:** Within the Dispatcher, decision elements determine which business requirements apply based on the data state.
3.  **The Handlers (Sub-flows/Actions):** The Dispatcher calls modular sub-processes (Handlers) to perform specific tasks. These handlers are decoupled from the trigger itself, making them reusable across different contexts.

## Common Patterns

### The Sequential Branch
Logic is organized in a top-to-bottom fashion within the single flow. This is used when Step B absolutely depends on the successful completion of Step A.

### The Conditional Orchestrator
The flow uses complex branching logic (If/Else or Switch statements) to ensure that only the relevant segments of logic execute for a specific transaction, preventing unnecessary processing.

### The "Before" and "After" Split
In many systems, the rule is refined to "One Trigger Per Event Phase." For example, one flow for logic that must happen *before* data is saved (validation/assignment) and one flow for logic that happens *after* data is saved (notifications/external integrations).

## Anti-Patterns

### The "Siloed" Automation
Creating a new, independent flow for every new business requirement. This leads to "spaghetti automation" where multiple flows compete for resources and the final state of the data becomes unpredictable.

### Over-Complexification (The "God" Flow)
While the rule advocates for one trigger, an anti-pattern emerges when the resulting flow becomes so large and complex that it is unreadable. This is mitigated by using sub-flows or modularized logic rather than putting every single step inside the main trigger body.

### Hidden Dependencies
Relying on the alphabetical naming of flows or internal IDs to "force" an execution order in systems that allow multiple triggers. This is fragile and often breaks during system updates or deployments.

## Edge Cases

### Recursive Triggers
If the "One Flow" updates the same record that triggered it, it may re-trigger itself. The One Trigger Per Flow rule requires robust recursion handling (e.g., static variables or "already processed" flags) to prevent infinite loops.

### Cross-Object Side Effects
A flow on Object A might update Object B, which has its own "One Flow." This can create a chain reaction. Architects must map these dependencies to ensure that the "One Flow" rule on Object B can handle inputs originating from Object A.

### High-Volume Transactions
In scenarios involving bulk data imports, a single complex flow might hit execution time limits. In these rare cases, the rule may be bent to allow for "Asynchronous" or "Batch" processing paths to offload heavy logic from the immediate trigger.

## Related Topics
* **Idempotency in Automation:** Ensuring that running the same flow multiple times does not result in unintended side effects.
* **Separation of Concerns:** The principle of dividing a computer program into distinct sections such that each section addresses a separate concern.
* **Error Handling Frameworks:** Standardized methods for catching and logging failures within a centralized flow.

## Change Log

| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-16 | Initial AI-generated canonical documentation |