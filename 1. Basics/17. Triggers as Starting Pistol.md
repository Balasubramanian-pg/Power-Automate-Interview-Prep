# 17. Triggers as Starting Pistol

Canonical documentation for 17. Triggers as Starting Pistol. This document defines concepts, terminology, and standard usage.

## Purpose
The "Triggers as Starting Pistol" pattern addresses the architectural challenge of managing side effects and complex workflows initiated by state changes. In many systems, a trigger (database, file system, or application event) is often misused as a container for heavy business logic. This leads to increased latency, resource contention, and brittle failure modes.

The purpose of this topic is to define the standard for using triggers exclusively as **signaling mechanisms**. By treating a trigger as a "starting pistol," the system ensures that the initiation of a process is decoupled from the execution of the process itself, promoting scalability, reliability, and observability.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative.

## Scope
Clarify what is in scope and out of scope for this topic.

**In scope:**
* The architectural transition from synchronous execution to asynchronous signaling.
* The hand-off boundary between the triggering event and the downstream consumer.
* Design principles for payload minimization and reliability.
* Theoretical foundations of event-driven decoupling.

**Out of scope:**
* Specific syntax for SQL triggers (e.g., PL/SQL, T-SQL).
* Configuration of specific cloud-native event buses (e.g., AWS EventBridge, Azure Event Grid).
* Implementation details of specific programming languages.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **Trigger** | A functional component that automatically executes in response to a specific event or state change. |
| **Starting Pistol** | A design metaphor where the trigger's only responsibility is to signal that a process should begin, without participating in the process itself. |
| **Downstream Consumer** | The service, worker, or process that receives the signal and performs the actual business logic. |
| **Hand-off** | The moment the trigger successfully passes the signal to a transport layer (e.g., a queue or bus). |
| **Payload** | The data packet emitted by the trigger containing information about the event. |
| **Side Effect** | Any state change or external interaction that occurs as a result of the primary event. |

## Core Concepts

### The Principle of Minimal Latency
A trigger should occupy the shortest possible duration within the execution thread of the primary transaction. By acting as a starting pistol, the trigger minimizes the "hold time" on resources (such as database locks or HTTP connections), allowing the primary operation to commit or complete immediately.

### Decoupling of Concerns
The "Starting Pistol" pattern enforces a strict boundary between *what happened* (the event) and *what should happen next* (the reaction). The trigger does not need to know the complexity of the downstream logic, only where to send the signal.

### Asynchronous Execution
Once the starting pistol is fired, the resulting workflow occurs in a separate execution context. This allows the downstream process to scale independently and fail without impacting the integrity of the initial event.

## Standard Model

The standard model for "Triggers as Starting Pistol" follows a four-stage pipeline:

1.  **The Event:** A state change occurs (e.g., a row is inserted, a file is uploaded).
2.  **The Trigger (Starting Pistol):** The system detects the change. It performs the absolute minimum work required to capture the event context.
3.  **The Transport:** The trigger places a message into a persistent medium (e.g., a message queue, event bus, or outbox table).
4.  **The Worker:** An independent process picks up the message and executes the heavy business logic.

In this model, the trigger is considered successful the moment the message is durably stored in the Transport layer.

## Common Patterns

### Transactional Outbox
To ensure the "starting pistol" always fires when a database change occurs, the trigger writes the event to a dedicated "Outbox" table within the same transaction. A separate relay service then reads from this table to signal downstream systems.

### Fire-and-Forget
The trigger sends a signal to an asynchronous endpoint or message broker and immediately returns control to the main process, regardless of when the downstream task completes.

### Event Augmentation
The trigger provides a minimal identifier (e.g., `order_id`) in its payload. The downstream consumer is responsible for "augmenting" this data by querying the necessary state, rather than the trigger passing a massive, point-in-time data snapshot.

## Anti-Patterns

### The "Heavy Lifter"
The most common anti-pattern where the trigger contains complex logic, such as calling external APIs, performing heavy calculations, or updating multiple unrelated tables. This leads to long-running transactions and potential system deadlocks.

### The "Chain Reaction"
A scenario where a trigger initiates a change that fires another trigger, which fires another. This creates a "hidden" execution path that is difficult to debug and can lead to infinite loops.

### Synchronous Coupling
Designing the trigger to wait for a response from the downstream consumer. This negates the benefits of the starting pistol pattern by forcing the primary transaction to wait for the side effect to complete.

## Edge Cases

### Signal Failure (Misfire)
If the transport layer is unavailable, the "starting pistol" may fail to fire. Systems must decide if the primary transaction should fail (Atomic) or if the signal should be retried later (Eventual Consistency).

### Duplicate Signals
In distributed systems, a trigger might fire more than once for the same event (at-least-once delivery). Downstream consumers must be **idempotent**, meaning they can process the same signal multiple times without unintended side effects.

### Race Conditions
The downstream worker may start processing the signal before the primary transaction that fired the trigger has fully committed. The worker must be designed to handle cases where the data it expects to find is not yet visible.

## Related Topics
* **Event-Driven Architecture (EDA):** The broader architectural style that utilizes triggers and signals.
* **Idempotency:** The property of certain operations that can be applied multiple times without changing the result beyond the initial application.
* **Message Queuing:** The primary technology used for the Transport layer in the standard model.
* **Observability and Distributed Tracing:** Necessary for tracking a process from the "starting pistol" through to completion.

## Change Log

| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-16 | Initial AI-generated canonical documentation |