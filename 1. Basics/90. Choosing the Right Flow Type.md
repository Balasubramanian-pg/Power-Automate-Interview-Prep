# 90. Choosing the Right Flow Type

Canonical documentation for 90. Choosing the Right Flow Type. This document defines concepts, terminology, and standard usage.

## Purpose
The selection of a flow type is a foundational architectural decision that determines how logic is executed, how data is persisted, and how the system interacts with users or external services. This topic addresses the problem of mapping business requirements—such as latency sensitivity, process duration, and transactional integrity—to the appropriate technical execution model. Choosing the incorrect flow type often results in system bottlenecks, poor user experience, or data inconsistency.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative.

## Scope
Clarify what is in scope and out of scope for this topic.

**In scope:**
* Classification of flow execution models (Synchronous vs. Asynchronous).
* State management strategies (Stateful vs. Stateless).
* Structural logic patterns (Sequential, Parallel, Iterative).
* Decision criteria for selecting flow types based on business constraints.

**Out of scope:**
* Specific vendor implementations (e.g., Salesforce Flows, AWS Step Functions, Azure Logic Apps).
* Programming language-specific syntax.
* UI/UX design for flow visualization.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **Flow** | A structured sequence of operations or tasks designed to achieve a specific outcome. |
| **Synchronous** | An execution model where the requester waits for the process to complete before continuing. |
| **Asynchronous** | An execution model where the process runs independently of the requester, often returning an immediate acknowledgment rather than a final result. |
| **Stateful** | A flow that maintains and persists its context and data across multiple sessions or time intervals. |
| **Stateless** | A flow where each execution or step is independent and does not rely on data from a previous session unless explicitly passed. |
| **Deterministic** | A flow that, given the same initial state and input, will always produce the same output and follow the same path. |
| **Orchestration** | A centralized approach to flow management where a single controller directs the order of operations. |
| **Choreography** | A decentralized approach where individual components react to events to determine the next step in a flow. |

## Core Concepts
The selection of a flow type is governed by four primary dimensions:

1.  **Temporal Coupling:** How closely the start and end of a flow are tied to the trigger. High coupling (Synchronous) requires immediate availability; low coupling (Asynchronous) allows for queuing and delayed processing.
2.  **Longevity:** The duration of the flow. Short-lived flows typically execute in milliseconds or seconds, while long-running flows may span days, weeks, or months, requiring persistence.
3.  **Resilience Requirements:** The necessity for the flow to survive system restarts, network partitions, or transient failures.
4.  **Interaction Model:** Whether the flow is fully automated (system-to-system) or requires human intervention (user-interactive).

## Standard Model
The standard model for choosing a flow type follows a hierarchical decision matrix based on the nature of the task:

### 1. Real-Time Interactive Flows
Used when a user or calling system requires an immediate result to proceed.
*   **Type:** Synchronous, Stateless.
*   **Constraint:** Must complete within the request-timeout window of the calling system.

### 2. Background Processing Flows
Used for high-volume data operations or tasks that do not require immediate feedback.
*   **Type:** Asynchronous, Stateless/Stateful.
*   **Constraint:** Requires a mechanism to notify the requester of completion (e.g., webhooks, polling).

### 3. Long-Running Business Processes
Used for workflows involving human approvals, external wait states, or multi-stage processing.
*   **Type:** Asynchronous, Stateful.
*   **Constraint:** Must persist state to a durable store to survive interruptions.

### 4. Event-Driven Reactive Flows
Used for decoupled architectures where a change in one system triggers logic in another.
*   **Type:** Asynchronous, Choreographed.
*   **Constraint:** Relies on a robust event bus or message queue.

## Common Patterns
*   **Request-Response:** The simplest flow where an input yields an immediate output.
*   **Fire-and-Forget:** The flow is triggered, and the calling system moves on without waiting for a result.
*   **Saga Pattern:** A sequence of local transactions where each step updates a database and publishes an event to trigger the next step, used for maintaining consistency in distributed systems.
*   **Wait-State Pattern:** A flow that pauses execution until an external signal (e.g., an API callback or human approval) is received.

## Anti-Patterns
*   **The Synchronous Chain:** Linking multiple synchronous flows together, where the failure of the last link causes the entire chain to fail and hold resources open.
*   **Over-Orchestration:** Using a complex stateful flow for a simple transformation that could be handled by a stateless function.
*   **State in the Middle:** Storing intermediate flow state in volatile memory (like a web session) for a process that takes longer than the session timeout.
*   **The "God" Flow:** Creating a single, massive flow that attempts to handle every possible business logic branch, making it unmaintainable and prone to regression.

## Edge Cases
*   **Idempotency Requirements:** In asynchronous flows, a message might be delivered twice. The flow must be designed to handle re-execution without side effects.
*   **Race Conditions:** When two parallel branches of a flow attempt to update the same record simultaneously.
*   **Zombie Flows:** Stateful flows that reach a state where they can neither progress nor terminate (e.g., waiting for an event that will never fire).
*   **Backpressure:** When a flow is triggered faster than the underlying system can process it, requiring a strategy for shedding load or queuing.

## Related Topics
*   **Error Handling and Retry Policies:** Strategies for managing flow failures.
*   **Event-Driven Architecture (EDA):** The broader architectural context for asynchronous flows.
*   **Distributed Transactions:** Managing data integrity across multiple flow steps.
*   **Observability and Tracing:** Monitoring the path of a flow across distributed components.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-16 | Initial AI-generated canonical documentation |