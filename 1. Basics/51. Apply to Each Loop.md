# 51. Apply to Each Loop

Canonical documentation for 51. Apply to Each Loop. This document defines concepts, terminology, and standard usage.

## Purpose
The **Apply to Each Loop** is a control flow construct designed to automate the repetitive execution of a defined set of actions across every individual member of a data collection. It addresses the problem of processing variable-length datasets where the number of iterations is determined dynamically by the input size rather than a fixed constant.

By abstracting the mechanics of pointer incrementation and bounds checking, the Apply to Each Loop allows architects to focus on the logic applied to a single "current" item, ensuring consistency across the entire set.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative.

## Scope
Clarify what is in scope and out of scope for this topic.

**In scope:**
* Logic of collection traversal and element isolation.
* Execution modes (sequential vs. concurrent).
* Scope and context management within iterations.
* Input requirements and output expectations.

**Out of scope:**
* Specific syntax for programming languages (e.g., Python `for`, JavaScript `forEach`).
* Vendor-specific UI implementations (e.g., Power Automate, Logic Apps).
* Low-level memory management of iterators.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **Collection** | An ordered or unordered set of data elements (array, list, or object set) serving as the input for the loop. |
| **Iteration** | A single execution cycle of the loop's internal logic for one element of the collection. |
| **Current Item** | The specific element from the collection currently being processed in the active iteration. |
| **Concurrency** | The ability to execute multiple iterations of the loop simultaneously rather than one after another. |
| **Sequential Execution** | A processing mode where each iteration must complete before the next begins, preserving order. |
| **Iterator** | The underlying mechanism that tracks the progress through the collection. |

## Core Concepts

### 1. Collection Dependency
An Apply to Each loop cannot exist in a vacuum; it requires a valid collection as an input. If the input is not a collection (e.g., a single string or an integer), the loop structure is logically invalid.

### 2. Contextual Reference
Within the boundaries of the loop, the system provides a reference to the "Current Item." This reference is dynamic, updating with each iteration to point to the next element in the collection.

### 3. Scope Isolation
Actions defined inside an Apply to Each loop are scoped to that loop. While they can typically access variables from the parent scope, variables defined *within* the loop are often reset or re-evaluated for each iteration, depending on the implementation's state management.

## Standard Model

The standard model for an Apply to Each loop follows a three-phase lifecycle:

1.  **Initialization:** The loop receives a collection. The iterator is set to the first element.
2.  **Execution Cycle:**
    *   The "Current Item" is isolated.
    *   The defined internal actions are executed using the Current Item's data.
    *   The system checks for a "Next" element.
3.  **Termination:** Once the final element is processed, the loop exits, and the workflow proceeds to the next action outside the loop scope.

## Common Patterns

### Transformation (Map)
Taking a collection of raw data and applying logic to each item to produce a new, modified collection.

### Filtering (Select)
Evaluating each item against a condition; only items meeting the criteria trigger subsequent actions within the loop.

### Accumulation (Reduce)
Iterating through a collection to update a single value (e.g., summing prices in an array of invoices).

### Side-Effect Execution
Performing an external action for every item, such as sending an individual email for every record in a list.

## Anti-Patterns

*   **Modifying the Source Collection:** Attempting to add or remove items from the collection while the loop is currently iterating over it. This leads to unpredictable behavior or "index out of bounds" errors.
*   **Deep Nesting:** Placing multiple Apply to Each loops inside one another (O(n^x) complexity). This significantly degrades performance and increases maintenance difficulty.
*   **Ignoring Concurrency Limits:** Enabling high concurrency on loops that interact with rate-limited APIs or shared resources, leading to race conditions or service throttling.
*   **Variable Shadowing:** Using the same variable name inside the loop as one defined in the global scope, causing logic errors in state tracking.

## Edge Cases

*   **Empty Collections:** If the input collection contains zero items, the loop should terminate immediately without executing any internal actions. This is a "success" state, not a failure.
*   **Null Inputs:** If the input is `null` rather than an empty collection, the loop may trigger an exception depending on the strictness of the implementation.
*   **Single-Item Collections:** The loop should behave identically to a multi-item collection, executing exactly once.
*   **Large Datasets:** When collections exceed memory or timeout thresholds, the loop may require "chunking" or pagination strategies to complete.
*   **Data Type Mismatch:** When the collection contains heterogeneous data (e.g., a list containing both strings and integers) and the internal logic expects a specific type.

## Related Topics
*   **Conditionals (If/Else):** Often used inside loops to branch logic.
*   **Variables and State Management:** Essential for tracking data across iterations.
*   **Error Handling (Try/Catch):** Defining what happens if a single iteration fails while others succeed.
*   **Parallelism:** The theoretical framework for concurrent execution.

## Change Log

| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-16 | Initial AI-generated canonical documentation |