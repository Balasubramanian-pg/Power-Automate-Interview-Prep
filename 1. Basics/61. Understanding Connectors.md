# 61. Understanding Connectors

Canonical documentation for 61. Understanding Connectors. This document defines concepts, terminology, and standard usage.

## Purpose
The primary purpose of a connector is to facilitate interoperability between disparate systems by abstracting the complexities of communication protocols, data formats, and authentication mechanisms. In modern architecture, connectors solve the "N x M" integration problem—where connecting $N$ systems to $M$ targets would otherwise require $N \times M$ custom integrations. By providing a standardized interface, connectors allow systems to interact without requiring deep internal knowledge of the peer system’s implementation details.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative. It focuses on the architectural role of connectors rather than specific software vendor plugins.

## Scope
Clarify what is in scope and out of scope for this topic.

**In scope:**
* **Abstraction Layers:** The theoretical framework for decoupling systems.
* **Interface Standardization:** How connectors normalize data and commands.
* **Lifecycle Management:** The stages of a connector's operation (Initialization, Execution, Termination).
* **Security Delegation:** The role of connectors in handling identity and access.

**Out of scope:**
* **Specific Vendor Implementations:** (e.g., specific Salesforce, AWS, or SAP connector configurations).
* **Physical Hardware Connectors:** (e.g., USB, HDMI, or fiber optic specifications).
* **Programming Language Syntax:** Specific code snippets for SDKs.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **Connector** | A software component that acts as an intermediary, translating requests and data between a host system and an external resource. |
| **Endpoint** | The specific destination or entry point (URL, IP, or Socket) with which a connector communicates. |
| **Protocol** | The set of rules (e.g., HTTP, MQTT, gRPC) that the connector uses to transmit data. |
| **Schema Mapping** | The process of aligning the data structure of the source system with the data structure of the target system. |
| **Authentication Provider** | The mechanism within a connector that manages credentials (e.g., OAuth2, API Keys, Mutual TLS). |
| **Backpressure** | A signal sent by a connector to a source system to slow down data transmission when the target system is overwhelmed. |

## Core Concepts

### 1. Abstraction of Complexity
Connectors serve as a "black box" for the consuming application. The application interacts with a simplified API or interface, while the connector handles the nuances of the target system’s API versions, rate limits, and error codes.

### 2. Protocol Translation
A connector often bridges different communication styles. For example, a connector might accept a RESTful JSON request from a modern web application and translate it into a SOAP/XML message for a legacy mainframe system.

### 3. Data Normalization
Connectors ensure that data entering or leaving a system adheres to a specific format. This includes type conversion (e.g., converting a string to a date object) and structural transformation (e.g., flattening a nested JSON object).

### 4. State Management
Connectors may be **stateless** (treating every request as independent) or **stateful** (maintaining a persistent connection or session context to optimize performance and track progress).

## Standard Model
The standard model for a connector follows a three-tier architecture:

1.  **The Interface Layer:** The "surface" exposed to the host system. It provides a consistent set of methods (e.g., `Read`, `Write`, `Update`, `Delete`).
2.  **The Logic/Transformation Layer:** The "engine" where data mapping, protocol translation, and business logic reside. This layer handles retries, logging, and error mapping.
3.  **The Transport Layer:** The "driver" that manages the physical or virtual connection to the external resource, including encryption and low-level handshake protocols.

## Common Patterns

### Request-Response (Synchronous)
The host system sends a request through the connector and waits for a specific response from the target. This is common for real-time data lookups.

### Pub/Sub (Asynchronous)
The connector listens to a message broker or stream. When an event occurs in the target system, the connector "pushes" the notification to the host system.

### Batch/Bulk Processing
The connector accumulates data over a period or until a threshold is met, then transmits the data in a single large transaction to optimize throughput and reduce overhead.

### Polling
The connector periodically queries the target system to check for updates or new data, simulating real-time behavior for systems that do not support webhooks or push notifications.

## Anti-Patterns

*   **Hardcoding Credentials:** Embedding API keys or passwords directly within the connector logic rather than using a secure vault or environment variables.
*   **The "God" Connector:** Creating a single connector that attempts to handle too many disparate functions or systems, leading to high complexity and fragility.
*   **Bypassing the Connector:** Allowing applications to communicate directly with the target system, which creates "shadow integrations" and breaks the abstraction layer.
*   **Ignoring Rate Limits:** Failing to implement throttling or backpressure, which can lead to the connector being blocked or banned by the target system.

## Edge Cases

*   **Schema Evolution:** When the target system updates its data structure without notice, the connector must handle the mismatch gracefully (e.g., through versioning or "permissive" parsing).
*   **Partial Failures:** In a bulk operation, some records may succeed while others fail. The connector must provide a mechanism to report specific failures without invalidating the entire transaction.
*   **Zombie Connections:** Persistent connections that remain open on the network layer but are no longer valid at the application layer, requiring robust heartbeat or timeout logic.
*   **Circular Dependencies:** A scenario where Connector A triggers an action in System B, which via Connector B triggers an action back in System A, creating an infinite loop.

## Related Topics
*   **API Gateway Management:** How connectors are governed at scale.
*   **Middleware Architecture:** The broader ecosystem where connectors reside.
*   **Identity and Access Management (IAM):** The security frameworks connectors must navigate.
*   **Data Orchestration:** The sequencing of multiple connector actions to complete a business process.

## Change Log

| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-16 | Initial AI-generated canonical documentation |