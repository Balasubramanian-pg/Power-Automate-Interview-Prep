# 74. Workflow Definition Language WDL

Canonical documentation for 74. Workflow Definition Language WDL. This document defines concepts, terminology, and standard usage.

## Purpose
Workflow Definition Language (WDL) is a domain-specific language (DSL) designed to describe complex data processing pipelines in a human-readable and writable format. Its primary purpose is to decouple the logical definition of a computational workflow from the underlying execution infrastructure. 

WDL addresses the challenges of reproducibility, scalability, and portability in scientific computing and data engineering. By providing a structured syntax for defining tasks and their dependencies, it allows researchers and engineers to define "what" needs to be computed, while leaving the "how" and "where" to specialized execution engines.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative, focusing on the language specifications rather than specific execution engines.

## Scope
**In scope:**
* **Language Syntax and Semantics:** The structural components of WDL files (Tasks, Workflows, Structs).
* **Data Flow Logic:** How data is passed between discrete units of computation.
* **Execution Requirements:** The declaration of runtime environments and resource constraints.
* **Portability Standards:** The mechanisms that allow WDL to remain functional across different computing environments.

**Out of scope:**
* **Execution Engines:** Specific software implementations that interpret WDL (e.g., Cromwell, miniWDL).
* **Infrastructure Provisioning:** The specific mechanics of how cloud or HPC resources are allocated.
* **Language Versioning Nuances:** Specific differences between WDL 1.0, 1.1, and development versions, unless necessary for conceptual clarity.

## Definitions
| Term | Definition |
|------|------------|
| **Task** | The smallest unit of execution, typically wrapping a specific command-line tool or script. |
| **Workflow** | A collection of tasks and/or sub-workflows organized into a directed graph to achieve a complex objective. |
| **Call** | An instruction within a workflow to execute a specific task or sub-workflow. |
| **Scatter** | A parallelization construct that executes a block of code multiple times over a list of inputs. |
| **Gather** | The implicit or explicit process of collecting results from a scattered execution into a single collection. |
| **Struct** | A user-defined data type used to group related variables into a single named entity. |
| **Runtime** | A block within a task that defines the environment requirements (e.g., memory, CPU, container image). |
| **Declaration** | The definition of a variable, including its type and name, and optionally its value. |

## Core Concepts

### 1. Declarative Structure
WDL is primarily declarative. While it describes a sequence of events, the execution engine determines the optimal order of operations based on the dependency graph (Directed Acyclic Graph or DAG). A task is not executed until all its required inputs are available.

### 2. Separation of Concerns
WDL enforces a strict separation between:
* **The Command:** The actual shell script or tool being run.
* **The Logic:** The flow of data and conditional execution.
* **The Environment:** The hardware and software requirements (defined in the `runtime` block).

### 3. Strong Typing
WDL utilizes a strong type system (e.g., `String`, `Int`, `File`, `Array`, `Map`, `Object`). This ensures that data passed between tasks is compatible, allowing for static validation of workflows before execution begins.

### 4. Portability via Containerization
A core tenet of WDL is the use of containers (e.g., Docker, Singularity). By specifying a container image within a task's runtime block, the workflow ensures that the software environment remains consistent regardless of the host machine.

## Standard Model

The standard model of a WDL document follows a hierarchical structure:

1.  **Imports and Structs:** Definitions of shared data structures and external WDL files.
2.  **Tasks:** Individual units of work. Each task contains:
    *   **Input:** Variables required for execution.
    *   **Command:** The literal shell command to be executed.
    *   **Output:** Files or values to be captured after execution.
    *   **Runtime:** Metadata regarding the execution environment.
3.  **Workflow:** The orchestration layer. It defines:
    *   **Workflow Inputs:** Global parameters.
    *   **Calls:** Invocations of tasks.
    *   **Data Routing:** Mapping outputs from one call to the inputs of another.
    *   **Workflow Outputs:** The final results to be persisted.

## Common Patterns

### Scatter-Gather
Used for data parallelism. A workflow "scatters" an array of inputs across multiple instances of a task, executing them in parallel. Once complete, the engine "gathers" the individual outputs back into an array for downstream processing.

### Conditional Execution
Using `if` statements to determine whether a specific task or block of code should execute based on a Boolean expression or the presence of an optional input.

### Sub-workflows
Workflows can call other workflows as if they were tasks. This promotes modularity and the reuse of complex logic across different projects.

### Optional Inputs/Outputs
Using the `?` modifier (e.g., `File?`) to handle variables that may or may not be present, allowing for flexible pipeline behavior.

## Anti-Patterns

### Hardcoding Paths
Including absolute file system paths within a task's command block. This breaks portability, as the path may not exist in a different execution environment or container.

### Monolithic Tasks
Combining multiple unrelated tools or processing steps into a single WDL task. This prevents the execution engine from effectively caching intermediate results and parallelizing the workload.

### Logic in the Command Block
Performing complex data manipulation or flow control within the `command` string using shell scripting, rather than using WDL's native expressions and declarations. This makes the workflow harder to debug and validate.

### Over-reliance on `Object`
Using the generic `Object` type instead of defined `Structs`. This bypasses the benefits of the strong type system and makes the code less readable.

## Edge Cases

### Empty Scatters
If a `scatter` is performed over an empty array, the tasks within the scatter block are skipped. Downstream tasks relying on those outputs must be able to handle empty arrays or optional types.

### Non-Zero Exit Codes
By default, any non-zero exit code from a command block signals a task failure. However, some legacy tools use specific non-zero codes to indicate success or warnings. WDL allows for overriding this via the `continueOnReturnCode` runtime attribute.

### File Localization
In distributed environments, files must be "localized" (copied or linked) to the working directory of the task. Large files or complex directory structures can lead to significant latency or disk space issues if not managed via appropriate cloud-native URI handling.

### Dangling Inputs
Inputs defined in a task but not provided by the workflow call can lead to runtime errors unless they have default values defined in the task itself.

## Related Topics
* **Containerization (Docker/Singularity):** The standard method for encapsulating software environments.
* **POSIX Shell:** The language typically used within the `command` block of a task.
* **JSON/YAML:** The standard formats for providing input values to a WDL workflow.
* **Common Workflow Language (CWL):** An alternative workflow standard focusing on YAML/JSON descriptors.
* **Nextflow:** A reactive workflow framework and DSL.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-16 | Initial AI-generated canonical documentation |