# 57. Sequential Action Execution

Canonical documentation for 57. Sequential Action Execution. This document defines concepts, terminology, and standard usage.

## Purpose
Sequential Action Execution addresses the requirement for ordered, deterministic operations within a system. It provides a framework for ensuring that a series of discrete tasks (actions) are performed in a specific, linear progression where the initiation of a subsequent action is contingent upon the completion or status of its predecessor.

The primary problem space addressed by this topic is the management of dependencies and state consistency. In complex systems, certain operations cannot occur simultaneously due to resource constraints, logical dependencies, or the necessity of state transformation provided by a prior step. Sequential execution guarantees that the system remains in a predictable state throughout the lifecycle of a multi-step process.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative.

## Scope
Clarify what is in scope and out of scope for this topic.

**In scope:**
* **Ordering Logic:** The mechanisms that govern the "next-in-line" selection.
* **State Propagation:** How data or context is passed from one action to the next.
* **Execution Flow Control:** Handling success, failure, and termination within a sequence.
* **Synchronicity:** The blocking nature of sequential steps.

**Out of scope:**
* **Parallelism/Concurrency:** Multi-threaded or simultaneous execution models (except where they intersect with sequence termination).
* **Specific Syntax:** Language-specific implementations (e.g., Promises in JavaScript, Coroutines in Go).
* **Hardware Scheduling:** Low-level CPU instruction pipelining.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **Action** | The smallest atomic unit of work within a sequence. |
| **Sequence** | An ordered collection of actions intended to be executed chronologically. |
| **Predecessor** | An action that must complete before the current action begins. |
| **Successor** | An action that begins only after the current action reaches a defined state. |
| **State Context** | The shared data or environment variables accessible to actions within a sequence. |
| **Blocking** | A state where the execution engine waits for the current action to finalize before proceeding. |
| **Exit Code** | A standardized signal returned by an action indicating its completion status (e.g., Success, Failure, Warning). |

## Core Concepts

### Determinism
Sequential execution is fundamentally deterministic. Given the same initial state and the same set of actions, the order of operations and the final state should be predictable. This eliminates race conditions inherent in concurrent systems.

### Linear Dependency
In a sequence, Action $B$ is dependent on Action $A$. This dependency may be **functional** (Action $B$ needs data from Action $A$) or **procedural** (Action $B$ should only happen if Action $A$ succeeded).

### State Continuity
As a sequence progresses, it carries a "State Context." Each action may read from this context, modify it, or augment it. The integrity of the sequence depends on the consistent hand-off of this context between predecessors and successors.

### Termination Criteria
A sequence must have defined boundaries. Execution terminates when:
1. All actions in the sequence have completed successfully.
2. An action fails, and no error-handling or "continue-on-failure" logic is defined.
3. A "Stop" or "Break" command is issued by an internal action logic.

## Standard Model

The standard model for Sequential Action Execution follows a **Pipeline Architecture**. 

1.  **Initialization:** The execution engine loads the sequence definition and initializes the State Context.
2.  **Selection:** The engine identifies the first (or next) action based on the defined order.
3.  **Validation:** Pre-execution checks ensure that the requirements for the action are met.
4.  **Execution:** The action is performed. The engine enters a "Blocking" state.
5.  **Evaluation:** The engine captures the Exit Code and updates the State Context.
6.  **Transition:** Based on the Exit Code, the engine determines whether to proceed to the Successor, trigger an error handler, or terminate.

## Common Patterns

### The Fail-Fast Pattern
The sequence terminates immediately upon the first failure of any action. This prevents "cascading failures" where subsequent actions operate on corrupted or incomplete state.

### The Relay Pattern (Data Pipe)
Each action transforms data and passes it directly to the next. The output of Action $n$ becomes the input for Action $n+1$.

### The Transactional Sequence
A pattern where the entire sequence is treated as a single logical unit. If any action fails, the system attempts to "Rollback" or revert the changes made by previous actions in the sequence to maintain atomicity.

### Conditional Branching (Linear)
While the sequence remains linear, the *choice* of the successor is determined by the output of the current action. This is still sequential, as only one path is executed at a time.

## Anti-Patterns

### Circular Dependencies
Defining a sequence where Action $A$ depends on Action $B$, which in turn depends on Action $A$. This leads to infinite loops or system deadlocks.

### The "God" Action
Creating a single action that performs too many tasks, defeating the purpose of a sequence. This reduces granularity, makes error recovery difficult, and obscures the progress of the execution.

### Hidden State Side-Effects
Actions that modify global variables or external systems without updating the State Context. This makes the sequence non-deterministic and difficult to debug.

### Ignoring Exit Codes
Proceeding to a successor regardless of the predecessor's success or failure without an explicit "Continue on Failure" policy.

## Edge Cases

### Timeouts and Stalls
An action may enter an indeterminate state where it neither fails nor succeeds (e.g., waiting for a network response). Sequential execution models must define a maximum "Time-to-Live" (TTL) for any single action to prevent the entire sequence from hanging indefinitely.

### Partial Success
An action completes its primary task but encounters a non-critical error. The system must decide if a "Warning" status constitutes a "Success" or "Failure" for the purpose of transition logic.

### External State Interference
If an external process modifies the environment that a sequence relies on while the sequence is mid-execution, the sequence may fail despite all internal logic being correct.

### Re-entrancy
The scenario where a sequence is triggered again while a previous instance of the same sequence is still executing. Without proper locking, this can lead to state corruption.

## Related Topics
* **58. Parallel Execution:** The simultaneous execution of actions.
* **12. State Machine Theory:** The mathematical model governing transitions between states.
* **84. Error Handling and Recovery:** Strategies for managing failures within automated systems.
* **22. Atomic Transactions:** Ensuring a series of actions are treated as a single unit.

## Change Log

| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-16 | Initial AI-generated canonical documentation |