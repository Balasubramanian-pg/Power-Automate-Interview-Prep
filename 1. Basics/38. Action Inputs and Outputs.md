# 38. Action Inputs and Outputs

Canonical documentation for 38. Action Inputs and Outputs. This document defines concepts, terminology, and standard usage.

## Purpose
The concept of Action Inputs and Outputs exists to facilitate the modular exchange of data between discrete units of execution (Actions) and their orchestrating environment. By defining a formal interface for data entry and exit, systems can achieve decoupling, where the internal logic of an action is isolated from the broader workflow. This structure ensures that actions are reusable, testable, and predictable, providing a standardized mechanism for state transition and information flow across complex sequences.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative.

## Scope
Clarify what is in scope and out of scope for this topic.

**In scope:**
* The definition of data contracts between actions and orchestrators.
* Mechanisms for parameterization and result capture.
* Validation, typing, and mapping of data across execution boundaries.
* The lifecycle of data as it transitions from an input state to an output state.

**Out of scope:**
* Internal execution logic or runtime environments of specific actions.
* Specific syntax for vendor-specific workflow engines (e.g., YAML schemas for specific CI/CD tools).
* Network-level protocols used for data transport.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **Action** | A discrete, atomic unit of work or logic designed to perform a specific task. |
| **Input** | A defined parameter or data point required by an action to modify its behavior or provide necessary context for execution. |
| **Output** | A data point, artifact, or status produced by an action upon completion, intended for consumption by subsequent processes. |
| **Contract** | The formal agreement defining the expected types, formats, and constraints of inputs and outputs. |
| **Mapping** | The process of connecting the output of one action to the input of another. |
| **Side Effect** | Any state change caused by an action that occurs outside of the formal output definition (e.g., modifying a global database). |
| **Schema** | The structural definition that governs the validation of input and output data. |

## Core Concepts

### 1. The Interface Contract
Every action operates behind an interface contract. This contract dictates what the action requires to start (Inputs) and what it promises to deliver upon success (Outputs). This abstraction allows the orchestrator to treat the action as a "black box," focusing on data flow rather than implementation details.

### 2. Determinism and Predictability
Ideally, an action should be deterministic: given the same set of inputs, it should produce the same outputs and side effects. Well-defined inputs and outputs are the primary mechanism for achieving this predictability in automated systems.

### 3. Data Integrity and Validation
Inputs and outputs serve as the primary checkpoints for data integrity. Validation occurs at the boundary:
* **Input Validation:** Ensures the action does not execute with malformed or dangerous data.
* **Output Validation:** Ensures the action has met its contractual obligations before the workflow continues.

### 4. Scope and Visibility
Inputs are scoped to the execution instance of the action. Outputs, once generated, enter the scope of the orchestrator, which determines their visibility to subsequent actions in the sequence.

## Standard Model

The standard model for Action Inputs and Outputs follows a **Linear Transformation Pattern**:

1.  **Initialization:** The orchestrator identifies the required inputs based on the action's schema.
2.  **Resolution:** The orchestrator resolves values for these inputs from static definitions, environment variables, or previous action outputs.
3.  **Injection:** Resolved values are injected into the action's execution environment.
4.  **Execution:** The action processes the inputs.
5.  **Extraction:** Upon completion, the orchestrator captures specific data points or files designated as outputs.
6.  **Persistence/Pass-through:** The outputs are stored in the execution context for future use.

### Input Categories
*   **Required:** Essential data without which the action cannot function.
*   **Optional:** Parameters that provide overrides or extended functionality, often carrying default values.
*   **Sensitive:** Inputs requiring specialized handling (e.g., masking in logs, encryption at rest).

### Output Categories
*   **Metadata:** Small data points (strings, integers, booleans) describing the result.
*   **Artifacts:** Files or large data objects generated during execution.
*   **Status Codes:** Standardized indicators of success, failure, or specific states.

## Common Patterns

### The Chain Pattern
The output of Action A is mapped directly to the input of Action B. This creates a functional dependency and defines a clear data pipeline.

### The Aggregator Pattern
Multiple outputs from various preceding actions are collected and mapped into a single action's inputs, allowing for complex decision-making or reporting.

### The Defaulting Pattern
Actions define sensible defaults for inputs, allowing them to be executed with minimal configuration while remaining flexible for advanced use cases.

### The Passthrough Pattern
An action accepts an input and includes it in its output unchanged, often used to maintain context or "breadcrumbs" across a long-running process.

## Anti-Patterns

*   **The "God" Input:** Passing a single, massive, unstructured object (like a raw JSON blob) as an input, which obscures dependencies and breaks validation.
*   **Hidden Inputs:** Relying on global state or environment variables that are not explicitly defined in the action's input schema.
*   **Output Overload:** Exporting excessive, unnecessary data as outputs, leading to "namespace pollution" and increased memory/storage overhead.
*   **Side-Effect Reliance:** Depending on an action's side effects (e.g., a file left on a disk) rather than formal outputs to pass data to the next step.
*   **Mutable Inputs:** Attempting to modify an input value within the action and expecting that change to reflect back to the orchestrator (Inputs should be treated as immutable).

## Edge Cases

*   **Null/Empty Values:** How the system distinguishes between a "missing" input and an "intentionally empty" input.
*   **Circular Dependencies:** Scenarios where Action A requires an output from Action B, which in turn requires an output from Action A. This must be handled at the orchestrator level.
*   **Large Payload Handling:** When an output exceeds the standard size limits for metadata (e.g., a 2GB log file). Standard practice involves exporting a reference (URI) as an output rather than the data itself.
*   **Type Mismatch in Mapping:** When Action A outputs a string that Action B expects as an integer. Robust systems require a transformation layer or strict casting rules.

## Related Topics
*   **37. Workflow Orchestration:** The broader context in which actions are executed.
*   **39. Error Handling and Retries:** How failures in producing outputs are managed.
*   **42. Secrets Management:** Specialized handling for sensitive inputs.
*   **15. Data Schemas and Serialization:** The formats used to structure inputs and outputs (JSON, YAML, Protobuf).

## Change Log

| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-16 | Initial AI-generated canonical documentation |