# 16. Understanding Triggers

Canonical documentation for 16. Understanding Triggers. This document defines concepts, terminology, and standard usage.

## Purpose
Triggers exist to provide a mechanism for automated, event-driven execution within a systemâ€”most commonly a database management system (DBMS) or an event-orchestration engine. They address the need for "active" data environments where specific state changes or system events must immediately and reliably invoke procedural logic. 

The primary purpose of a trigger is to enforce complex integrity constraints, automate secondary data maintenance (such as auditing or synchronization), and ensure that business rules are applied consistently, regardless of the application or interface interacting with the system.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative.

## Scope
Clarify what is in scope and out of scope for this topic.

**In scope:**
* **Event-Condition-Action (ECA) Framework:** The theoretical foundation of trigger logic.
* **Execution Timing and Context:** When triggers fire relative to the triggering event.
* **Granularity:** The distinction between row-level and statement-level operations.
* **Integrity and Side Effects:** The impact of triggers on transaction atomicity and system state.

**Out of scope:**
* **Specific vendor implementations:** Syntax or limitations specific to PostgreSQL, Oracle, SQL Server, or cloud-native event triggers (e.g., AWS Lambda triggers).
* **Application-level event listeners:** Logic residing entirely within the application tier (e.g., middleware hooks).

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **Triggering Event** | A specific operation (e.g., Insert, Update, Delete, or System Startup) that initiates the trigger. |
| **Trigger Action** | The procedural code or logic executed when the trigger's conditions are met. |
| **ECA Model** | Event-Condition-Action; the standard architectural pattern for reactive systems. |
| **Granularity** | The frequency of execution (e.g., once per affected record vs. once per total operation). |
| **Transition Variables** | Pseudo-records that allow access to data states before and after the triggering event (e.g., OLD/NEW or DELETED/INSERTED). |
| **Cascading** | A scenario where the action of one trigger invokes another trigger, potentially creating a chain of execution. |
| **Mutation** | The state of a data object being modified during the execution of a trigger that is also monitoring that object. |

## Core Concepts

### The ECA Framework
Triggers operate on the **Event-Condition-Action** model:
1.  **Event:** The system detects a change in state or a specific command.
2.  **Condition:** An optional boolean evaluation to determine if the action should proceed.
3.  **Action:** The execution of the defined logic.

### Execution Timing
Triggers are categorized by their temporal relationship to the event:
*   **BEFORE:** Executed before the triggering event is applied to the state. Often used for validation or data transformation.
*   **AFTER:** Executed after the event is applied. Used for logging, auditing, or updating dependent systems.
*   **INSTEAD OF:** Executed in place of the triggering event. Commonly used to make non-updatable views modifiable.

### Granularity
*   **Row-Level:** The trigger fires once for every individual record affected by the event.
*   **Statement-Level:** The trigger fires once for the entire operation, regardless of how many records are affected.

## Standard Model
The standard model for triggers emphasizes **Atomicity** and **Consistency**. In a transactional system, a trigger typically operates within the same logical unit of work (transaction) as the triggering event. If the trigger fails, the event fails, and the system rolls back to its previous state.

1.  **Detection:** The system intercepts a request (DML, DDL, or System Event).
2.  **Context Initialization:** The system populates transition variables (OLD/NEW values).
3.  **Constraint Checking:** The system evaluates if the trigger's internal logic or "WHEN" clause is satisfied.
4.  **Execution:** The procedural block runs.
5.  **Finalization:** The system proceeds to the next trigger in the sequence or completes the original request.

## Common Patterns

### 1. Automated Auditing
Capturing changes to sensitive data by writing the "OLD" and "NEW" states to a separate history table. This ensures a tamper-evident record that is independent of application logic.

### 2. Derived Data Maintenance
Automatically updating a summary table or a calculated field (e.g., `total_order_value`) whenever a line item is inserted or modified.

### 3. Complex Integrity Enforcement
Enforcing rules that span multiple tables or involve temporal logic that standard "Check Constraints" or "Foreign Keys" cannot handle.

### 4. Data Normalization/Cleaning
Standardizing input (e.g., forcing strings to uppercase or trimming whitespace) immediately before the data is committed to the system.

## Anti-Patterns

### 1. Hidden Business Logic
Placing critical business rules inside triggers where they are invisible to application developers. This leads to "magic" behavior that is difficult to debug and document.

### 2. Recursive/Circular Triggers
Defining Trigger A to update Table B, which in turn has a trigger that updates Table A. Without strict depth limits, this results in infinite loops and system exhaustion.

### 3. Heavy Processing
Performing high-latency operations (e.g., calling an external API or processing large files) within a trigger. Because triggers are usually synchronous, this blocks the main transaction and reduces throughput.

### 4. Over-reliance on Cascading
Creating long chains of triggers where one update causes a dozen others. This makes the performance impact of a single "Update" statement unpredictable.

## Edge Cases

### 1. Bulk Operations
In some systems, high-performance bulk loads may bypass triggers entirely to increase speed. This can lead to data inconsistency if the triggers were responsible for enforcing integrity.

### 2. Mutating Tables
Attempting to read or modify the same table that fired the trigger. Many systems forbid this to prevent non-deterministic results, often resulting in a "Mutating Table Error."

### 3. Transaction Rollbacks
If a trigger performs an external action (like sending an email) and the parent transaction subsequently rolls back, the external action cannot be "undone," leading to a mismatch between system state and real-world effects.

### 4. Trigger Ordering
When multiple triggers are defined for the same event on the same object, the order of execution may be non-deterministic unless the system provides a specific "precedence" or "weight" mechanism.

## Related Topics
*   **Transaction Management:** Understanding how triggers interact with COMMIT and ROLLBACK.
*   **Constraints:** The relationship between declarative (FK, Unique) and procedural (Trigger) integrity.
*   **Event-Driven Architecture:** The broader application of trigger-like patterns in distributed systems (e.g., Pub/Sub).
*   **Stored Procedures:** The reusable logic blocks often invoked by triggers.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-16 | Initial AI-generated canonical documentation |