# 34. On Demand Automation

Canonical documentation for 34. On Demand Automation. This document defines concepts, terminology, and standard usage.

## Purpose
On Demand Automation (ODA) exists to provide immediate, event-driven, or user-initiated execution of automated workflows. It addresses the limitations of scheduled (batch) processing and manual intervention by allowing systems and users to invoke complex logic at the precise moment it is required. 

The primary goal of ODA is to reduce latency in operational cycles, minimize human error in repetitive tasks, and provide a self-service interface for technical and non-technical stakeholders. It transforms automation from a background utility into a responsive service.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative.

## Scope
Clarify what is in scope and out of scope for this topic.

**In scope:**
* Mechanisms for triggering automated workflows (API, Webhooks, CLI, UI).
* The lifecycle of an on-demand request from invocation to completion.
* Security and governance models for ad-hoc execution.
* Resource management for ephemeral automation tasks.

**Out of scope:**
* Specific vendor implementations (e.g., specific CI/CD runners or RPA tools).
* Scheduled/Cron-based automation (Batch Processing).
* Purely manual procedural documentation.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **Trigger** | The specific event, signal, or user action that initiates the automation workflow. |
| **Payload** | The data or parameters passed to the automation at the time of invocation to customize its behavior. |
| **Idempotency** | The property of an automation where multiple identical requests have the same effect as a single request. |
| **Self-Service** | A model where end-users can trigger predefined automations without requiring intervention from a system administrator. |
| **Ephemeral Environment** | A temporary compute context created specifically for the duration of the on-demand task and destroyed upon completion. |
| **Callback** | A mechanism where the automation notifies the requester or a third-party system of its status or result. |

## Core Concepts

### 1. Trigger Modalities
On-demand automation is categorized by how it is invoked:
*   **User-Initiated:** Triggered via a dashboard, CLI, or ChatOps interface.
*   **System-Initiated (Event-Driven):** Triggered by a state change in another system (e.g., a code commit, a monitoring alert, or a database update).
*   **API-Driven:** Triggered by external software via a standardized interface (REST, gRPC, etc.).

### 2. Parameterization
Unlike static scripts, on-demand automation relies on dynamic input. The system must validate these inputs against a schema before execution to ensure security and predictability.

### 3. Execution Context
ODA requires a runtime environment that is provisioned "just-in-time." This context must include the necessary dependencies, credentials (injected securely), and compute resources required to fulfill the specific request.

### 4. Observability and Feedback
Because ODA happens outside of a fixed schedule, real-time feedback is critical. This includes logs, status updates (Pending, Running, Succeeded, Failed), and output data returned to the requester.

## Standard Model
The standard model for On Demand Automation follows a four-stage pipeline:

1.  **Request & Authentication:** The requester provides credentials and a payload. The system verifies the requester's identity and their authorization to execute the specific automation.
2.  **Validation & Queuing:** The system validates the payload against predefined constraints. If valid, the task is placed in a queue to manage concurrency and resource allocation.
3.  **Execution:** A worker picks up the task, prepares the environment, injects secrets, and executes the logic.
4.  **Reporting & Cleanup:** The system captures the output, notifies the requester, and tears down the execution environment to free up resources.

## Common Patterns

### ChatOps
Integrating automation triggers into collaboration tools (e.g., Slack, Teams). This allows teams to trigger deployments or diagnostic scripts within the context of a conversation.

### Webhook Integration
Using HTTP callbacks from third-party services to trigger internal workflows. For example, a vulnerability scanner finding a flaw and triggering an automated patching workflow.

### The "Sidecar" Pattern
Running an on-demand automation task alongside a primary application to perform maintenance tasks like log rotation, cache clearing, or database migrations without interrupting the main service.

### Self-Service Portals
Providing a simplified UI for non-technical users to perform complex tasks (e.g., "Provision a Sandbox Environment") without needing access to the underlying infrastructure.

## Anti-Patterns

*   **The "Fire and Forget" Fallacy:** Triggering an automation without a mechanism to track its success or failure.
*   **Hardcoded Credentials:** Embedding secrets within the automation logic rather than injecting them at runtime based on the requester's context.
*   **Lack of Rate Limiting:** Allowing unlimited on-demand requests, which can lead to Denial of Service (DoS) on the underlying infrastructure.
*   **Monolithic Workflows:** Creating a single on-demand script that does too many things, making it difficult to debug and increasing the risk of partial failure.
*   **State Persistence:** Designing on-demand tasks that rely on the local file system of the worker, which is destroyed after execution.

## Edge Cases

*   **Race Conditions:** Two on-demand requests triggered simultaneously that attempt to modify the same resource.
*   **Payload Injection:** Malicious actors providing crafted input to execute unauthorized commands (similar to SQL injection).
*   **Network Partitioning:** The automation starts successfully, but the connection to the reporting service is lost, leaving the requester in an indefinite "Pending" state.
*   **Zombie Processes:** On-demand tasks that hang and fail to terminate, consuming resources indefinitely until manually cleared.

## Related Topics
*   **Infrastructure as Code (IaC):** Often used to define the environments where ODA executes.
*   **Event-Driven Architecture (EDA):** The broader architectural pattern that ODA often supports.
*   **Role-Based Access Control (RBAC):** Critical for governing who can trigger which automations.
*   **Observability:** The discipline of monitoring the health and output of automated tasks.

## Change Log

| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-16 | Initial AI-generated canonical documentation |