# 85. Desktop Flows RPA

Canonical documentation for 85. Desktop Flows RPA. This document defines concepts, terminology, and standard usage.

## Purpose
Desktop Flows Robotic Process Automation (RPA) exists to automate human-centric tasks within a graphical user interface (GUI) environment. It addresses the "last mile" of digital transformation by enabling integration with legacy systems, proprietary software, and local applications that lack modern Application Programming Interfaces (APIs). By mimicking human interactions—such as keystrokes, mouse movements, and data extraction from visual elements—Desktop Flows allow organizations to digitize workflows that would otherwise require manual intervention.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative.

## Scope
Clarify what is in scope and out of scope for this topic.

**In scope:**
* **UI Automation:** Interaction with desktop-based controls, windows, and elements.
* **Surface Automation:** Image recognition and Optical Character Recognition (OCR) for non-accessible UI elements.
* **Session Management:** Handling of user sessions, including attended and unattended execution modes.
* **Local Resource Orchestration:** Management of local files, system clipboards, and peripheral inputs.
* **Data Transformation:** Manipulation of data within the context of a desktop-based workflow.

**Out of scope:**
* **Cloud-to-Cloud API Integration:** Direct service-to-service communication without a UI component.
* **Hardware Robotics:** Physical mechanical automation.
* **Specific Vendor Implementations:** Proprietary syntax or features unique to specific software suites (e.g., Power Automate, UiPath, Blue Prism).

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **Attended RPA** | Automation that runs on a user’s workstation, triggered by and interacting with a human operator. |
| **Unattended RPA** | Automation that runs independently on a dedicated server or virtual machine without human intervention. |
| **UI Selector** | A hierarchical path or attribute set used to uniquely identify a specific element within a software interface. |
| **Surface Automation** | A method of automation that relies on visual pixel matching or OCR rather than underlying object properties. |
| **Control Tree** | The structural representation of all UI elements within an application, often used for navigation and identification. |
| **Orchestrator** | A centralized management system that schedules, deploys, and monitors desktop flows across multiple environments. |
| **Virtual Desktop Infrastructure (VDI)** | A technology that hosts a desktop operating system on a centralized server, often used for hosting unattended bots. |

## Core Concepts

### UI Element Identification
The foundation of Desktop Flows is the ability to identify and interact with software controls. This is primarily achieved through:
*   **Object-Based Identification:** Accessing the underlying metadata of a control (e.g., ID, Name, Class).
*   **Coordinate-Based Identification:** Interacting with specific X/Y coordinates on a screen (highly fragile).
*   **Visual Identification:** Using computer vision to find patterns or text on the screen.

### Execution Modes
Desktop Flows operate in two primary modes:
1.  **Foreground Execution:** The automation takes control of the mouse and keyboard, requiring the target application to be visible and in focus.
2.  **Background Execution:** The automation interacts with the application via system messages or hidden windows, allowing the machine to remain usable or locked (where supported).

### Error Handling and Resiliency
Because desktop environments are dynamic (e.g., unexpected pop-ups, network lag), Desktop Flows must incorporate:
*   **Wait Conditions:** Pausing execution until an element appears or a state changes.
*   **Exception Blocks:** Logic to handle failures, such as retrying a step or taking a screenshot for debugging.
*   **State Validation:** Confirming the application is in the expected state before proceeding.

## Standard Model
The standard model for Desktop Flows RPA follows a four-layer architecture:

1.  **Trigger Layer:** The mechanism that initiates the flow (e.g., a schedule, a manual click, or an external API call).
2.  **Logic Layer:** The conditional branching, loops, and data manipulation that define the business process.
3.  **Interaction Layer:** The specific commands sent to the UI (e.g., "Click Button," "Read Text").
4.  **Logging/Reporting Layer:** The output of the flow's success, failure, and telemetry data to a central repository.

## Common Patterns

### The "Search and Action" Pattern
The flow navigates to a search interface, inputs a unique identifier, waits for the results to load, and then performs an action on the specific result.

### The "Data Scraper" Pattern
The flow iterates through multiple pages or records in a legacy application, extracting data from specific fields and consolidating it into a structured format (e.g., CSV or Database).

### The "Bridge" Pattern
The flow acts as a connector between a modern system (like a web form) and a legacy system (like a mainframe terminal), moving data from one to the other where no API exists.

## Anti-Patterns

### Hardcoded Delays
Using fixed "Sleep" commands (e.g., "Wait 5 seconds") instead of dynamic "Wait for Element" logic. This leads to either unnecessary slowness or intermittent failures when the system is under load.

### Coordinate-Only Interaction
Relying on screen coordinates for clicking. This fails if the screen resolution changes, a window is moved, or a UI update shifts elements by even a few pixels.

### Monolithic Flows
Creating a single, massive flow that handles an entire end-to-end process. This makes debugging difficult and prevents the reuse of common components (like login sequences).

### Over-Reliance on OCR
Using OCR for elements that are accessible via the Control Tree. OCR is computationally expensive and prone to character misinterpretation (e.g., '0' vs 'O').

## Edge Cases

### Resolution and Scaling Mismatches
A flow developed on a 1080p monitor may fail when executed on a 4K monitor or a VDI with different DPI scaling settings, particularly if using surface automation.

### Unexpected System Dialogs
Operating system updates, anti-virus alerts, or "Save As" dialogs can steal focus from the target application, causing the flow to time out or interact with the wrong window.

### Session Disconnects
In unattended RPA, if a remote desktop session is disconnected or the screen is locked, certain UI interaction methods (specifically those requiring a "rendered" desktop) may fail.

### Application Latency
Legacy applications may experience "freezing" or "not responding" states. A robust flow must distinguish between a slow application and a crashed application.

## Related Topics
*   **84. API Integration:** The preferred alternative to RPA when interfaces are available.
*   **86. Process Mining:** The practice of discovering workflows that are candidates for Desktop Flows.
*   **102. Computer Vision:** The underlying technology for surface-based RPA.
*   **115. Workflow Orchestration:** The management of multiple flows in a complex ecosystem.

## Change Log
| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-16 | Initial AI-generated canonical documentation |