# 73. Expressions Overview

Canonical documentation for 73. Expressions Overview. This document defines concepts, terminology, and standard usage.

## Purpose
Expressions serve as the fundamental building blocks of logic and data transformation within computational systems. The purpose of an expression is to represent a value or a computation that results in a value. Unlike statements, which perform actions or control the flow of execution, expressions are evaluated to produce an output. This topic addresses the need for a standardized way to describe how data is combined, manipulated, and resolved across various formal languages and systems.

> [!NOTE]
> This documentation is intended to be implementation-agnostic and authoritative.

## Scope
Clarify what is in scope and out of scope for this topic.

**In scope:**
* **Structural Components:** The definition of operands, operators, and functions.
* **Evaluation Mechanics:** Rules governing how expressions are resolved (precedence, associativity).
* **Typing and Results:** The relationship between input types and the resulting output type.
* **Theoretical Boundaries:** The distinction between expressions, statements, and declarations.

**Out of scope:**
* **Specific Vendor Implementations:** Syntax specific to individual programming languages (e.g., C++, Python, SQL) except as illustrative examples.
* **Hardware-level Execution:** CPU-specific instruction sets or register management.
* **Compiler Optimization:** Specific algorithms for bytecode or machine code generation.

## Definitions
Provide precise definitions for key terms.

| Term | Definition |
|------|------------|
| **Expression** | A syntactic entity that may be evaluated to determine its value. |
| **Operand** | The data or value upon which an operator acts (e.g., variables, literals). |
| **Operator** | A symbol or keyword that represents a specific mathematical, logical, or relational manipulation. |
| **Evaluation** | The process of resolving an expression into a single resulting value. |
| **Arity** | The number of operands an operator takes (e.g., unary, binary, ternary). |
| **Precedence** | The hierarchy of rules that determines the order in which operators are evaluated. |
| **Associativity** | The rule determining the order of evaluation when operators of the same precedence appear in succession. |
| **Side Effect** | A change in the state of the system that occurs during the evaluation of an expression, beyond returning a value. |

## Core Concepts

### 1. Compositionality
Expressions are inherently recursive. An expression can be composed of other expressions, which are themselves composed of further sub-expressions. This allows for the construction of complex logic from simple primitives.

### 2. Evaluation Context
The value of an expression often depends on the environment or context in which it is evaluated. This context includes:
* **Variable Bindings:** The current values assigned to identifiers.
* **Scope:** The visibility and lifetime of variables within the expression.
* **State:** The global or local environment variables that may influence the result.

### 3. Pure vs. Impure Expressions
* **Pure Expressions:** Evaluation produces a value based solely on its inputs and has no side effects. Given the same inputs, a pure expression always yields the same result (referential transparency).
* **Impure Expressions:** Evaluation may modify external state (e.g., incrementing a global counter) or depend on external state that changes (e.g., reading a system clock).

## Standard Model

The standard model for expression processing follows a three-stage lifecycle:

1.  **Parsing:** The raw syntax is analyzed and converted into a structured format, typically an **Abstract Syntax Tree (AST)**. In this tree, internal nodes represent operators and leaf nodes represent operands.
2.  **Binding/Analysis:** Identifiers (variables) are linked to their respective memory locations or values. Type checking is performed to ensure that operators are compatible with their operands.
3.  **Reduction/Evaluation:** The tree is traversed (usually post-order) to compute the final value. Sub-expressions are resolved first, moving up the tree until a single root value remains.

### Order of Operations
The standard model relies on a strict hierarchy:
*   **Grouping:** Parentheses or brackets override default behavior.
*   **Precedence:** Higher-priority operators (e.g., multiplication) are evaluated before lower-priority ones (e.g., addition).
*   **Associativity:** Defines directionality (Left-to-Right or Right-to-Left) for operators of equal rank.

## Common Patterns

### Boolean Logic
Expressions used to determine truth values, often utilizing `AND`, `OR`, and `NOT` operators. These are foundational for conditional branching.

### Arithmetic Transformation
The use of mathematical operators (`+`, `-`, `*`, `/`, `%`) to derive numerical results from raw data.

### Relational Comparison
Expressions that compare two values to produce a boolean result (e.g., `greater than`, `equal to`, `not equal to`).

### Conditional (Ternary) Selection
A compact expression pattern that selects one of two values based on a boolean condition: `(condition) ? (value_if_true) : (value_if_false)`.

## Anti-Patterns

### Excessive Nesting
Deeply nested expressions (e.g., `a(b(c(d(e))))`) reduce readability and increase the likelihood of logic errors. This is often referred to as "Spaghetti Logic."

### Side-Effect Reliance
Embedding critical state changes within an expression (e.g., `if (x++ > 10)`) can lead to unpredictable behavior, especially in systems where the order of evaluation is not strictly guaranteed.

### Type Coercion Ambiguity
Relying on implicit type conversion (e.g., adding a string to an integer) can lead to "silent failures" or unexpected results that vary across different execution environments.

## Edge Cases

### Division by Zero
A classic evaluation failure where the mathematical result is undefined. Systems must define whether this results in an error, an infinity value, or a null state.

### Null/Undefined Operands
When an expression encounters a missing or uninitialized value. Standard approaches include "Null Propagation" (where the result becomes null) or "Short-circuiting" to a default value.

### Overflow and Underflow
Occurs when the result of an expression exceeds the maximum or minimum capacity of the underlying data type.

### Short-Circuit Evaluation
In logical `AND`/`OR` expressions, the second operand may not be evaluated if the first operand is sufficient to determine the final result. This can be an edge case if the second operand contains a necessary side effect.

## Related Topics
*   **74. Statement Syntax:** The distinction between expressions and executable statements.
*   **12. Type Systems:** How data types influence expression validity.
*   **45. Operator Overloading:** Redefining standard operators for custom data structures.
*   **88. Functional Programming:** Systems where expressions are the primary unit of logic.

## Change Log

| Version | Date | Description |
|---------|------|-------------|
| 1.0 | 2026-01-16 | Initial AI-generated canonical documentation |