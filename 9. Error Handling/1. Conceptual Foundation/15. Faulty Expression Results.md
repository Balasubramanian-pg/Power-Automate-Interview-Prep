# 15. Faulty Expression Results

## 1. Flow Overview
- **Flow Name**: Expression Validation and Data Sanitization Framework
- **Business Problem Statement**: Automated workflows frequently fail or produce "silent errors" when dynamic content contains null values, unexpected data types, or malformed strings. These "faulty expression results" lead to downstream data corruption and broken business logic.
- **Business Impact / Value**: Ensures data integrity across enterprise systems, reduces manual intervention for failed runs by 90%, and prevents "poison pill" data from reaching systems of record.
- **Trigger Type**: Instant (typically called as a Child Flow or via HTTP Request)
- **Trigger Source**: Parent Workflow / API Gateway
- **Systems / Connectors Involved**: Data Operations, HTTP Request/Response, Control Logic
- **Expected Run Frequency**: High (executed for every data transformation event)
- **Estimated Data Volume**: Variable; optimized for high-throughput JSON payloads.

## 2. Trigger Design
- **Trigger Connector & Action**: Request - When an HTTP request is received
- **Why This Trigger Was Chosen**: To provide a synchronous, reusable utility service that validates and sanitizes expressions before they are used in critical actions.
- **Trigger Conditions Used**: No
- **Trigger Condition Logic (if applicable)**: N/A
- **Polling vs Event-Based**: Event-Based (Push)
- **How Unnecessary Runs Are Avoided**: The flow is only invoked when a parent process identifies a high-risk data transformation step (e.g., converting a string to an integer or parsing complex JSON).

## 3. End-to-End Flow Narrative
The flow begins when a payload containing "raw" data is passed to the validation engine. 

1.  **Input Reception**: The flow receives a JSON object containing the values to be evaluated.
2.  **Type Verification**: The engine uses expressions to check if the data matches the expected schema (e.g., ensuring a "Price" field is actually a number and not a string like "N/A").
3.  **Null Coalescing**: The flow evaluates if any required fields are null. If a null is found where a value is required, it applies a "Safe Default" (e.g., 0 for numbers, "" for strings).
4.  **Logic Branching**: If an expression is deemed "Faulty" (e.g., a division by zero or an invalid date format), the flow enters a "Correction" branch.
5.  **Output Generation**: The flow returns a sanitized, "safe" version of the data back to the calling process, along with a boolean flag `isValid`.

> [!IMPORTANT]
> A "Faulty Expression Result" is often not a system error, but a logic error where the expression evaluates to something the next action cannot process.

## 4. Key Actions and Connectors
Document only the actions that influence logic, performance, or reliability.

| Action Name | Connector | Purpose | Key Inputs | Key Outputs | Why This Action |
|------------|-----------|---------|------------|-------------|----------------|
| Parse JSON | Data Operations | Validates schema structure | Raw Body | Typed Properties | Forces a schema check early to catch malformed inputs. |
| Compose_Sanitize | Data Operations | Executes complex logic | `coalesce()`, `if()` | Sanitized Value | Consolidates multiple logic checks into a single atomic step. |
| Response | Request | Returns data to parent | Status Code, Body | Validated Payload | Provides synchronous feedback to the calling flow. |

## 5. Control Logic and Flow Structure
- **Conditions Used**: Used to check for `null` or `empty` states before attempting complex transformations.
- **Switch Statements**: Used when handling multiple data types (String, Integer, Boolean, Object).
- **Loops (Apply to each / Do until)**: Avoided to maintain low latency; the flow processes single records or small arrays via the `Select` action.
- **Nested Loops**: No.
- **Parallel Branches**: Used to validate independent data points simultaneously to reduce total execution time.
- **Scope Usage**: "Try-Catch" scopes are wrapped around risky expressions (like `int()` or `base64()`) to prevent the entire flow from crashing on a single faulty value.

## 6. Error Handling and Monitoring
- **Anticipated Failure Scenarios**: Type mismatch (e.g., "ABC" passed to an integer field), Null Reference exceptions, and Index Out of Bounds in arrays.
- **Try Scope Logic**: Contains the primary data transformation expressions.
- **Catch Scope Logic**: Triggered if an expression fails. It logs the specific field that caused the error and assigns a "Fallback Value."
- **Finally Scope Logic**: Ensures a response is sent back to the parent flow regardless of success or failure.
- **Run After Configuration**: The "Catch" block is set to run only if the "Try" block "has failed" or "has timed out."
- **Failure Notification Method**: Adaptive Cards sent to a developer Teams channel for high-severity logic failures.
- **Logging Strategy**: Custom tracking IDs are passed through the flow to correlate the sanitization request with the original business transaction.
- **How to Debug a Failed Run**: Review the "Inputs" of the `Compose_Sanitize` action to see the raw data that triggered the faulty result.

> [!WARNING]
> Never allow a flow to "Succeed" if it has returned a fallback value that could negatively impact financial calculations. Use the `isValid` flag to alert the parent flow.

## 7. Data Handling and Expressions
- **Variables Used**: `varIsDataValid` (Boolean), `varErrorMessage` (String).
- **Key Expressions**: 
    - `coalesce(triggerBody()?['Value'], 0)`: Handles nulls.
    - `if(empty(item()), 'Default', item())`: Handles empty strings.
    - `substring(outputs('Value'), 0, min(length(outputs('Value')), 100))`: Prevents buffer overflow/string length errors.
- **Data Operations (Select / Filter array / Compose)**: `Compose` is used heavily for inline logic to minimize action count.
- **Why Expressions Were Used Instead of Actions**: Expressions are significantly faster and do not count against API request limits as heavily as individual "Condition" actions.

## 8. Performance and Scalability
- **Known Bottlenecks**: Large JSON arrays can slow down `Parse JSON` actions.
- **Loop Optimization Strategy**: Use the `Select` action with inline expressions instead of `Apply to each` to transform arrays.
- **Pagination Handling**: N/A (handled by the parent flow).
- **Concurrency Control**: Set to high (50+) to allow multiple parent flows to validate data simultaneously.
- **What Breaks at Higher Data Volumes**: Deeply nested JSON objects may exceed the expression depth limit.
- **Redesign Approach for Scale**: Move complex regex or heavy validation to an Azure Function if the payload exceeds 5MB.

## 9. Security and Governance
- **Connection Type (Personal / Service Account)**: Service Account (Managed Identity where possible).
- **Environment Strategy**: Deployed in a "Shared Services" environment.
- **Secrets Handling**: No secrets are processed; only data values. If PII is involved, "Secure Inputs/Outputs" are enabled.
- **DLP Considerations**: Ensure the "HTTP" connector is allowed in the same policy as the data source connectors.
- **Access Control Notes**: Only authorized parent flows (via IP filtering or Secret Key) can trigger the validation engine.

## 10. Testing and Validation
- **Test Scenarios Covered**: 
    - Input is `null`.
    - Input is an empty string `""`.
    - Input is the wrong data type (String instead of Int).
    - Input exceeds maximum character length.
- **Edge Cases Considered**: Special characters in strings, zero-value integers, and leap-year dates.
- **Failure Testing**: Intentionally passing malformed JSON to ensure the `Catch` block handles it gracefully.
- **Rerun / Recovery Strategy**: Since the flow is stateless, it can be safely retried by the parent flow.

## 11. Interview Question Mapping
- **Explain This Flow in 2â€“3 Minutes**: This is a centralized validation engine designed to catch "Faulty Expression Results." It intercepts data, checks for nulls or type mismatches using `coalesce` and `if` logic, and ensures that downstream systems only receive sanitized, predictable data.
- **How Failures Are Handled**: We use a Try-Catch scope pattern. If an expression fails (like trying to parse a non-date string), the Catch block assigns a safe default and flags the record as invalid without stopping the entire process.
- **How Performance Is Optimized**: By using the `Select` action and complex inline expressions instead of multiple `Condition` or `Apply to each` steps, we reduce the action count and execution time.
- **One Trade-Off Made**: We chose to use a Child Flow architecture. While this adds a small amount of latency (HTTP overhead), it provides a single point of maintenance for all validation logic across the organization.

## 12. Lessons Learned
- **Initial Issues**: Early versions used `Apply to each`, which was too slow for large datasets.
- **Improvements Made**: Switched to `coalesce()` expressions to replace 80% of the "Condition" actions.
- **What I Would Do Differently Now**: Implement a "Rules Engine" stored in a database (like Dataverse or SQL) so validation rules can be updated without editing the flow logic.

> [!TIP]
> Always use the `string()` function around dynamic content inside a `concat()` expression to prevent the entire expression from failing if one component is null.