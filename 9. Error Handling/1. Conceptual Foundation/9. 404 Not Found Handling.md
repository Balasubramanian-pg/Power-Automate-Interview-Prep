# 9. 404 Not Found Handling

## 1. Flow Overview
- **Flow Name**: Resource Resolution and 404 Exception Management
- **Business Problem Statement**: When external systems or users request resources that do not exist, systems often return generic errors or crash, leading to poor user experience and lack of visibility into broken links or missing data.
- **Business Impact / Value**: Standardizing 404 handling ensures system resilience, provides clear feedback to consumers, and enables proactive identification of "dead links" or synchronization gaps between systems.
- **Trigger Type**: Instant
- **Trigger Source**: API Gateway / HTTP Request / Internal Function Call
- **Systems / Connectors Involved**: HTTP Request/Response, Database/Storage (SQL, Dataverse, SharePoint), Logging Service (Azure Monitor, Splunk).
- **Expected Run Frequency**: High (Dependent on external traffic and data integrity).
- **Estimated Data Volume**: Low per request; high aggregate volume in public-facing scenarios.

## 2. Trigger Design
- **Trigger Connector & Action**: HTTP Request - "When an HTTP request is received"
- **Why This Trigger Was Chosen**: To intercept incoming resource requests in real-time and evaluate the existence of the requested entity before proceeding with business logic.
- **Trigger Conditions Used**: Yes
- **Trigger Condition Logic**: `@not(empty(triggerOutputs()?['queries']?['id']))` — Ensures the flow only processes requests that include a resource identifier.
- **Polling vs Event-Based**: Event-Based.
- **How Unnecessary Runs Are Avoided**: Schema validation at the trigger level rejects malformed requests before the flow logic executes, saving execution costs.

## 3. End-to-End Flow Narrative
The flow begins when a client system requests a specific resource via an ID. Upon receipt, the system attempts to retrieve the record from the primary data store. 

A decision point occurs immediately after the retrieval action: the system checks if the returned object is null or if the status code from the data store is a 404. If the resource is found, the flow proceeds to the standard success path. If the resource is missing, the flow enters the "Not Found" handling branch.

In the 404 branch, the system generates a structured JSON error response containing a correlation ID and a user-friendly message. Simultaneously, the event is logged to a monitoring service to track "Resource Not Found" trends. The flow terminates gracefully with a 404 status code, preventing downstream actions from executing on null data.

## 4. Key Actions and Connectors
Document only the actions that influence logic, performance, or reliability.

| Action Name | Connector | Purpose | Key Inputs | Key Outputs | Why This Action |
|------------|-----------|---------|------------|-------------|----------------|
| Get_Resource_ByID | SQL / Dataverse | Attempt to fetch the record. | Resource ID | Record Object | Primary check for existence. |
| Check_If_Exists | Control | Logic branch based on result. | `body('Get_Resource')` | Boolean | Determines if 404 logic is needed. |
| Response_404 | HTTP | Return standard error to client. | Status Code: 404 | JSON Error Body | Ensures API compliance. |
| Log_Missing_Resource | Application Insights | Telemetry for debugging. | Resource ID, Timestamp | Trace ID | Allows for proactive fixing of dead links. |

## 5. Control Logic and Flow Structure
- **Conditions Used**: A central condition checks if the output of the "Get Resource" action is empty or null.
- **Switch Statements**: Used if the 404 handling differs by resource type (e.g., a missing "User" returns a different message than a missing "Order").
- **Loops (Apply to each / Do until)**: None; 404 handling is typically a linear, single-item check.
- **Nested Loops**: No.
- **Parallel Branches**: Used to log the error to a database while simultaneously returning the HTTP response to the user to minimize latency.
- **Scope Usage**: "Try-Catch" scopes are used to wrap the retrieval logic. A 404 is often handled within the "Catch" or "Success" block depending on whether the connector treats a missing record as a "Failure" or a "Null Success."

## 6. Error Handling and Monitoring
- **Anticipated Failure Scenarios**: Database timeout (504) vs. Resource missing (404).
- **Try Scope Logic**: Contains the data retrieval action.
- **Catch Scope Logic**: If the "Get Resource" action fails with a 404 error code, the Catch scope intercepts this to format a clean response.
- **Finally Scope Logic**: Closes the connection and ensures telemetry is sent regardless of the outcome.
- **Run After Configuration**: The 404 Response action is set to run if the retrieval action "Succeeded" (but returned null) or "Failed" (with a 404 status).
- **Failure Notification Method**: Adaptive Cards to IT Ops if 404 rates exceed a specific threshold (indicating a possible system-wide sync issue).
- **Logging Strategy**: Log the Request URL, Client IP, and the specific ID that was not found.
- **How to Debug a Failed Run**: Check the "Inputs" of the retrieval action to see the ID passed, and verify if that ID exists in the source system.

## 7. Data Handling and Expressions
- **Variables Used**: `varResponseObject` (Object) to store the error message.
- **Key Expressions**: 
    - `empty(outputs('Get_Resource')?['body/value'])`
    - `coalesce(triggerOutputs()?['queries']?['id'], 'Unknown')`
- **Data Operations (Select / Filter array / Compose)**: `Compose` is used to build the standardized JSON error schema.
- **Why Expressions Were Used Instead of Actions**: Expressions like `empty()` are used within conditions to provide faster evaluation without adding extra steps to the flow designer.

## 8. Performance and Scalability
- **Known Bottlenecks**: High-latency lookups in legacy SQL databases.
- **Loop Optimization Strategy**: N/A (Single request pattern).
- **Pagination Handling**: N/A.
- **Concurrency Control**: High concurrency should be enabled on the trigger to handle bursts of requests.
- **What Breaks at Higher Data Volumes**: If the logging service (e.g., a SharePoint list) is not performant, the 404 handling will slow down the entire API response.
- **Redesign Approach for Scale**: Implement a Redis cache layer to store "Negative Results" (Negative Caching) so the flow doesn't hit the database for repeated requests of the same missing ID.

## 9. Security and Governance
- **Connection Type (Personal / Service Account)**: Service Account with Read-Only access to the data source.
- **Environment Strategy**: Managed environments with DLP policies preventing the 404 logs from being sent to unauthorized external connectors.
- **Secrets Handling**: API Keys or Bearer tokens for the trigger are managed via Azure Key Vault.
- **DLP Considerations**: Ensure that the "Not Found" response does not leak sensitive metadata (e.g., server names or stack traces).
- **Access Control Notes**: Only authorized clients should be able to trigger the resource lookup.

> [!WARNING]
> Avoid returning detailed system errors in the 404 response body. This can lead to information disclosure vulnerabilities.

## 10. Testing and Validation
- **Test Scenarios Covered**: 
    1. Valid ID (Expect 200 OK).
    2. Non-existent ID (Expect 404 Not Found).
    3. Malformed ID (Expect 400 Bad Request).
- **Edge Cases Considered**: ID exists but is marked as "Deleted" (Soft-delete logic should also return 404).
- **Failure Testing**: Simulate database downtime to ensure the system returns a 500/503 instead of a misleading 404.
- **Rerun / Recovery Strategy**: 404s are generally not retried unless they are suspected to be caused by eventual consistency delays.

## 11. Interview Question Mapping
- **Explain This Flow in 2–3 Minutes**: I designed a robust resource resolution pattern that intercepts incoming requests, validates the existence of data, and handles missing records by returning a standardized 404 response while logging the event for audit purposes.
- **How Failures Are Handled**: We use "Run After" configurations to distinguish between a record that is truly missing (404) and a connection failure to the database (500).
- **How Performance Is Optimized**: By using trigger conditions to filter out bad requests early and utilizing parallel branches for logging to ensure the user receives a response as quickly as possible.
- **One Trade-Off Made**: We chose to return a generic "Resource Not Found" message rather than specific details to prioritize security over verbose debugging information for the end-user.

## 12. Lessons Learned
- **Initial Issues**: Initially, the flow returned a 200 OK with an empty body when a resource was missing, which confused client-side developers.
- **Improvements Made**: Implemented proper HTTP status codes (404) and added a "Correlation ID" to the error body to link client reports to server logs.
- **What I Would Do Differently Now**: I would implement a "Negative Cache" in Redis to prevent repeated database hits for known non-existent IDs, especially during potential scraping attacks.

> [!TIP]
> Always use a standardized JSON schema for error responses so that front-end applications can implement a single global error-handling component.