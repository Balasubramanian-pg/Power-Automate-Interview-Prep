# 10. 400 Bad Request Diagnostics

## 1. Flow Overview
- **Flow Name**: API Request Validation and 400 Error Diagnostic Framework
- **Business Problem Statement**: Automated workflows frequently fail due to "400 Bad Request" errors when communicating with internal or external APIs. These errors are often opaque, providing little information on whether the failure was due to malformed JSON, missing headers, data type mismatches, or schema violations.
- **Business Impact / Value**: Reduces Mean Time to Repair (MTTR) by providing granular visibility into request payloads. Prevents data loss by identifying invalid records before they enter downstream systems and reduces API consumption costs by eliminating redundant, malformed calls.
- **Trigger Type**: Automated (Error-triggered or Inline Validation)
- **Trigger Source**: HTTP Request, Webhook, or Child Flow call.
- **Systems / Connectors Involved**: HTTP Connector, JSON Schema Validator, Logging Service (e.g., Azure Application Insights, Splunk, or Dataverse).
- **Expected Run Frequency**: High (Executes on every outbound API call or inbound webhook).
- **Estimated Data Volume**: Variable; depends on the payload size of the business transaction.

## 2. Trigger Design
- **Trigger Connector & Action**: HTTP Request / Response or "When an HTTP request is received."
- **Why This Trigger Was Chosen**: To intercept data at the point of entry or exit. In a diagnostic context, this flow often acts as a "Wrapper" or "Middleware" to inspect traffic.
- **Trigger Conditions Used**: Yes
- **Trigger Condition Logic**: `@equals(triggerOutputs()?['statusCode'], 400)` (Used when this is a dedicated error-handling child flow).
- **Polling vs Event-Based**: Event-Based.
- **How Unnecessary Runs Are Avoided**: By using schema validation at the trigger level to reject obviously malformed requests before the logic executes.

## 3. End-to-End Flow Narrative
The flow begins when an outbound HTTP action or an inbound webhook encounters a 400 Bad Request status. 

1. **Capture**: The flow captures the raw request body, headers, and the specific error message returned by the server.
2. **Evaluation**: The diagnostic logic checks for common "400" culprits:
    - Is the JSON syntax valid?
    - Are required fields present?
    - Do data types match the target API's requirements (e.g., String vs. Integer)?
    - Are headers (like `Content-Type: application/json`) missing?
3. **Decision**: If the error is a schema mismatch, the flow logs the specific field causing the issue. If it is a syntax error, it flags the payload for manual review.
4. **Resolution**: The flow ends by either sending a formatted alert to the developer team or passing a sanitized error object back to the parent flow for graceful termination.

> [!IMPORTANT]
> A 400 error is a "Client Error." Unlike 500-series errors, retrying a 400 error without changing the request payload will result in the same failure and potentially lead to account lockout or rate limiting.

## 4. Key Actions and Connectors
Document only the actions that influence logic, performance, or reliability.

| Action Name | Connector | Purpose | Key Inputs | Key Outputs | Why This Action |
|------------|-----------|---------|------------|-------------|----------------|
| Parse JSON | Data Operations | Validates payload against a known schema. | Body of the request | Structured Data / Error | To identify exactly which field failed validation. |
| Compose (Request Dump) | Data Operations | Captures the full state of the request. | `outputs('HTTP')` | Full JSON object | Essential for debugging transient API issues. |
| Filter Array | Data Operations | Isolates null or empty values in the payload. | Request Body | Array of empty fields | Identifies missing required parameters. |
| HTTP (Diagnostic Call) | HTTP | Tests the endpoint with a minimal payload. | Static Test JSON | Status Code | Determines if the issue is the data or the endpoint configuration. |

## 5. Control Logic and Flow Structure
- **Conditions Used**: Used to check if the error message contains specific keywords (e.g., "Required field missing" or "Invalid Type").
- **Switch Statements**: Used to route diagnostics based on the specific API being called (different APIs return different 400 error formats).
- **Loops (Apply to each / Do until)**: Used to iterate through validation error arrays returned by complex JSON schemas.
- **Nested Loops**: No. Nested loops are avoided to maintain performance during error handling.
- **Parallel Branches**: Used to simultaneously log the error to a database and send a real-time notification to a monitoring channel (Teams/Slack).
- **Scope Usage**: "Try-Catch" blocks are mandatory. The diagnostic logic resides in the "Catch" scope of the primary business logic.

## 6. Error Handling and Monitoring
- **Anticipated Failure Scenarios**: API returns a 400 but with an HTML error page instead of JSON; API is behind a WAF that blocks the request entirely.
- **Try Scope Logic**: Contains the primary API call and data transformation.
- **Catch Scope Logic**: Triggered if the primary call returns a 400. It parses the `outputs('Action_Name')?['body']` to extract the error details.
- **Finally Scope Logic**: Cleans up temporary variables and updates the parent record status to "Failed - Validation Error."
- **Run After Configuration**: The diagnostic scope is set to run only if the primary action "has failed."
- **Failure Notification Method**: Adaptive Cards in Microsoft Teams or email alerts containing the Correlation ID.
- **Logging Strategy**: Log the Request ID, Timestamp, Target URL, and the specific validation error to a centralized log.
- **How to Debug a Failed Run**: Review the "Compose (Request Dump)" output to see exactly what was sent to the API vs. what the API expected.

> [!TIP]
> Always check the `Content-Type` header. A common cause of 400 errors is sending a JSON string to an endpoint expecting `x-www-form-urlencoded` data.

## 7. Data Handling and Expressions
- **Variables Used**: `varErrorDetails` (String), `varIsSchemaValid` (Boolean).
- **Key Expressions**: 
    - `actions('HTTP_Action')?['outputs']?['body']?['error']?['message']` to extract the specific error text.
    - `base64ToString(...)` if the API returns a base64 encoded error response.
- **Data Operations (Select / Filter array / Compose)**: `Select` is used to map the API's error array into a human-readable format.
- **Why Expressions Were Used Instead of Actions**: Expressions are used to safely navigate JSON properties that might not exist (`?` operator) to prevent the diagnostic flow itself from failing.

## 8. Performance and Scalability
- **Known Bottlenecks**: Large payload parsing can slow down the diagnostic flow.
- **Loop Optimization Strategy**: Use `Filter Array` instead of `Apply to each` when searching for specific error codes in a response.
- **Pagination Handling**: Not applicable for 400 diagnostics.
- **Concurrency Control**: High concurrency is enabled to ensure that one malformed request doesn't block the diagnostic processing of others.
- **What Breaks at Higher Data Volumes**: Logging large payloads to a database can hit storage limits or API throttling on the logging connector.
- **Redesign Approach for Scale**: Offload detailed payload logging to a dedicated blob storage or log analytics workspace rather than a transactional database.

## 9. Security and Governance
- **Connection Type (Personal / Service Account)**: Service Account (Principal) to ensure consistent access to API logs.
- **Environment Strategy**: Diagnostics are deployed as a shared resource (Child Flow) across the environment.
- **Secrets Handling**: Ensure that sensitive data (PII, Credentials) is scrubbed from the request body before it is logged in the "Catch" block.
- **DLP Considerations**: The HTTP connector must be in the "Business" data group to interact with internal APIs.
- **Access Control Notes**: Only administrators and the DevOps team should have access to the diagnostic logs.

> [!WARNING]
> Never log raw Authorization headers or API Keys in your diagnostic "Compose" actions. Use the "Secure Outputs" setting in the action configuration.

## 10. Testing and Validation
- **Test Scenarios Covered**: 
    - Missing required field.
    - Incorrect data type (sending "ABC" to an integer field).
    - Malformed JSON (missing a comma or bracket).
    - Exceeding character limits.
- **Edge Cases Considered**: API returns a 400 but the body is empty; API returns a 400 but the `Content-Type` is `text/plain`.
- **Failure Testing**: Intentionally sending "junk" data to the flow to ensure the diagnostic logic correctly identifies the failure reason.
- **Rerun / Recovery Strategy**: Once the data is corrected in the source system, the flow can be resubmitted.

## 11. Interview Question Mapping
- **Explain This Flow in 2â€“3 Minutes**: This is a diagnostic framework designed to handle 400 Bad Request errors. It uses a Try-Catch pattern to intercept failed API calls, parses the error response to identify if the issue is a schema violation or a syntax error, and logs the sanitized details for developer review.
- **How Failures Are Handled**: Failures are caught using "Run After" configurations. The flow distinguishes between transient network issues and permanent data issues (400s), ensuring we don't waste resources retrying invalid data.
- **How Performance Is Optimized**: By using non-blocking expressions and avoiding heavy loops, the diagnostic overhead is kept under 200ms per run.
- **One Trade-Off Made**: We chose to truncate logged payloads over 100KB to save on storage costs, even though this might occasionally hide the specific field that caused a 400 error in extremely large files.

## 12. Lessons Learned
- **Initial Issues**: Initially, the diagnostic flow would fail if the API returned an error message that wasn't in JSON format.
- **Improvements Made**: Added a check to verify if the response is valid JSON before attempting to parse it; added "Secure Inputs/Outputs" to protect PII.
- **What I Would Do Differently Now**: I would implement a "Schema Registry" where the flow could dynamically pull the latest API requirements to provide even more precise diagnostic feedback.