# 3. Happy Path vs Resilient Path

## 1. Flow Overview
- **Flow Name**: Resilient Transactional Processing Pattern
- **Business Problem Statement**: Standard "Happy Path" designs assume perfect network conditions, valid data, and 100% system uptime. When these assumptions fail, workflows terminate prematurely, leaving data in inconsistent states and requiring manual IT intervention.
- **Business Impact / Value**: Transitioning from a Happy Path to a Resilient Path reduces manual support tickets by up to 90%, ensures data integrity through atomicity, and maintains business continuity during downstream system outages.
- **Trigger Type**: Automated
- **Trigger Source**: Enterprise Service Bus (e.g., Azure Service Bus, RabbitMQ) or Webhook
- **Systems / Connectors Involved**: Source System (CRM/ERP), Middleware/Orchestrator, Target Database/API, Logging Service.
- **Expected Run Frequency**: High-volume, real-time processing.
- **Estimated Data Volume**: 10,000+ transactions per day.

## 2. Trigger Design
- **Trigger Connector & Action**: Service Bus - When a message is received in a queue (Peek-Lock).
- **Why This Trigger Was Chosen**: Peek-Lock is essential for the Resilient Path. It ensures the message is not deleted from the queue until the workflow explicitly completes successfully. If the flow fails, the message remains in the queue for a retry.
- **Trigger Conditions Used**: Yes
- **Trigger Condition Logic**: `@equals(triggerBody()?['MessageStatus'], 'Ready')`
- **Polling vs Event-Based**: Event-Based (Push) to minimize latency and reduce unnecessary compute costs.
- **How Unnecessary Runs Are Avoided**: Trigger conditions filter out malformed or incomplete messages at the entry point, preventing the orchestrator from spinning up instances for invalid data.

## 3. End-to-End Flow Narrative
The flow begins when a message enters the queue. 

**The Happy Path**:
The flow assumes the message is perfectly formatted. It immediately parses the JSON, updates the target ERP system, sends a success notification, and completes the message. There are no checks, no retries, and no error handling.

**The Resilient Path**:
1. **Initialization**: The flow enters a "Try" scope.
2. **Validation**: It checks for the existence of required fields. If missing, it routes to a "Dead Letter" queue rather than failing blindly.
3. **Execution**: It attempts the API call to the ERP. 
4. **Decision Point**: If the API returns a 429 (Rate Limit) or 5xx (Server Error), the Resilient Path utilizes a retry policy with exponential backoff.
5. **Error Handling**: If all retries fail, the "Catch" scope is triggered. The error is logged, and the message is abandoned (returned to the queue) or moved to a Dead Letter Queue (DLQ) for manual review.
6. **Finalization**: The "Finally" scope ensures that regardless of success or failure, the execution state is logged to a centralized dashboard.

## 4. Key Actions and Connectors
Documenting the structural components that differentiate the Resilient Path.

| Action Name | Connector | Purpose | Key Inputs | Key Outputs | Why This Action |
|------------|-----------|---------|------------|-------------|----------------|
| Try_Scope | Control | Encapsulates main logic | N/A | N/A | Groups actions for unified error handling. |
| ERP_API_Call | HTTP / Custom | Data persistence | JSON Payload | Status Code | The primary integration point. |
| Catch_Scope | Control | Error processing | Error Details | Log Entry | Executes only if Try_Scope fails. |
| Dead_Letter_Msg | Service Bus | Isolation | Message ID | Success/Fail | Prevents "Poison Messages" from looping. |
| Log_Telemetry | Application Insights | Observability | Execution Metadata | Trace ID | Provides visibility into failures. |

## 5. Control Logic and Flow Structure
- **Conditions Used**: Used for data validation (e.g., "Does record exist?") before attempting updates.
- **Switch Statements**: Used to handle different API response codes (200, 400, 404, 500) with specific logic for each.
- **Loops (Apply to each / Do until)**: "Do until" is used for custom polling scenarios where a downstream process is asynchronous.
- **Nested Loops**: No. Nested loops are avoided to prevent performance degradation; "Filter Array" is used instead.
- **Parallel Branches**: Used in the "Catch" block to simultaneously notify the DevOps team and log the error to a database.
- **Scope Usage**: **Mandatory.** Scopes (Try, Catch, Finally) are the foundation of the Resilient Path.

## 6. Error Handling and Monitoring
- **Anticipated Failure Scenarios**: Downstream API downtime, Authentication token expiration, Data schema mismatch, Rate limiting (Throttling).
- **Try Scope Logic**: Contains the "Happy Path" actions.
- **Catch Scope Logic**: Configured to run only if the Try Scope "has failed," "has timed out," or "is skipped."
- **Finally Scope Logic**: Runs regardless of success or failure to clean up resources or close the message lock.
- **Run After Configuration**: This is the critical setting. The Catch scope is set to `runAfter` the Try scope fails.
- **Failure Notification Method**: Adaptive Cards sent to a Microsoft Teams Developer Channel or PagerDuty alerts.
- **Logging Strategy**: Correlation IDs are passed through every action to allow end-to-end tracing across multiple systems.
- **How to Debug a Failed Run**: Use the Correlation ID to pull logs from Application Insights and review the "Catch" scope inputs to see the specific exception message.

> [!IMPORTANT]
> A Resilient Path without a Dead Letter Queue (DLQ) strategy is just a delayed Happy Path. Always ensure "Poison Messages" are isolated.

## 7. Data Handling and Expressions
- **Variables Used**: `varIsSuccess` (Boolean), `varRetryCount` (Integer), `varErrorDetails` (String).
- **Key Expressions**: 
    - `coalesce()`: To provide default values for null fields.
    - `empty()`: To validate collections before looping.
    - `result('Try_Scope')`: To extract error messages from the failed scope.
- **Data Operations (Select / Filter array / Compose)**: "Filter array" is used to validate data sets without entering a loop, significantly increasing speed.
- **Why Expressions Were Used Instead of Actions**: Expressions like `if()` and `coalesce()` are used inside actions to reduce the total action count, which improves performance and reduces cost.

## 8. Performance and Scalability
- **Known Bottlenecks**: Synchronous API calls to legacy systems.
- **Loop Optimization Strategy**: Enable "Concurrency Control" on loops to process records in parallel (up to 50).
- **Pagination Handling**: Enabled on "Get Records" actions to handle datasets exceeding 5,000 items.
- **Concurrency Control**: Set to a specific limit (e.g., 20) to avoid overwhelming the downstream ERP database.
- **What Breaks at Higher Data Volumes**: The "Happy Path" breaks due to timeout limits; the "Resilient Path" handles this via asynchronous patterns.
- **Redesign Approach for Scale**: Move from a single sequential flow to a "Producer-Consumer" pattern using message queues.

## 9. Security and Governance
- **Connection Type (Personal / Service Account)**: Service Account (Principal-based) is mandatory for production resilience.
- **Environment Strategy**: Development -> UAT -> Production (Managed Environments).
- **Secrets Handling**: All API keys and connection strings are retrieved from **Azure Key Vault** at runtime.
- **DLP Considerations**: Ensure the "HTTP" connector and "Service Bus" connector are in the same Business data group.
- **Access Control Notes**: Only the Service Account has "Write" access to the target ERP; users have "Read-Only."

## 10. Testing and Validation
- **Test Scenarios Covered**: 
    1. Valid data (Happy Path).
    2. Invalid JSON schema (Resilient Path - Validation).
    3. Downstream API 500 error (Resilient Path - Retry).
    4. Downstream API 401 error (Resilient Path - Auth Refresh).
- **Edge Cases Considered**: Empty payloads, duplicate messages (Idempotency check), and extremely large attachments.
- **Failure Testing**: Manually disabling the target API to ensure the "Catch" scope triggers and logs correctly.
- **Rerun / Recovery Strategy**: Logic is designed to be **Idempotent**. If a flow is rerun, it checks if the work was already done to avoid duplicate entries.

> [!TIP]
> Design every action as if it will be executed twice. Idempotency is the secret to true resilience.

## 11. Interview Question Mapping
- **Explain This Flow in 2â€“3 Minutes**: "I design workflows using a Try-Catch-Finally architecture. While the Happy Path handles the standard business logic, the Resilient Path focuses on exception handling, retries, and data integrity. For example, in an order processing flow, I use Peek-Lock triggers and Scopes to ensure that if a system fails, the order isn't lost but is instead retried or safely moved to a Dead Letter Queue."
- **How Failures Are Handled**: "Failures are caught using 'Run After' configurations. I extract the error message using the `result()` expression and log it to a central repository while notifying the support team via Teams."
- **How Performance Is Optimized**: "I use concurrency control on loops, filter arrays to minimize iterations, and offload complex logic to expressions rather than multiple sequential actions."
- **One Trade-Off Made**: "The Resilient Path adds complexity and slightly higher latency due to the extra checks, but this is a necessary trade-off to ensure 99.9% data reliability."

## 12. Lessons Learned
- **Initial Issues**: Early versions used "Happy Path" logic, which caused "Zombie Runs" where flows stayed in a 'Running' state indefinitely during API outages.
- **Improvements Made**: Implemented explicit timeouts on HTTP actions and added a "Finally" scope to ensure the flow always reaches a terminal state (Succeeded/Failed).
- **What I Would Do Differently Now**: I would implement a "Circuit Breaker" pattern. If the flow fails 5 times in a row, it should automatically disable the trigger to prevent further system strain until a human intervenes.

> [!CAUTION]
> Never use "Personal" connections in a Resilient Path. If the employee leaves the company, the "Resilient" flow will immediately fail due to authentication revocation.