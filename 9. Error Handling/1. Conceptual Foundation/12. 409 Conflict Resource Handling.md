# 12. 409 Conflict Resource Handling

## 1. Flow Overview
- **Flow Name**: Automated Conflict Resolution and State Synchronization
- **Business Problem Statement**: In distributed systems or high-concurrency environments, multiple processes often attempt to update the same resource simultaneously. This results in HTTP 409 Conflict errors, leading to data desynchronization, failed transactions, and inconsistent state between the source of truth and downstream consumers.
- **Business Impact / Value**: Ensures data integrity across systems, reduces manual intervention for failed syncs, and prevents "lost update" scenarios where concurrent changes overwrite one another without validation.
- **Trigger Type**: Automated
- **Trigger Source**: Upstream API Webhook or Data Event (e.g., Resource Created/Updated)
- **Systems / Connectors Involved**: REST API (HTTP), Cloud Database (e.g., Dataverse, SQL, or NoSQL), and State Management Service.
- **Expected Run Frequency**: High (triggered on every resource modification attempt).
- **Estimated Data Volume**: Variable; depends on the frequency of concurrent writes to specific high-traffic resources.

## 2. Trigger Design
- **Trigger Connector & Action**: HTTP Webhook / Generic Webhook Receiver.
- **Why This Trigger Was Chosen**: To provide a real-time response to state changes. Using a webhook allows the system to react immediately to a conflict rather than waiting for a polling interval, which would increase the window for further conflicts.
- **Trigger Conditions Used**: Yes.
- **Trigger Condition Logic**: `@not(equals(triggerOutputs()?['body']?['status'], 'ignored'))` — ensures the flow only triggers for actionable resource states.
- **Polling vs Event-Based**: Event-Based.
- **How Unnecessary Runs Are Avoided**: Implementation of server-side filtering at the source and trigger conditions to ignore "Read" events or heartbeat signals.

## 3. End-to-End Flow Narrative
The flow begins when an upstream system sends a data payload intended to update a specific resource. The flow attempts a standard `PUT` or `PATCH` operation. 

If the target system returns an **HTTP 409 Conflict**, the flow does not terminate. Instead, it enters a specialized "Catch" scope. Inside this scope, the flow performs a "Get" operation to retrieve the current version of the resource from the target system, including its unique identifier (like an ETag or Version Number).

The flow then executes a logic-based comparison: it evaluates whether the incoming data is newer than the existing data (using timestamps) or if the changes can be merged. If a merge is possible, the flow constructs a new payload combining the updates and re-submits the request using the correct version header (`If-Match`). If the conflict is irreconcilable (e.g., the resource was deleted or fundamentally changed), the flow logs the conflict and alerts an administrator.

## 4. Key Actions and Connectors
Document only the actions that influence logic, performance, or reliability.

| Action Name | Connector | Purpose | Key Inputs | Key Outputs | Why This Action |
|------------|-----------|---------|------------|-------------|----------------|
| **Update Resource** | HTTP / Custom | Primary update attempt. | Payload, Resource ID | Status Code, Body | The initial action that may trigger the 409. |
| **Get Current State** | HTTP / Custom | Fetch latest version. | Resource ID | ETag, Current Body | Necessary to resolve the conflict. |
| **Compare Versions** | Filter Array / Compose | Logic check. | Current vs. New Data | Boolean (Is Newer?) | Determines if the update is still valid. |
| **Retry with ETag** | HTTP | Final resolution. | Merged Payload, ETag | 200 OK / 204 No Content | Completes the sync using optimistic concurrency. |

## 5. Control Logic and Flow Structure
- **Conditions Used**: Used to compare timestamps (`LastModified`) and ETag values to decide between "Overwrite," "Merge," or "Discard."
- **Switch Statements**: Used to handle different HTTP status codes (404 vs 409 vs 500) within the error handling block.
- **Loops (Apply to each / Do until)**: A **Do Until** loop is implemented for a limited number of retries (e.g., 3 attempts) in case the resource is under heavy contention.
- **Nested Loops**: No; avoided to prevent performance degradation and complexity.
- **Parallel Branches**: Used to simultaneously log the conflict to a monitoring dashboard while attempting the resolution logic.
- **Scope Usage**: Extensive use of **Try-Catch-Finally** blocks to encapsulate the primary update logic and the subsequent conflict resolution logic.

## 6. Error Handling and Monitoring
- **Anticipated Failure Scenarios**: Persistent 409s (deadlock), 412 Precondition Failed (ETag mismatch during retry), and 404 Resource Deleted.
- **Try Scope Logic**: Contains the initial `PATCH` or `PUT` request.
- **Catch Scope Logic**: Configured to run only if the Try scope fails. It filters for the 409 status code and initiates the "Fetch-Compare-Resubmit" pattern.
- **Finally Scope Logic**: Updates the transaction log with the final outcome (Success/Resolved/Failed).
- **Run After Configuration**: The Conflict Resolution Scope is set to "Run After" the Primary Update has "Failed."
- **Failure Notification Method**: Adaptive Cards sent to a Microsoft Teams channel or an email to the DevOps alias if the "Do Until" loop exceeds maximum retries.
- **Logging Strategy**: Centralized logging using Application Insights or a dedicated SQL log table capturing the Correlation ID, Conflict Reason, and Resolution Path.
- **How to Debug a Failed Run**: Review the "Get Current State" output in the Catch block to see the delta between the submitted payload and the server's state.

## 7. Data Handling and Expressions
- **Variables Used**: `varRetryCount` (Integer), `varIsResolved` (Boolean), `varCurrentETag` (String).
- **Key Expressions**: 
    - `outputs('Get_Current_State')?['headers']?['ETag']` to extract concurrency tokens.
    - `if(greater(triggerBody()?['timestamp'], body('Get_Current_State')?['timestamp']), true, false)` to validate data freshness.
- **Data Operations (Select / Filter array / Compose)**: **Compose** is used to build the JSON payload for the retry attempt to ensure no properties are lost during the merge.
- **Why Expressions Were Used Instead of Actions**: Expressions are used for timestamp comparisons to reduce the number of actions in the flow, improving execution speed and readability.

## 8. Performance and Scalability
- **Known Bottlenecks**: The "Get" request inside the Catch block adds latency. High-frequency conflicts can lead to API throttling.
- **Loop Optimization Strategy**: The **Do Until** loop includes a `delay` action using exponential backoff (e.g., 2^retry seconds) to reduce pressure on the target API.
- **Pagination Handling**: Not applicable for single resource updates, but handled in the "Get" action if the resource is a collection.
- **Concurrency Control**: The flow itself is set to a high concurrency limit, but the logic relies on **Optimistic Concurrency Control (OCC)** via ETags.
- **What Breaks at Higher Data Volumes**: If hundreds of processes hit the same record, the "Do Until" loop may exhaust retries, leading to a "Final Failure."
- **Redesign Approach for Scale**: Move to a message queue (e.g., Azure Service Bus) with a "Sequential Session" lock to process updates to the same Resource ID one at a time.

## 9. Security and Governance
- **Connection Type (Personal / Service Account)**: Service Account (Principal) with "Contributor" or "Data Writer" permissions.
- **Environment Strategy**: Developed in Dev, validated in UAT with simulated race conditions, and deployed to Production via Managed Solutions/Pipelines.
- **Secrets Handling**: All API Keys and Client Secrets are retrieved from **Azure Key Vault**; "Secure Inputs/Outputs" is enabled on HTTP actions.
- **DLP Considerations**: Ensure the HTTP connector is in the "Business" data group to allow communication with the database connectors.
- **Access Control Notes**: Only the Service Account and designated Admins have "Run-Only" or "Owner" permissions on the flow.

## 10. Testing and Validation
- **Test Scenarios Covered**: 
    1. Successful update (No conflict).
    2. Conflict detected and resolved via "Last-Writer-Wins."
    3. Conflict detected and resolved via "Merge."
    4. Conflict detected but resolution fails (Manual intervention triggered).
- **Edge Cases Considered**: Resource deleted between the 409 error and the "Get" attempt; ETag format changes.
- **Failure Testing**: Artificially inducing 409s by running two instances of the flow simultaneously with different data for the same ID.
- **Rerun / Recovery Strategy**: Flows can be resubmitted from the failed trigger; the logic is idempotent, meaning re-running will not cause duplicate data if the conflict was already resolved.

## 11. Interview Question Mapping
- **Explain This Flow in 2–3 Minutes**: "I designed a robust resource handling flow that manages HTTP 409 Conflicts. When an update fails due to a state mismatch, the flow automatically catches the error, fetches the latest version of the record, compares the data using timestamps and ETags, and attempts a merge-back. This ensures that concurrent updates don't crash the process or lose data."
- **How Failures Are Handled**: "I use a Try-Catch pattern. The Catch block specifically looks for 409 errors. It uses an exponential backoff retry policy and optimistic concurrency headers to resolve the conflict without overwriting newer data."
- **How Performance Is Optimized**: "By using expressions for logic instead of multiple condition actions and implementing a 'Do Until' loop with a delay to prevent API hammering during high contention."
- **One Trade-Off Made**: "I chose Optimistic Concurrency (ETags) over Pessimistic Locking. While locking prevents conflicts entirely, it significantly reduces throughput and can lead to deadlocks in this specific architecture."

## 12. Lessons Learned
- **Initial Issues**: Initially, the flow just retried the same payload, which resulted in an infinite 409 loop because the ETag was never updated.
- **Improvements Made**: Added the "Get Current State" step to refresh the ETag and data payload before retrying.
- **What I Would Do Differently Now**: I would implement a "Conflict Dashboard" earlier in the process to visualize how often specific resources are colliding, which helps identify upstream architectural bottlenecks.

> [!IMPORTANT]
> Always ensure the target API supports ETags or versioning. If the API does not provide a way to verify the current state, 409 handling must rely on business logic timestamps, which are less reliable than system-generated concurrency tokens.

> [!TIP]
> When configuring the "Run After" settings, ensure the Catch scope is set to run if the Try scope "has failed," "has skipped," or "has timed out" to cover all non-success scenarios.