# 22. Failure Decision Trees

## 1. Flow Overview
- **Flow Name**: Automated Failure Triage and Decision Framework
- **Business Problem Statement**: Standard automation error notifications are often generic, leading to high Mean Time to Repair (MTTR). Developers and stakeholders struggle to distinguish between transient network glitches, data validation errors, and critical system outages.
- **Business Impact / Value**: Reduces manual triage time by up to 80%, enables automated self-healing for transient issues, and ensures critical failures are routed to the correct technical teams with full context.
- **Trigger Type**: Automated (Sub-flow / Child Flow)
- **Trigger Source**: Parent Flow "Catch" Scope or Error Handler
- **Systems / Connectors Involved**: Microsoft Teams/Slack, Azure Log Analytics, ServiceNow/Jira, Power Automate/Logic Apps.
- **Expected Run Frequency**: On-demand (only upon failure of primary business processes).
- **Estimated Data Volume**: Low (JSON metadata regarding the error).

## 2. Trigger Design
- **Trigger Connector & Action**: HTTP Request / Manual Trigger (Child Flow).
- **Why This Trigger Was Chosen**: A centralized "Failure Decision Tree" (FDT) should be a reusable component. Using a child flow allows multiple parent flows to pass error metadata to a single source of truth for error handling.
- **Trigger Conditions Used**: No.
- **Trigger Condition Logic**: N/A (The logic is handled within the parent flow's "Run After" configuration).
- **Polling vs Event-Based**: Event-Based (triggered immediately upon parent failure).
- **How Unnecessary Runs Are Avoided**: The FDT is only invoked if a "Try" scope in a parent process fails.

## 3. End-to-End Flow Narrative
The flow begins when a parent process encounters an unhandled exception or a failed action within a "Try" scope. The parent flow passes the error object (including status code, message, and action name) to the Failure Decision Tree.

The FDT first parses the error metadata. It then enters a logic gate to categorize the failure:
1.  **Transient Errors**: If the error is a 429 (Too Many Requests) or 502/504 (Gateway Timeout), the FDT instructs the parent to wait and retry or logs it as a temporary blip.
2.  **Data/Validation Errors**: If the error is a 400 (Bad Request), the FDT routes a notification to the business user who submitted the data, rather than the IT team.
3.  **System/Auth Errors**: If the error is a 401/403 (Unauthorized) or 500 (Internal Server Error), the FDT creates a high-priority ticket in the ITSM tool and alerts the DevOps team.

The flow concludes by logging the final decision and the resulting action (Retry, Ignore, or Escalate) to a centralized telemetry dashboard.

## 4. Key Actions and Connectors
Document only the actions that influence logic, performance, or reliability.

| Action Name | Connector | Purpose | Key Inputs | Key Outputs | Why This Action |
|------------|-----------|---------|------------|-------------|----------------|
| Parse Error JSON | Data Operations | Extracts specific error codes and messages. | `triggerBody()` | Error Code, Message | Essential for routing logic. |
| Categorize Failure | Switch | Routes the flow based on HTTP status codes. | `StatusCode` | Path Selection | Efficiently handles multiple error types. |
| Get Action Details | Workflow | Retrieves the specific step that failed in the parent. | `workflow()` | Action Name | Provides context for debugging. |
| Log to Analytics | Azure Monitor | Records the failure for long-term trend analysis. | Error Metadata | Log ID | Enables proactive maintenance. |

## 5. Control Logic and Flow Structure
- **Conditions Used**: Used to check for specific strings in error messages (e.g., "Access Denied").
- **Switch Statements**: The primary driver of the Decision Tree, branching by `StatusCode` (400, 401, 429, 500, etc.).
- **Loops (Apply to each / Do until)**: Used if the FDT needs to check multiple error objects in a batch process.
- **Nested Loops**: No, to maintain low latency.
- **Parallel Branches**: Used to simultaneously log to a database and send a real-time alert to a chat platform.
- **Scope Usage**: Scopes are used to group "Self-Healing" logic vs. "Escalation" logic.

## 6. Error Handling and Monitoring
- **Anticipated Failure Scenarios**: The FDT itself failing (e.g., the logging database is down).
- **Try Scope Logic**: Wraps the ticket creation and notification logic.
- **Catch Scope Logic**: If the FDT fails, it sends a "Critical Failure in Error Handler" alert via a secondary, simplified channel (e.g., a direct email).
- **Finally Scope Logic**: Updates the parent flow's status record regardless of the triage outcome.
- **Run After Configuration**: The FDT is triggered only when the parent "Try" scope has "Timed Out" or "Failed."
- **Failure Notification Method**: Adaptive Cards in Teams for high-visibility alerts.
- **Logging Strategy**: All decisions are logged to a central "Automation Health" table.
- **How to Debug a Failed Run**: Review the "Parse Error JSON" output to see exactly what the parent flow passed to the FDT.

> [!IMPORTANT]
> Ensure the FDT has "Run After" permissions for all possible failure states in the parent flow to avoid "silent failures" where the error handler itself is skipped.

## 7. Data Handling and Expressions
- **Variables Used**: `varErrorCategory` (String), `varIsRetryable` (Boolean).
- **Key Expressions**: 
    - `result('Scope_Name')`: To capture the array of action results from the parent.
    - `first(where(outputs('Get_Results'), item() => equals(item()['status'], 'Failed')))`: To isolate the specific failed action.
- **Data Operations (Select / Filter array / Compose)**: Filter array is used to extract only the "Failed" actions from the parent flow's result set.
- **Why Expressions Were Used Instead of Actions**: Using `result()` and `filter` expressions is significantly faster and more reliable than looping through every action in a flow to find the failure.

## 8. Performance and Scalability
- **Known Bottlenecks**: API limits of the ITSM tool (e.g., ServiceNow) if a massive system outage triggers hundreds of FDT instances simultaneously.
- **Loop Optimization Strategy**: Use `Filter Array` instead of `Apply to Each` when parsing parent flow results.
- **Pagination Handling**: N/A for this specific logic.
- **Concurrency Control**: Set to high (50+) to handle simultaneous failures across multiple enterprise flows.
- **What Breaks at Higher Data Volumes**: If 1,000 flows fail at once, the notification channel (Teams/Slack) may throttle the FDT.
- **Redesign Approach for Scale**: Implement a message queue (Azure Service Bus) between the parent flows and the FDT to buffer error processing.

## 9. Security and Governance
- **Connection Type (Personal / Service Account)**: Service Account (e.g., `svc-automation-monitor`).
- **Environment Strategy**: Deployed in a "COE" or "Shared Services" environment.
- **Secrets Handling**: API keys for ITSM tools are stored in Azure Key Vault and referenced via environment variables.
- **DLP Considerations**: Ensure the "HTTP" connector is allowed in the same policy as the notification connectors.
- **Access Control Notes**: Only the Automation Team should have "Owner" access to the FDT to prevent logic tampering.

> [!WARNING]
> Never pass sensitive user data (PII) or passwords in the error metadata passed to the FDT. Error messages should be sanitized at the parent level.

## 10. Testing and Validation
- **Test Scenarios Covered**: 
    - Forced 404 (Resource not found).
    - Forced 401 (Expired secret).
    - Forced 429 (Throttling simulation).
- **Edge Cases Considered**: Parent flow failing at the very first action vs. the very last action.
- **Failure Testing**: What happens if the FDT cannot reach the ITSM tool? (Fallback to email).
- **Rerun / Recovery Strategy**: The FDT provides a "Retry" link in the Teams notification that allows a developer to restart the parent flow with one click.

## 11. Interview Question Mapping
- **Explain This Flow in 2â€“3 Minutes**: It is a centralized error-handling framework. Instead of every flow having its own complex error logic, they all send their failure data to this "Decision Tree." The tree analyzes the error code, decides if it's a technical or business issue, and either retries the action, notifies a user, or opens a ticket.
- **How Failures Are Handled**: The FDT uses a Switch statement to categorize errors. It also has its own internal Try/Catch to ensure that if the error-handler fails, a secondary alert is sent.
- **How Performance Is Optimized**: By using the `result()` expression to instantly find the failed action in a parent flow rather than looping through dozens of steps.
- **One Trade-Off Made**: We chose to use a Child Flow instead of a Logic App. While Logic Apps have better out-of-the-box monitoring, the Child Flow allowed for easier integration with the existing Power Platform environment and shared connections.

## 12. Lessons Learned
- **Initial Issues**: Initially, the FDT sent too many notifications for transient 429 errors that eventually succeeded on retry.
- **Improvements Made**: Added a "Wait and Retry" logic gate for 429/502 errors before escalating to a human.
- **What I Would Do Differently Now**: I would implement a "Deduplication" check to prevent the FDT from opening multiple tickets for the same recurring system issue.

> [!TIP]
> Use "Adaptive Cards" for the notification output. This allows you to include "Approve" or "Retry" buttons directly within the alert message, turning a notification into an actionable interface.