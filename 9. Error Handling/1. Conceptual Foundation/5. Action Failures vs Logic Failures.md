# 5. Action Failures vs Logic Failures

## 1. Flow Overview
- **Flow Name**: Standardized Error Handling and Validation Framework
- **Business Problem Statement**: Automated processes often fail in two distinct ways: technical execution errors (Action Failures) and incorrect business outcomes despite successful execution (Logic Failures). Without a clear distinction, support teams struggle to identify if a failure requires a developer fix or a data correction.
- **Business Impact / Value**: Reduces Mean Time to Repair (MTTR) by categorizing errors immediately. Prevents "silent failures" where data is processed incorrectly but the system reports success.
- **Trigger Type**: Automated
- **Trigger Source**: Generic Webhook or System Event (e.g., Dataverse, SharePoint, SQL)
- **Systems / Connectors Involved**: Control Flow (Scopes, Conditions), Logging (Application Insights/Log Analytics), Notification (Email/Teams).
- **Expected Run Frequency**: High (Every execution of a mission-critical flow).
- **Estimated Data Volume**: Variable; depends on the payload of the parent process.

## 2. Trigger Design
- **Trigger Connector & Action**: Request / When an HTTP request is received (or native platform trigger).
- **Why This Trigger Was Chosen**: To capture incoming data packets that must be validated against both schema (Action level) and business rules (Logic level).
- **Trigger Conditions Used**: Yes
- **Trigger Condition Logic**: `@not(empty(triggerBody()?['TargetID']))` - Ensures the flow only initiates if the primary key exists, preventing immediate logic failure.
- **Polling vs Event-Based**: Event-Based.
- **How Unnecessary Runs Are Avoided**: Schema validation at the trigger level prevents the flow from starting if the JSON structure is malformed.

## 3. End-to-End Flow Narrative
The flow begins by receiving a data payload. It immediately enters a **Try-Catch-Finally** structure to manage **Action Failures**.

1.  **Action Level**: The flow attempts to execute technical steps (e.g., updating a database). If a connector times out or an API returns a 500 error, the "Catch" block is triggered. This is an Action Failure.
2.  **Logic Level**: Within the "Try" block, the flow performs data validation. For example, if a "Discount" field is greater than 100%, the flow is technically capable of processing it, but the business logic forbids it.
3.  **Decision Point**: The flow evaluates if the data meets business criteria. If it fails, the flow follows a "Logic Failure" path, which might involve a "Terminate as Succeeded" (to avoid false technical alerts) but with a custom status of "Business Rule Violation."
4.  **End State**: The flow concludes by logging the specific failure type—Technical (Action) or Functional (Logic)—to a centralized dashboard.

## 4. Key Actions and Connectors
Document only the actions that influence logic, performance, or reliability.

| Action Name | Connector | Purpose | Key Inputs | Key Outputs | Why This Action |
|------------|-----------|---------|------------|-------------|----------------|
| Scope_Try | Control | Encapsulates technical actions. | N/A | Success/Failure | To isolate Action Failures. |
| Condition_Validate_Data | Control | Checks business rules. | `variables('Price')` | True/False | To identify Logic Failures. |
| Terminate_Logic_Error | Control | Ends flow with custom status. | "Cancelled" | Custom Message | Prevents false "Success" logs. |
| Compose_Error_Log | Data Ops | Aggregates error details. | `result('Scope_Try')` | JSON Object | Centralizes error metadata. |

## 5. Control Logic and Flow Structure
- **Conditions Used**: Used extensively for Logic Failure detection (e.g., checking if a record exists before attempting an update).
- **Switch Statements**: Used to route different types of Logic Failures (e.g., "Invalid Customer," "Out of Stock," "Price Mismatch").
- **Loops (Apply to each / Do until)**: Used to validate arrays of data; a single item failing logic may or may not fail the entire action.
- **Nested Loops**: No; avoided to maintain performance and simplify error tracing.
- **Parallel Branches**: Used to log errors to a database while simultaneously notifying a user.
- **Scope Usage**: **Mandatory.** Scopes are the primary mechanism for separating Action Failures (via "Run After" configuration) from Logic Failures.

## 6. Error Handling and Monitoring
- **Anticipated Failure Scenarios**: API Throttling (Action), Timeout (Action), Invalid Data Format (Action), Business Rule Violation (Logic), Missing Required Field (Logic).
- **Try Scope Logic**: Contains the core business process.
- **Catch Scope Logic**: Configured to run only if the Try Scope fails, times out, or is skipped. This handles **Action Failures**.
- **Finally Scope Logic**: Runs regardless of success or failure to clean up resources or close connections.
- **Run After Configuration**: The "Catch" scope is set to run after the "Try" scope has "Failed," "Timed Out," or "Is Skipped."
- **Failure Notification Method**: Adaptive Cards in Microsoft Teams for Logic Failures; High-priority PagerDuty/Email alerts for Action Failures.
- **Logging Strategy**: Log the `workflow()` run ID, the specific action that failed, and the error code.
- **How to Debug a Failed Run**: Check the "Catch" scope for Action Failures; check the "Condition" results for Logic Failures.

> [!IMPORTANT]
> An **Action Failure** means the tool broke. A **Logic Failure** means the data broke the business rules. Never treat them the same in your monitoring dashboard.

## 7. Data Handling and Expressions
- **Variables Used**: `varIsLogicValid` (Boolean), `varErrorDetails` (String).
- **Key Expressions**: `result('Scope_Name')` to parse the status of all actions within a scope.
- **Data Operations (Select / Filter array / Compose)**: `Filter array` is used to identify specific items in a batch that caused a Logic Failure without failing the entire batch.
- **Why Expressions Were Used Instead of Actions**: Expressions like `empty()` or `coalesce()` are used to prevent Action Failures (like "Null" errors) by providing default values.

## 8. Performance and Scalability
- **Known Bottlenecks**: Large "Catch" blocks can slow down the conclusion of a flow.
- **Loop Optimization Strategy**: Use "Filter Array" to validate logic across a collection before entering a loop.
- **Pagination Handling**: Ensure that logic checks are applied to every page of results, not just the first 100.
- **Concurrency Control**: High concurrency can lead to transient Action Failures (429 Too Many Requests).
- **What Breaks at Higher Data Volumes**: Logic validation using "Apply to Each" without concurrency enabled.
- **Redesign Approach for Scale**: Move complex logic validation to a dedicated Azure Function or stored procedure if the flow exceeds 500 logic checks per run.

## 9. Security and Governance
- **Connection Type (Personal / Service Account)**: Service Account (Principal) to ensure continuity.
- **Environment Strategy**: Development, UAT, and Production isolation.
- **Secrets Handling**: Use Key Vault for API keys to prevent Action Failures due to expired credentials.
- **DLP Considerations**: Ensure error logs do not leak PII (Personally Identifiable Information) into the logging system.
- **Access Control Notes**: Only administrators should see Action Failure details; Business Users may see Logic Failure summaries.

## 10. Testing and Validation
- **Test Scenarios Covered**: 
    1. Kill the API connection (Simulate Action Failure).
    2. Provide a negative price value (Simulate Logic Failure).
    3. Provide malformed JSON (Simulate Trigger/Action Failure).
- **Edge Cases Considered**: Empty arrays, null values in required fields, and maximum character limits.
- **Failure Testing**: Manually forcing a "Terminate" action to ensure the Catch block triggers correctly.
- **Rerun / Recovery Strategy**: Action Failures can often be "Resubmitted." Logic Failures usually require the source data to be fixed before a rerun.

> [!WARNING]
> Resubmitting a flow that failed due to a **Logic Failure** without changing the underlying data will simply result in the same failure.

## 11. Interview Question Mapping
- **Explain This Flow in 2–3 Minutes**: This framework distinguishes between technical crashes (Action Failures) and business rule violations (Logic Failures). It uses Scopes to catch technical errors and Conditions to catch data errors, ensuring that the support team knows exactly whether to call a developer or a business analyst.
- **How Failures Are Handled**: Action failures are caught using "Run After" configurations on Scopes. Logic failures are handled by validating data against business rules and using the "Terminate" action with a custom status.
- **How Performance Is Optimized**: By using "Filter Array" to check for logic errors across entire datasets at once rather than checking item-by-item in a loop.
- **One Trade-Off Made**: We chose to let Logic Failures "Succeed" in the platform's eyes but log them as "Business Failures" in our custom dashboard to avoid cluttering the technical health logs.

## 12. Lessons Learned
- **Initial Issues**: Early versions treated Logic Failures as technical errors, causing the IT team to be paged at 2 AM for simple data entry mistakes.
- **Improvements Made**: Added a "Logic Error" flag in the logging database to filter out non-technical issues from the IT dashboard.
- **What I Would Do Differently Now**: Implement a "Pre-flight Check" pattern where logic is validated before any heavy actions (like database writes) are attempted.

> [!TIP]
> Use the `result()` expression on a Scope to get a JSON array of every action's status. This is the fastest way to find exactly which action caused a failure in a complex flow.