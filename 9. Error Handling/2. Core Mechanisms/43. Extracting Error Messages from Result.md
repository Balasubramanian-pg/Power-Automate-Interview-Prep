# 43. Extracting Error Messages from Result

## 1. Flow Overview
- **Flow Name**: Standardized Error Extraction and Logging Framework
- **Business Problem Statement**: When automated workflows fail, native notifications often provide generic "Flow Failed" alerts without specific context. Developers and support teams spend excessive time manually digging through run histories to find the specific action that failed and the underlying error message.
- **Business Impact / Value**: Reduces Mean Time to Repair (MTTR) by providing immediate, actionable error details. Improves system reliability by enabling automated error categorization and proactive alerting.
- **Trigger Type**: Automated (typically triggered by the failure of a "Try" scope)
- **Trigger Source**: Internal Workflow Engine
- **Systems / Connectors Involved**: Data Operations, Control Workflow, Notification Services (Email/Teams/Slack), Logging Services (Azure Application Insights/Dataverse).
- **Expected Run Frequency**: On-demand (only upon failure of monitored processes).
- **Estimated Data Volume**: Low (JSON metadata of the failed scope).

## 2. Trigger Design
- **Trigger Connector & Action**: Scope-based execution (Try/Catch pattern).
- **Why This Trigger Was Chosen**: Using a "Catch" scope that runs only when the "Try" scope fails or times out ensures that error extraction logic does not consume resources during successful runs.
- **Trigger Conditions Used**: No (Logic is handled by "Run After" configurations).
- **Trigger Condition Logic**: The "Catch" scope is configured to run if the "Try" scope has 'Failed', 'Skipped', or 'Timed Out'.
- **Polling vs Event-Based**: Event-based (Internal state change).
- **How Unnecessary Runs Are Avoided**: The extraction logic is encapsulated within a conditional block that only executes when the parent container's status is non-success.

## 3. End-to-End Flow Narrative
The flow follows the industry-standard Try-Catch-Finally pattern. 

1.  **Execution**: The "Try" scope contains the core business logic.
2.  **Failure Detection**: If any action within the "Try" scope fails, the engine skips remaining actions and moves to the "Catch" scope.
3.  **Extraction**: Inside the "Catch" scope, the `result()` function is called, targeting the "Try" scope. This returns an array of JSON objects representing every action inside that scope.
4.  **Filtering**: A "Filter Array" action iterates through the result set to isolate only those actions where the status is 'Failed'.
5.  **Parsing**: The flow extracts the `name`, `error code`, and `message` from the filtered results.
6.  **Notification/Logging**: The extracted details are formatted into a readable string and sent to a centralized logging system or support channel.

> [!IMPORTANT]
> The `result()` function is the cornerstone of this pattern. It provides a programmatic way to inspect the metadata of a scope's execution without manual intervention.

## 4. Key Actions and Connectors
| Action Name | Connector | Purpose | Key Inputs | Key Outputs | Why This Action |
|------------|-----------|---------|------------|-------------|----------------|
| Filter_Failed_Actions | Data Operations | Isolates failed steps from successful ones. | `result('Try_Scope')` | Array of failed actions | Essential to ignore successful steps in the scope. |
| Select_Error_Details | Data Operations | Maps complex JSON to simple Key-Value pairs. | Output of Filter | Action Name, Error Message | Simplifies the data for notifications. |
| Join_Errors | Data Operations | Converts the array of errors into a single string. | Output of Select | String | Makes the output readable in emails or logs. |
| Log_Error | System Connector | Records the failure for audit. | Error String, Run ID | Success/Fail | Ensures persistence of the error data. |

## 5. Control Logic and Flow Structure
- **Conditions Used**: Used to check if the filtered array of errors is empty (though theoretically, it shouldn't be if the Catch block triggered).
- **Switch Statements**: Not typically used in extraction, but can be used to route different error codes to different support tiers.
- **Loops (Apply to each / Do until)**: Used to iterate through the failed actions if multiple failures occurred (e.g., in parallel branches).
- **Nested Loops**: No; avoided to maintain performance.
- **Parallel Branches**: Used within the "Try" scope; the extraction logic handles parallel failures by capturing all "Failed" statuses in the array.
- **Scope Usage**: Critical. "Try" and "Catch" scopes define the boundaries for error extraction.

## 6. Error Handling and Monitoring
- **Anticipated Failure Scenarios**: The `result()` function might fail if the scope name is renamed and the expression is not updated.
- **Try Scope Logic**: Contains the primary business process.
- **Catch Scope Logic**: Contains the `result()` extraction and notification logic.
- **Finally Scope Logic**: Used for cleanup tasks (e.g., closing connections) regardless of success or failure.
- **Run After Configuration**: The Catch scope is set to "Run After" the Try scope has 'Failed', 'Timed Out', or 'Has Skipped'.
- **Failure Notification Method**: Adaptive Cards in Teams or HTML-formatted emails.
- **Logging Strategy**: Centralized logging to a database or Application Insights for long-term trend analysis.
- **How to Debug a Failed Run**: Inspect the "Filter Array" output to see the raw JSON returned by the `result()` function.

> [!TIP]
> Always include the "Run URL" in your error extraction so support staff can click directly into the failed instance.

## 7. Data Handling and Expressions
- **Variables Used**: `varErrorMessages` (String).
- **Key Expressions**: 
    - `result('Try_Scope')`: Retrieves the status of all actions in the scope.
    - `item()?['outputs']?['body']?['error']?['message']`: Navigates the JSON schema of a failed action to find the human-readable message.
- **Data Operations (Select / Filter array / Compose)**: Used heavily to transform the verbose `result()` JSON into a concise summary.
- **Why Expressions Were Used Instead of Actions**: Expressions like `item()?['outputs']...` are used because the schema of a failed action can vary slightly between connectors; using the "Question Mark" (null-conditional operator) prevents the error handler itself from failing.

## 8. Performance and Scalability
- **Known Bottlenecks**: Large scopes with hundreds of actions can result in a large JSON object for the `result()` function to process.
- **Loop Optimization Strategy**: Use the `Select` and `Join` actions instead of "Apply to Each" to concatenate error messages; this is significantly faster.
- **Pagination Handling**: N/A (Result sets for scopes are not paginated).
- **Concurrency Control**: Not applicable for error extraction.
- **What Breaks at Higher Data Volumes**: If the error message itself is massive (e.g., a full HTML page returned as an error), it may exceed the character limit of the notification connector (like Teams).
- **Redesign Approach for Scale**: For high-volume environments, send the raw JSON to a Log Analytics workspace and use KQL for parsing rather than parsing within the flow.

## 9. Security and Governance
- **Connection Type (Personal / Service Account)**: Service Account (to ensure the error handler has access to logging repositories).
- **Environment Strategy**: Error handling patterns should be packaged as a "Child Flow" or "Shared Template" across the environment.
- **Secrets Handling**: Ensure that the error extraction logic does not log sensitive inputs (like passwords or API keys) that might be present in the action's "Inputs" metadata.
- **DLP Considerations**: Ensure the "Logging" connector is in the same data group as the connectors being monitored.
- **Access Control Notes**: Only administrators should have access to the logs generated by the extraction process.

> [!WARNING]
> Be careful when logging `outputs`. If an action fails while processing PII (Personally Identifiable Information), the error message might contain that data. Use `Select` to only grab the `message` and not the `body`.

## 10. Testing and Validation
- **Test Scenarios Covered**: 
    1. Single action failure.
    2. Multiple action failures in parallel branches.
    3. Timeout failures.
    4. Nested scope failures.
- **Edge Cases Considered**: What happens if the error message is null? (Handled via null-conditional expressions).
- **Failure Testing**: Intentionally providing incorrect credentials or malformed JSON to the "Try" scope to trigger the "Catch" block.
- **Rerun / Recovery Strategy**: The error log should include enough state information to allow for a manual "Submit" of the failed run after the root cause is fixed.

## 11. Interview Question Mapping
- **Explain This Flow in 2â€“3 Minutes**: I implement a Try-Catch pattern using Scopes. In the Catch block, I use the `result()` expression to get a JSON array of all actions in the Try block. I filter this array for 'Failed' statuses and use a `Select` action to extract the specific error messages, which are then logged centrally.
- **How Failures Are Handled**: Failures are handled by the "Run After" configuration, ensuring that the error extraction logic only runs when something goes wrong.
- **How Performance Is Optimized**: I avoid "Apply to Each" loops when processing error arrays, opting for `Filter Array` and `Join` operations which are processed in-memory and are much faster.
- **One Trade-Off Made**: I chose to extract only the `message` and `code` rather than the full `body` to avoid hitting character limits in notifications and to prevent accidental logging of sensitive data.

## 12. Lessons Learned
- **Initial Issues**: Initially, the flow would fail if an action was skipped, as I wasn't filtering specifically for the 'Failed' status.
- **Improvements Made**: Added the `item()?['outputs']?['body']?['error']?['message']` path to handle standard API error formats.
- **What I Would Do Differently Now**: I would implement this as a standardized Child Flow that any Parent Flow can call, passing its Scope Name to ensure a consistent error-handling experience across the entire organization.