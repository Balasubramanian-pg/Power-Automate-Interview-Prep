# 42. Extracting Status from Result

## 1. Flow Overview
- **Flow Name**: Standardized Result Status Extraction Pattern
- **Business Problem Statement**: Automated processes often interact with APIs, child flows, or external systems that return complex JSON objects. Without a standardized way to extract and interpret the "Status" or "Outcome" of these operations, flows become brittle, error-prone, and difficult to monitor.
- **Business Impact / Value**: Ensures consistent error handling across the enterprise, reduces manual intervention by accurately routing "Success" vs. "Failure" paths, and provides clear audit trails for business stakeholders.
- **Trigger Type**: Automated (typically as a Child Flow or a pattern within a Parent Flow)
- **Trigger Source**: HTTP Request or Power Automate "Run a Child Flow"
- **Systems / Connectors Involved**: Data Operations, Control Logic, HTTP Connector, JSON Parser.
- **Expected Run Frequency**: High (used in almost every transactional flow).
- **Estimated Data Volume**: Low per run (JSON metadata), but high aggregate volume.

## 2. Trigger Design
- **Trigger Connector & Action**: Power Automate - "When an HTTP request is received" or "Manually trigger a flow".
- **Why This Trigger Was Chosen**: This pattern is most effective when implemented as a reusable utility (Child Flow). It allows multiple parent flows to pass a "Result Object" and receive a normalized "Status String."
- **Trigger Conditions Used**: No.
- **Trigger Condition Logic**: N/A.
- **Polling vs Event-Based**: Event-based; the extraction logic executes immediately upon receiving the result object.
- **How Unnecessary Runs Are Avoided**: By ensuring the parent flow only calls the extraction logic if the preceding action actually returns a body (using a condition to check for null).

## 3. End-to-End Flow Narrative
The flow begins when a "Result Object" (typically the output of an API call or a database operation) is passed into the logic. 

1.  **Input Reception**: The flow receives the raw JSON body from a previous action.
2.  **Schema Validation**: The flow uses a `Parse JSON` action or a `Compose` with a path expression to locate the status field (e.g., `statusCode`, `status`, or `outcome`).
3.  **Normalization**: Since different systems use different terms (e.g., "Succeeded" vs "200" vs "Complete"), a `Switch` or `Expression` maps these to a standardized set of values: `SUCCESS`, `FAILURE`, `PENDING`.
4.  **Decision Point**: Based on the normalized status, the flow branches. If the status is `FAILURE`, it extracts the error message; if `SUCCESS`, it extracts the payload.
5.  **Termination**: The flow returns the normalized status and any relevant metadata back to the calling process or updates a system of record.

## 4. Key Actions and Connectors
Document only the actions that influence logic, performance, or reliability.

| Action Name | Connector | Purpose | Key Inputs | Key Outputs | Why This Action |
|------------|-----------|---------|------------|-------------|----------------|
| Parse JSON | Data Operations | To structure the raw result for easy property access. | `Body` of previous action | Individual properties (Status, ID) | Avoids complex string manipulation. |
| Compose - Extract Status | Data Operations | Uses expressions to safely navigate the JSON. | `outputs('Action')?['body/status']` | Normalized Status String | Handles nulls gracefully using the `?` operator. |
| Switch | Control | Routes logic based on the extracted status value. | Extracted Status | Branch execution | More efficient than multiple nested IF conditions. |
| Response | Request | Returns the extracted status to the parent flow. | Status, Message | HTTP 200 Body | Allows the parent flow to continue with a clean variable. |

## 5. Control Logic and Flow Structure
- **Conditions Used**: Used to check if the "Result" object is null or empty before attempting extraction.
- **Switch Statements**: The primary engine for status mapping (e.g., Case '200' -> Success, Case '404' -> Not Found).
- **Loops (Apply to each / Do until)**: Generally not used unless extracting statuses from an array of results (Batch Processing).
- **Nested Loops**: No, to maintain performance.
- **Parallel Branches**: Used when the status extraction needs to trigger a log entry and a notification simultaneously.
- **Scope Usage**: "Try-Catch" scopes are used to wrap the extraction logic to handle cases where the JSON schema is unexpected.

## 6. Error Handling and Monitoring
- **Anticipated Failure Scenarios**: Missing status field in the JSON, malformed JSON, or unexpected status codes (e.g., "Unknown").
- **Try Scope Logic**: Contains the `Parse JSON` and `Compose` extraction actions.
- **Catch Scope Logic**: Triggered if the JSON path does not exist. It sets a default status of `UNKNOWN_ERROR`.
- **Finally Scope Logic**: Logs the attempt to a centralized telemetry table (e.g., Dataverse or Application Insights).
- **Run After Configuration**: The "Catch" block is set to run only if the "Try" block fails or times out.
- **Failure Notification Method**: Adaptive Card sent to a Teams channel for developers if the extraction logic itself fails.
- **Logging Strategy**: Log the Raw Input, the Extracted Status, and the Timestamp.
- **How to Debug a Failed Run**: Check the `Compose - Extract Status` input to see the raw JSON structure and compare it against the expected schema.

## 7. Data Handling and Expressions
- **Variables Used**: `varStatus` (String), `varIsError` (Boolean).
- **Key Expressions**: 
    - `coalesce(outputs('Action')?['body/status'], 'Unknown')`: Provides a fallback value.
    - `if(equals(outputs('Action')?['statusCode'], 200), 'Success', 'Failure')`: Inline normalization.
- **Data Operations (Select / Filter array / Compose)**: `Compose` is used heavily for "Safe Navigation" of JSON properties.
- **Why Expressions Were Used Instead of Actions**: Expressions like `coalesce` and the `?` operator prevent the flow from failing when a property is missing, which is a common limitation of the `Parse JSON` action.

> [!TIP]
> Always use the question mark operator (e.g., `body('Action')?['status']`) to prevent "Property Not Found" errors from terminating your flow.

## 8. Performance and Scalability
- **Known Bottlenecks**: Large JSON payloads can slow down the `Parse JSON` action.
- **Loop Optimization Strategy**: If processing a list of results, use `Select` to extract all statuses at once rather than an `Apply to each` loop.
- **Pagination Handling**: N/A for single result extraction.
- **Concurrency Control**: High concurrency should be enabled if this is a Child Flow to handle multiple parent requests simultaneously.
- **What Breaks at Higher Data Volumes**: The `Response` action may time out if the parent flow is not configured to handle asynchronous responses.
- **Redesign Approach for Scale**: Move complex logic to an Azure Function if the status extraction requires heavy regex or multi-step validation.

## 9. Security and Governance
- **Connection Type (Personal / Service Account)**: Service Account (Principal) for standardized logging.
- **Environment Strategy**: Deployed in a "Shared Services" environment to be accessible by all departmental flows.
- **Secrets Handling**: If the result contains PII (Personally Identifiable Information), ensure "Secure Inputs/Outputs" is enabled on the extraction actions.
- **DLP Considerations**: Ensure the "HTTP" and "Data Operations" connectors are in the same business data group.
- **Access Control Notes**: Only authorized parent flows should be able to call the extraction utility.

## 10. Testing and Validation
- **Test Scenarios Covered**: 
    - Valid JSON with "Success" status.
    - Valid JSON with "Error" status.
    - Missing "Status" field.
    - Empty Body.
- **Edge Cases Considered**: Status codes returned as Integers vs. Strings (e.g., 200 vs "200").
- **Failure Testing**: Passing a non-JSON string to the flow to ensure the `Catch` block handles it.
- **Rerun / Recovery Strategy**: Since this is a stateless extraction logic, parent flows can simply resubmit the request.

## 11. Interview Question Mapping
- **Explain This Flow in 2â€“3 Minutes**: "I designed a standardized pattern for extracting status from various system results. It uses a combination of safe-navigation expressions and switch statements to normalize different system outputs into a single business language, ensuring that our error handling is consistent across all automations."
- **How Failures Are Handled**: "We use a Try-Catch scope pattern. If the JSON structure changes and the extraction fails, the Catch block assigns a default 'Unknown' status and alerts the dev team, preventing the entire parent process from crashing silently."
- **How Performance Is Optimized**: "By using Compose actions with expressions instead of multiple variables and Parse JSON actions, we reduce the action count and execution time."
- **One Trade-Off Made**: "I chose to use a Child Flow for this logic. While it adds a slight overhead of an HTTP call, the benefit of having a single place to update status mapping logic across 50+ flows outweighs the millisecond latency."

## 12. Lessons Learned
- **Initial Issues**: Early versions failed when the API returned an empty body instead of a JSON object.
- **Improvements Made**: Added a check for `empty(triggerBody())` at the very beginning of the flow.
- **What I Would Do Differently Now**: I would use Global Environment Variables to store the mapping of status codes to business terms, making it easier to update without editing the flow logic.

> [!IMPORTANT]
> Never assume a "Status" field will always be present. Always implement a default/fallback value to ensure the flow logic remains deterministic.