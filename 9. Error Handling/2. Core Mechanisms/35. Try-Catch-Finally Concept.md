# 35. Try Catch Finally Concept

## 1. Flow Overview
- **Flow Name**: Standardized Error Handling Framework (Try-Catch-Finally Pattern)
- **Business Problem Statement**: Automated workflows often fail due to transient network issues, data validation errors, or service outages. Without a structured error-handling pattern, these failures result in "Silent Failures," incomplete data processing, and lack of visibility for support teams.
- **Business Impact / Value**: Increases process reliability, ensures data integrity by allowing for rollbacks or notifications, reduces Mean Time to Repair (MTTR) through detailed logging, and prevents business process stagnation.
- **Trigger Type**: Automated / Instant / Scheduled (Pattern is trigger-agnostic)
- **Trigger Source**: Any (e.g., Dataverse, SharePoint, HTTP Request, SQL)
- **Systems / Connectors Involved**: Scope Control Action, Notification Connectors (Teams/Outlook), Logging Systems (Azure Application Insights, SharePoint, or SQL).
- **Expected Run Frequency**: Applicable to all production-grade flows.
- **Estimated Data Volume**: N/A (Logic-based pattern).

## 2. Trigger Design
- **Trigger Connector & Action**: Dependent on the specific business use case.
- **Why This Trigger Was Chosen**: The Try-Catch-Finally pattern is implemented downstream of the trigger to wrap the core business logic.
- **Trigger Conditions Used**: Yes (Recommended to prevent unnecessary execution of the error-handling logic for invalid inputs).
- **Trigger Condition Logic**: Use expressions to validate that required fields are present before entering the "Try" scope.
- **Polling vs Event-Based**: Pattern applies to both.
- **How Unnecessary Runs Are Avoided**: By using Trigger Conditions to filter out malformed data before the Try block is even initialized.

## 3. End-to-End Flow Narrative
The Try-Catch-Finally concept is implemented using **Scopes** and the **Configure Run After** settings.

1.  **Try Scope**: The flow begins by entering the "Try" scope. This container holds all primary business logic, such as data transformations, API calls, and database updates.
2.  **Catch Scope**: If any action within the "Try" scope fails, times out, or is skipped due to a previous failure, the "Catch" scope is triggered. This block captures error details, sends alerts to administrators, and performs any necessary "rollback" operations.
3.  **Finally Scope**: Regardless of whether the "Try" scope succeeded or the "Catch" scope was executed, the "Finally" scope runs last. This is used for cleanup activities, such as closing connections, updating a master "Audit" log, or resetting state variables.

> [!IMPORTANT]
> In low-code platforms like Power Automate, the "Catch" scope must be configured to "Run After" the "Try" scope has **Failed, Skipped, or Timed Out**.

## 4. Key Actions and Connectors
Documenting the structural components of the pattern.

| Action Name | Connector | Purpose | Key Inputs | Key Outputs | Why This Action |
|------------|-----------|---------|------------|-------------|----------------|
| Scope_Try | Control | Encapsulates main logic. | N/A | Success/Failure status | To group actions for collective error handling. |
| Scope_Catch | Control | Handles errors. | `result('Scope_Try')` | Error Message, Code | To intercept failures and prevent flow "Succeeded" status on failure. |
| Scope_Finally | Control | Final cleanup/logging. | N/A | Final Status | To ensure specific actions run regardless of outcome. |
| Terminate | Control | Sets final flow status. | Status: Failed | Error Code | To ensure the flow run is marked as "Failed" in history if the Catch block runs. |

## 5. Control Logic and Flow Structure
- **Conditions Used**: Often used inside the Catch block to differentiate between types of errors (e.g., 404 vs 500).
- **Switch Statements**: Used within the Catch block if different error codes require different remediation paths.
- **Loops (Apply to each / Do until)**: If a loop is inside a Try block, a failure inside the loop will trigger the Catch block.
- **Nested Loops**: Yes, but error handling should ideally be handled at the level where the recovery logic is most relevant.
- **Parallel Branches**: Can be used within a Try block; however, the Catch block will trigger if *any* branch fails.
- **Scope Usage**: This is the foundational element of the Try-Catch-Finally pattern.

## 6. Error Handling and Monitoring
- **Anticipated Failure Scenarios**: API Throttling (429), Authentication timeouts, Null value errors in expressions, and downstream service unavailability.
- **Try Scope Logic**: Contains the "Happy Path" logic.
- **Catch Scope Logic**: Configured to run only if "Try" fails. It typically uses the `result()` expression to parse which action failed and why.
- **Finally Scope Logic**: Configured to run after "Catch" (if it ran) OR after "Try" (if Catch was skipped).
- **Run After Configuration**:
    - **Catch**: Run after Try [Failed, Skipped, Timed Out].
    - **Finally**: Run after Catch [Succeeded, Failed, Skipped, Timed Out].
- **Failure Notification Method**: Adaptive Cards in Microsoft Teams or templated emails to a DevOps mailbox.
- **Logging Strategy**: Writing the error message, timestamp, and Correlation ID to a centralized log (e.g., Azure Log Analytics).
- **How to Debug a Failed Run**: Examine the "Catch" scope inputs to see the output of the `result()` function, which provides a JSON array of all actions in the Try block and their statuses.

> [!TIP]
> Use the expression `result('Scope_Try')` inside the Catch block and filter the array to find the object where `status` is equal to 'Failed'.

## 7. Data Handling and Expressions
- **Variables Used**: `varErrorDetails` (String), `varIsSuccessful` (Boolean).
- **Key Expressions**: 
    - `result('Scope_Try')`: Returns an array of action results.
    - `actions('Action_Name')?['outputs']?['body']`: To get specific error details.
- **Data Operations (Select / Filter array / Compose)**: Use **Filter Array** on the `result()` output to isolate the specific action that caused the failure.
- **Why Expressions Were Used**: Expressions allow for dynamic extraction of error messages without hard-coding every possible failure point.

## 8. Performance and Scalability
- **Known Bottlenecks**: Large `result()` arrays in very complex flows can slightly increase processing time in the Catch block.
- **Loop Optimization Strategy**: If errors occur inside a high-concurrency loop, ensure the Catch logic is thread-safe.
- **Pagination Handling**: Errors during pagination are caught by the Try block; ensure the Catch block logs the last successful page processed.
- **Concurrency Control**: The Try-Catch pattern does not impact concurrency but ensures that failed threads are logged correctly.
- **What Breaks at Higher Data Volumes**: If the Catch block sends an email for *every* failure in a loop, it may hit connector limits (Throttling).
- **Redesign Approach for Scale**: For high-volume flows, batch error logs and send a single summary notification in the Finally block.

## 9. Security and Governance
- **Connection Type (Personal / Service Account)**: Use Service Accounts for logging and notifications to ensure continuity.
- **Environment Strategy**: Standardize the Try-Catch-Finally template across Dev, Test, and Prod environments.
- **Secrets Handling**: Ensure that the Catch block does not log sensitive inputs (e.g., passwords or PII) that may have caused the failure.
- **DLP Considerations**: Ensure the logging destination (e.g., SQL or Google Sheets) is within the same DLP policy group as the data source.
- **Access Control Notes**: Only administrators should have access to the detailed error logs captured in the Catch block.

> [!WARNING]
> Be careful when using "Inputs" in your error logs. If an action fails due to a sensitive credential, that credential might be visible in the flow run history or your custom log.

## 10. Testing and Validation
- **Test Scenarios Covered**: 
    1. Success path (Try -> Finally).
    2. Failure path (Try -> Catch -> Finally).
    3. Timeout path (Simulated via long-running tasks).
- **Edge Cases Considered**: Empty arrays, null values, and expired authentication tokens.
- **Failure Testing**: Manually forcing a failure (e.g., dividing by zero or providing an invalid GUID) to ensure the Catch block triggers.
- **Rerun / Recovery Strategy**: The Catch block should ideally provide a "Deep Link" to the failed flow run to allow developers to quickly restart the process.

## 11. Interview Question Mapping
- **Explain This Flow in 2â€“3 Minutes**: "I implement a robust error-handling framework using Scopes to mimic the Try-Catch-Finally logic found in traditional programming. The Try scope contains the logic, the Catch scope handles failures via 'Run After' configurations, and the Finally scope ensures cleanup and final logging, ensuring no failure goes unnoticed."
- **How Failures Are Handled**: "Failures are intercepted by the Catch scope. I use the `result()` expression to identify the specific failed action and its error message, then notify the team via Teams and log the incident to a database."
- **How Performance Is Optimized**: "By wrapping logic in Scopes, I maintain a clean UI and minimize the number of individual 'Run After' checks, which keeps the flow execution efficient."
- **One Trade-Off Made**: "One trade-off is that using a Catch block can make a flow appear as 'Succeeded' in the run history unless a 'Terminate' action with a status of 'Failed' is explicitly used at the end of the Catch block."

## 12. Lessons Learned
- **Initial Issues**: Initially, flows were marked as "Succeeded" even when the Catch block ran, leading to missed errors.
- **Improvements Made**: Added a **Terminate** action at the end of the Catch block to ensure the platform correctly reports the failure status.
- **What I Would Do Differently Now**: I would implement a standardized "Error Logging Child Flow" that the Catch block calls, reducing redundancy across multiple workflows.

> [!NOTE]
> Always ensure the "Finally" scope is set to run even if the "Catch" scope is skipped (which happens when the "Try" scope succeeds).