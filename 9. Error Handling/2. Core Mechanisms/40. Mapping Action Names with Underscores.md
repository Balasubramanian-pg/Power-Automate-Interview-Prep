# 40. Mapping Action Names with Underscores

## 1. Flow Overview
- **Flow Name**: Standardized Action Reference and Underscore Mapping Pattern
- **Business Problem Statement**: In low-code automation platforms (like Power Automate or Logic Apps), action names often contain spaces for readability. However, the underlying workflow engine requires these names to be referenced using underscores in expressions (e.g., `outputs('Get_User_Profile')`). Manual mapping often leads to "Action Not Found" errors during runtime.
- **Business Impact / Value**: Reduces development time, prevents runtime expression errors, and ensures maintainable code by establishing a predictable naming convention for dynamic data retrieval.
- **Trigger Type**: Automated / Instant
- **Trigger Source**: Platform-agnostic (typically triggered by a data event or manual test)
- **Systems / Connectors Involved**: Workflow Engine, Data Operations, Expression Parser
- **Expected Run Frequency**: High (used in nearly every complex workflow)
- **Estimated Data Volume**: Low (metadata processing)

## 2. Trigger Design
- **Trigger Connector & Action**: Manual Trigger / HTTP Request
- **Why This Trigger Was Chosen**: To allow for isolated testing of expression syntax and to validate the mapping of action names to their internal underscore-represented IDs.
- **Trigger Conditions Used**: No
- **Trigger Condition Logic**: N/A
- **Polling vs Event-Based**: Event-Based
- **How Unnecessary Runs Are Avoided**: This pattern is a logic implementation within a larger flow; it only executes when the parent logic requires data from a specific action.

## 3. End-to-End Flow Narrative
The flow begins when a user or system event triggers the process. As the workflow progresses through various steps (e.g., "Get Manager" or "Update File Properties"), the engine assigns internal identifiers to these steps.

When the developer needs to reference the output of a previous step within an expression, they must map the "Friendly Name" (with spaces) to the "Internal Name" (with underscores). 

1.  **Action Execution**: An action named "Get Customer Details" runs.
2.  **Expression Mapping**: The developer writes an expression to access the body of that action.
3.  **Transformation**: The engine interprets `outputs('Get_Customer_Details')?['body/Email']`.
4.  **Decision Point**: If the action name is changed in the UI, the mapping must be updated, or the flow will fail.
5.  **Completion**: The mapped value is passed to the subsequent action (e.g., sending an email).

## 4. Key Actions and Connectors
Document only the actions that influence logic, performance, or reliability.

| Action Name | Connector | Purpose | Key Inputs | Key Outputs | Why This Action |
|------------|-----------|---------|------------|-------------|----------------|
| Compose | Data Operations | To store the mapped expression for reuse. | Action Output Reference | Formatted String/Object | Prevents redundant complex expressions. |
| Parse JSON | Data Operations | To structure the output of a mapped action. | Body of the underscore-mapped action | Typed Data | Ensures downstream actions can use dynamic content. |
| Initialize Variable | Variables | To hold the internal name string if dynamic. | String Name | Variable Value | Useful for flows that use dynamic action referencing. |

## 5. Control Logic and Flow Structure
- **Conditions Used**: Used to check if an action output is null before attempting to map it via underscores.
- **Switch Statements**: Rarely used for mapping unless handling multiple distinct API versions.
- **Loops (Apply to each / Do until)**: Used when mapping action names within an array of results.
- **Nested Loops**: No.
- **Parallel Branches**: Used to run multiple actions simultaneously, each requiring its own underscore-mapped reference in a final "Join" or "Compose" step.
- **Scope Usage**: Highly recommended to group actions. Note that actions inside a Scope still use their individual names for underscore mapping, not the Scope name.

## 6. Error Handling and Monitoring
- **Anticipated Failure Scenarios**: `ActionNotFound` error caused by a typo in the underscore mapping or renaming an action without updating the expression.
- **Try Scope Logic**: Wrap complex expressions in a Try scope to catch mapping errors.
- **Catch Scope Logic**: Log the specific action name that failed to map.
- **Finally Scope Logic**: Clear temporary variables used for mapping.
- **Run After Configuration**: Set downstream actions to run even if the mapping "Compose" fails to allow for custom error logging.
- **Failure Notification Method**: Adaptive Card to Teams or Email with the specific expression error.
- **Logging Strategy**: Log the "Internal Name" vs "Display Name" in a centralized log table.
- **How to Debug a Failed Run**: Use the "Peek Code" feature in the designer to verify the exact string the engine expects for the action name.

> [!IMPORTANT]
> If you rename an action from "Get Data" to "Fetch Records", any expression using `outputs('Get_Data')` will immediately break. The engine does not always auto-update hardcoded expressions.

## 7. Data Handling and Expressions
- **Variables Used**: `varActionName` (String).
- **Key Expressions**: 
    - `outputs('Action_Name_With_Underscores')`
    - `body('Action_Name_With_Underscores')`
    - `actions('Action_Name_With_Underscores')?['outputs']`
- **Data Operations (Select / Filter array / Compose)**: Compose is the primary tool for testing if an underscore mapping is valid.
- **Why Expressions Were Used Instead of Actions**: Expressions are required to access specific properties of an action's output that are not exposed as dynamic tokens in the UI.

> [!TIP]
> To find the correct underscore mapping, click the three dots (...) on an action and select "Peek Code". Look for the name defined in the "actions" object.

## 8. Performance and Scalability
- **Known Bottlenecks**: Excessive use of complex expressions inside high-frequency loops.
- **Loop Optimization Strategy**: Map the action output to a variable *before* entering a loop to avoid re-evaluating the underscore mapping on every iteration.
- **Pagination Handling**: Underscore mapping remains consistent across paginated results.
- **Concurrency Control**: Not directly applicable to naming, but ensure variables used for mapping are not overwritten in parallel branches.
- **What Breaks at Higher Data Volumes**: The mapping itself doesn't break, but the `outputs()` call may time out if the referenced action's payload is massive (e.g., >100MB).
- **Redesign Approach for Scale**: Use "Select" to narrow down the data from the mapped action before processing.

## 9. Security and Governance
- **Connection Type (Personal / Service Account)**: N/A (Logic-based).
- **Environment Strategy**: Ensure naming conventions are consistent across Dev, Test, and Prod environments.
- **Secrets Handling**: Never include sensitive keys in action names, as these appear in the underscore-mapped expressions in plain text in the run history.
- **DLP Considerations**: Mapping logic itself is not restricted by DLP, but the data being mapped might be.
- **Access Control Notes**: Users with "Run-only" permissions can see the mapped action names in the execution trace.

## 10. Testing and Validation
- **Test Scenarios Covered**: 
    - Action names with single spaces.
    - Action names with multiple consecutive spaces.
    - Action names with special characters (e.g., `Get Data (v2)` becomes `Get_Data_(v2)`).
- **Edge Cases Considered**: Actions starting with numbers or containing non-alphanumeric characters.
- **Failure Testing**: Intentionally renaming an action to verify that the flow fails as expected, then correcting the mapping.
- **Rerun / Recovery Strategy**: If a mapping error occurs, update the expression and resubmit the failed run.

## 11. Interview Question Mapping
- **Explain This Flow in 2â€“3 Minutes**: "In workflow automation, I use a standardized mapping pattern to reference action outputs. Since the engine requires underscores instead of spaces for internal references, I use the `outputs('Internal_Name')` syntax. This ensures that even when dynamic content tokens aren't available, I can precisely target data from any previous step."
- **How Failures Are Handled**: "I use 'Peek Code' to validate the internal name and wrap references in 'Compose' actions to isolate mapping errors from the rest of the business logic."
- **How Performance Is Optimized**: "I avoid placing complex underscore-mapped expressions directly inside loops; instead, I initialize them into variables or Compose actions once."
- **One Trade-Off Made**: "I trade off the 'Friendly Names' in the UI for shorter, more technical names (e.g., `Get_User` instead of `Get User Details from Office 365`) to make the expressions cleaner and less prone to mapping errors."

## 12. Lessons Learned
- **Initial Issues**: Frequently encountered `TemplateLanguageExpressionEvaluationFailed` because I forgot that parentheses and dashes are often preserved or handled differently than spaces.
- **Improvements Made**: Adopted a strict naming convention: `Verb_Object_Source` (e.g., `Get_Invoice_SharePoint`) to make the underscore mapping intuitive.
- **What I Would Do Differently Now**: I would always use the "Compose" action to hold an output immediately after a complex action, so I only have to map the underscore name once.

> [!CAUTION]
> Avoid using non-ASCII characters in action names. While the UI supports them, the underscore mapping and expression engine can produce unpredictable results or require URL encoding.