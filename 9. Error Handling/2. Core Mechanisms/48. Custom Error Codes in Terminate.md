# 48. Custom Error Codes in Terminate

## 1. Flow Overview
- **Flow Name**: Standardized Error Propagation via Custom Terminate Codes
- **Business Problem Statement**: Standard flow failures provide generic "ActionFailed" or "TimedOut" messages which are difficult for centralized monitoring systems or parent flows to parse and act upon programmatically.
- **Business Impact / Value**: Reduces Mean Time to Repair (MTTR) by providing granular, machine-readable error categories. Enables automated retry logic in parent flows based on specific error classifications (e.g., transient vs. permanent errors).
- **Trigger Type**: Instant (typically used in Child Flows or API-exposed Logic Apps)
- **Trigger Source**: Power Automate / Azure Logic Apps Request Trigger
- **Systems / Connectors Involved**: Control Connector (Terminate Action), Scope Logic, JSON Parsing.
- **Expected Run Frequency**: High (as this is a pattern applied across enterprise workflows).
- **Estimated Data Volume**: Minimal (metadata-only).

## 2. Trigger Design
- **Trigger Connector & Action**: Power Automate "Manually trigger a flow" or "When an HTTP request is received".
- **Why This Trigger Was Chosen**: Custom error codes are most valuable in "Child Flows" or "Callable Workflows" where the calling process needs to receive a specific status code to determine the next step in the business logic.
- **Trigger Conditions Used**: No.
- **Trigger Condition Logic**: N/A.
- **Polling vs Event-Based**: Event-Based.
- **How Unnecessary Runs Are Avoided**: Input validation at the trigger level ensures the flow only processes well-formed requests before reaching the logic that might necessitate a custom termination.

## 3. End-to-End Flow Narrative
The flow begins by initializing a standard "Try-Catch-Finally" structure using Scopes. The "Try" scope contains the core business logic (e.g., updating a database or calling an external API). 

If any action within the "Try" scope fails, the "Catch" scope is triggered via the "Run After" configuration. Inside the "Catch" scope, the flow identifies the specific failure point using expressions. Instead of allowing the flow to end with a generic failure, a "Terminate" action is used. 

The "Terminate" action is configured with a status of **Failed**. This unlocks two critical fields: **Code** and **Message**. The flow populates the "Code" field with a custom alphanumeric string (e.g., `APP-404-USER_NOT_FOUND`) and the "Message" field with dynamic details from the failed action. This ensures that the flow run is marked as failed in the history, but provides a structured reason that can be surfaced in Power BI dashboards or caught by a Parent Flow.

## 4. Key Actions and Connectors
Documenting the critical actions involved in the custom termination pattern.

| Action Name | Connector | Purpose | Key Inputs | Key Outputs | Why This Action |
|------------|-----------|---------|------------|-------------|----------------|
| Scope_Try | Control | Encapsulates main logic. | N/A | N/A | To isolate failures. |
| Scope_Catch | Control | Handles errors. | Run After: Has Failed | N/A | To intercept exceptions. |
| Filter_Error_Details | Data Operations | Extracts the specific failed action from the Scope result. | `result('Scope_Try')` | Array of failed actions. | To find the root cause. |
| Terminate_Custom_Error | Control | Ends the flow with specific metadata. | Status: Failed, Code: `ERR-102`, Message: `Dynamic Message` | N/A | To provide machine-readable error codes. |

## 5. Control Logic and Flow Structure
- **Conditions Used**: Often used within the Catch block to differentiate between "Expected" errors (e.g., record not found) and "Unexpected" errors (e.g., service down).
- **Switch Statements**: Used to map internal system error codes to standardized corporate error codes before termination.
- **Loops (Apply to each / Do until)**: Not typically used for the termination logic itself, but may be used to parse the `result()` array.
- **Nested Loops**: No.
- **Parallel Branches**: Used to simultaneously log the error to a database and terminate the flow.
- **Scope Usage**: **Mandatory.** The `Try` and `Catch` scopes are the foundation for implementing custom error codes.

## 6. Error Handling and Monitoring
- **Anticipated Failure Scenarios**: API timeouts, Authentication expiration, Data validation mismatches.
- **Try Scope Logic**: Contains all "Happy Path" actions.
- **Catch Scope Logic**: Filters the `result()` of the Try scope to find the action with a "Failed" status.
- **Finally Scope Logic**: Used for cleanup (e.g., closing a connection) regardless of success or failure.
- **Run After Configuration**: The Catch scope is set to run only if the Try scope **has failed, has skipped, or has timed out**.
- **Failure Notification Method**: Custom error codes are pushed to Azure Application Insights or a SharePoint Error Log.
- **Logging Strategy**: Log the Custom Code, Flow Run ID, and the Timestamp.
- **How to Debug a Failed Run**: Look at the "Terminate" action in the run history; the "Code" field will immediately identify the category of failure without needing to expand every scope.

> [!IMPORTANT]
> The "Code" field in the Terminate action is limited to 100 characters. Ensure your naming convention is concise but descriptive.

## 7. Data Handling and Expressions
- **Variables Used**: `varErrorCode` (String), `varErrorMessage` (String).
- **Key Expressions**: 
    - `result('Scope_Try')`: Returns an array of all action outputs within the scope.
    - `filter(result('Scope_Try'), x => x['status'] == 'Failed')`: Isolates the failure.
- **Data Operations (Select / Filter array / Compose)**: "Filter Array" is used on the `result()` expression to find the specific action that failed.
- **Why Expressions Were Used Instead of Actions**: Using `result()` in an expression is the only way to programmatically access the error message of a failed action without hard-coding every possible failure path.

## 8. Performance and Scalability
- **Known Bottlenecks**: The `result()` function can be slow if the Scope contains hundreds of actions.
- **Loop Optimization Strategy**: Keep Scopes focused on specific logical units to keep the `result()` array manageable.
- **Pagination Handling**: N/A.
- **Concurrency Control**: Terminate actions stop the specific run instance immediately, releasing any reserved concurrency slots.
- **What Breaks at Higher Data Volumes**: If thousands of flows fail simultaneously, the logging mechanism (e.g., SQL log) might become a bottleneck before the Terminate action is reached.
- **Redesign Approach for Scale**: Use asynchronous logging (Fire-and-Forget) before the Terminate action.

## 9. Security and Governance
- **Connection Type (Personal / Service Account)**: Service Account (to ensure consistent logging).
- **Environment Strategy**: Error codes should be standardized across Dev, Test, and Prod environments.
- **Secrets Handling**: Ensure that the "Message" field in the Terminate action does not include PII (Personally Identifiable Information) or API Keys from the failed action's inputs/outputs.
- **DLP Considerations**: The Terminate action is a built-in control and is generally not restricted by DLP policies.
- **Access Control Notes**: Only users with "Run-only" or "Owner" permissions can see the custom error codes in the run history.

> [!WARNING]
> Be cautious when using `outputs('ActionName')` in your error message. If the action failed because it contained sensitive data, that data might be exposed in the flow run history via the Terminate message.

## 10. Testing and Validation
- **Test Scenarios Covered**: 
    1. Force failure by providing invalid inputs.
    2. Force timeout by calling a slow mock API.
    3. Validate that the Parent Flow correctly interprets the Custom Code.
- **Edge Cases Considered**: Multiple actions failing within a single scope (the logic should pick the first failure).
- **Failure Testing**: Verified that the flow status shows as "Failed" in the dashboard, not "Succeeded," even though the error was "handled."
- **Rerun / Recovery Strategy**: Parent flows use a `Switch` statement on the child flow's error code to decide whether to "Resubmit" or "Escalate to Human."

## 11. Interview Question Mapping
- **Explain This Flow in 2â€“3 Minutes**: I use a Try-Catch pattern where the Catch block extracts the specific error from the Try scope using the `result()` expression. I then map that error to a custom business code and use the Terminate action with a "Failed" status to pass that code back to the system.
- **How Failures Are Handled**: Failures are intercepted by a Catch scope. Instead of a generic crash, the flow identifies the root cause and terminates gracefully with a machine-readable error code.
- **How Performance Is Optimized**: By using Scopes, I minimize the number of "Run After" checks the engine has to perform, and by using the `result()` expression, I avoid complex nested "If" conditions.
- **One Trade-Off Made**: Using "Terminate" with a status of "Failed" means the flow is counted as a failure in platform analytics. While this is accurate, some organizations prefer "Succeeded" with an error object in the output. I chose "Failed" to ensure the native monitoring alerts still trigger.

## 12. Lessons Learned
- **Initial Issues**: Initially, I used "Succeeded" status in Terminate to avoid "noise" in the logs, but this hid actual errors from the IT operations team.
- **Improvements Made**: Switched to "Failed" status but implemented a strict prefixing system for codes (e.g., `SYS-` for infrastructure issues, `BUS-` for logic issues) to allow for better filtering.
- **What I Would Do Differently Now**: I would implement a global "Error Dictionary" in a configuration file (JSON) so that error messages can be updated without editing the flow logic.

> [!TIP]
> When building Child Flows, always return the Custom Error Code in a "Respond to Power App or Flow" action *before* the Terminate action if you want the Parent Flow to receive the data without using a complex "Parse JSON" on the child's failure metadata.