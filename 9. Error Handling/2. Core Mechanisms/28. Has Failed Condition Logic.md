# 28. Has Failed Condition Logic

## 1. Flow Overview
- **Flow Name**: Global Exception Handling and Failure State Management
- **Business Problem Statement**: Standard automation platforms often lack granular error reporting. When a step fails, the entire process may stop without notifying stakeholders or cleaning up resources, leading to data silos and "silent failures."
- **Business Impact / Value**: Ensures 100% visibility into process health, reduces Mean Time to Repair (MTTR) by providing specific error context, and prevents data corruption by triggering rollback procedures.
- **Trigger Type**: Automated (Sub-flow) or Sequential (Inline Scope)
- **Trigger Source**: Parent Flow Failure or Terminal Scope State
- **Systems / Connectors Involved**: Logic Engine (Power Automate/Azure Logic Apps), Notification Systems (Teams/Slack/Email), Logging Systems (Azure Application Insights/Dataverse/SQL)
- **Expected Run Frequency**: Only upon failure of primary logic (Exception-based)
- **Estimated Data Volume**: Low (Metadata and error strings)

## 2. Trigger Design
- **Trigger Connector & Action**: "Run After" Configuration / Status Check Logic
- **Why This Trigger Was Chosen**: Standard triggers only execute on success. To handle failures, the logic must be configured to execute specifically when the preceding action or scope results in a `Failed`, `Timed Out`, or `Skipped` status.
- **Trigger Conditions Used**: Yes
- **Trigger Condition Logic**: `result('Scope_Name')` contains 'Failed'
- **Polling vs Event-Based**: Event-based (State-change triggered)
- **How Unnecessary Runs Are Avoided**: The "Catch" block is only entered if the "Try" block encounters an unhandled exception.

## 3. End-to-End Flow Narrative
The flow follows the industry-standard Try-Catch-Finally pattern. 

1.  **Try Block**: The main business logic executes (e.g., updating a database, sending a file).
2.  **Catch Block (Has Failed Logic)**: This block is configured to "Run After" the Try block has **Failed** or **Timed Out**. 
3.  **Error Extraction**: The flow uses expressions to filter the results of the Try block to find the specific action that failed and extract its error message.
4.  **Notification/Logging**: The error details are sent to a centralized logging system and a notification is sent to the administrator.
5.  **Termination**: The flow is explicitly terminated as "Failed" to ensure the dashboard reflects the true status, even though the error was "handled."

## 4. Key Actions and Connectors
Documenting the actions that facilitate the detection and processing of failures.

| Action Name | Connector | Purpose | Key Inputs | Key Outputs | Why This Action |
|------------|-----------|---------|------------|-------------|----------------|
| Scope_Try | Control | Groups main logic | N/A | Success/Failure | To create a single point of failure detection. |
| Scope_Catch | Control | Error handling container | Run After: Failed | N/A | Isolates error handling from main logic. |
| Filter_Results | Data Operation | Extracts failed actions | `result('Scope_Try')` | Array of failed actions | To identify exactly what failed inside the scope. |
| Compose_ErrorMessage | Data Operation | Formats error text | `item()?['error']?['message']` | Clean error string | To provide human-readable logs. |
| Terminate | Control | Sets final flow status | Status: Failed | N/A | Ensures the flow run is marked as a failure in history. |

## 5. Control Logic and Flow Structure
- **Conditions Used**: Used to check if the error is a "known" business exception (e.g., 404 Not Found) vs. a "system" exception (e.g., 500 Internal Server Error).
- **Switch Statements**: Used to route different error codes to different support tiers.
- **Loops (Apply to each / Do until)**: Used to iterate through the `result()` array of the failed scope to capture multiple errors if parallel branches were used.
- **Nested Loops**: No, to maintain performance and readability.
- **Parallel Branches**: Used to simultaneously log to a database and send an urgent alert.
- **Scope Usage**: Critical. The entire pattern relies on `Scope_Try`, `Scope_Catch`, and `Scope_Finally`.

## 6. Error Handling and Monitoring
- **Anticipated Failure Scenarios**: API Throttling (429), Authentication Expiry (401), and Timeout (Action takes > 2 minutes).
- **Try Scope Logic**: Contains all "Happy Path" actions.
- **Catch Scope Logic**: Configured to run only if Try Scope fails.
- **Finally Scope Logic**: Configured to run after both Success and Failure to perform cleanup (e.g., deleting temporary files).
- **Run After Configuration**: The "Has Failed" logic is explicitly set by clicking "Configure Run After" and selecting `has failed`, `has timed out`, and `is skipped`.
- **Failure Notification Method**: Adaptive Cards in Microsoft Teams or PagerDuty API integration.
- **Logging Strategy**: Telemetry is sent to a centralized table including Flow Run ID, Timestamp, Failed Action Name, and Error Message.
- **How to Debug a Failed Run**: Review the "Filter Results" output in the Catch block to see the raw JSON error response from the failing connector.

## 7. Data Handling and Expressions
- **Variables Used**: `varErrorDetails` (String), `varIsCritical` (Boolean).
- **Key Expressions**: 
    - `result('Scope_Name')`: Retrieves an array of all action statuses within a scope.
    - `filter(result('Scope_Name'), x => x['status'] == 'Failed')`: Isolates the failure.
- **Data Operations (Select / Filter array / Compose)**: Used to parse the complex JSON object returned by the `result()` function.
- **Why Expressions Were Used Instead of Actions**: Using `result()` is the only way to programmatically access error messages without manually checking every single action in a flow.

## 8. Performance and Scalability
- **Known Bottlenecks**: Large scopes with hundreds of actions can result in a large JSON object for the `result()` function to parse.
- **Loop Optimization Strategy**: Use `Filter Array` instead of `Apply to Each` to find failed actions to reduce execution time.
- **Pagination Handling**: N/A for error handling.
- **Concurrency Control**: Ensure that the error logging destination (e.g., a SQL table) can handle concurrent writes if multiple flows fail simultaneously.
- **What Breaks at Higher Data Volumes**: If the error message itself is extremely large (e.g., a full HTML page returned as an error), it may exceed variable string limits.
- **Redesign Approach for Scale**: Move error logging to an asynchronous pattern (e.g., pushing error metadata to a Queue).

## 9. Security and Governance
- **Connection Type (Personal / Service Account)**: Service Account (to ensure notifications come from a "System" entity).
- **Environment Strategy**: Error handling logic is packaged as a "Child Flow" in a Core Solutions environment for reuse across the tenant.
- **Secrets Handling**: Ensure that the `result()` function does not inadvertently log sensitive inputs (like passwords) that were part of the failed action.
- **DLP Considerations**: The notification connector (e.g., SMTP or Teams) must be in the same DLP policy bucket as the data connectors.
- **Access Control Notes**: Only administrators should have access to the detailed error logs.

## 10. Testing and Validation
- **Test Scenarios Covered**: 
    1. Forced failure (invalid credentials).
    2. Timeout simulation (calling a slow mock API).
    3. Dependency failure (deleting a required file before the run).
- **Edge Cases Considered**: What happens if the "Catch" block itself fails? (Answer: The flow terminates as "Timed Out" or "Failed" by default).
- **Failure Testing**: Use "Static Results" (Mocking) to simulate a failure in a specific action without actually breaking the system.
- **Rerun / Recovery Strategy**: The Catch block should provide a "Resubmit" link in the notification email.

## 11. Interview Question Mapping
- **Explain This Flow in 2â€“3 Minutes**: I use a Try-Catch-Finally pattern using Scopes. The "Catch" scope is configured via "Run After" settings to only execute if the "Try" scope fails. Inside, I use the `result()` expression to parse the error and log it centrally.
- **How Failures Are Handled**: Failures are intercepted before the flow stops. This allows for custom logging, notifications, and state cleanup, followed by an explicit `Terminate` action to preserve the integrity of the flow's run history.
- **How Performance Is Optimized**: By using the `Filter Array` data operation on the scope results rather than looping through every action, I minimize the overhead of the error handling logic.
- **One Trade-Off Made**: I chose to mark the flow as "Failed" at the end of the Catch block. While this makes the dashboard look "red," it is more honest than marking it "Succeeded," which would hide issues from standard monitoring tools.

## 12. Lessons Learned
- **Initial Issues**: Initially, I didn't use the `result()` expression and had to create a "Run After" branch for every single action, which was unmaintainable.
- **Improvements Made**: Transitioned to a "Global Error Handler" child flow. Now, every flow in the environment passes its error metadata to one central location.
- **What I Would Do Differently Now**: I would implement "Self-Healing" logic where the Catch block attempts to refresh a token or restart a service before finally giving up and sending an alert.

> [!IMPORTANT]
> Always ensure the **Terminate** action is the last step in your Catch block. If you handle an error but don't terminate as failed, the platform will report the run as "Succeeded," which can mislead monitoring teams.

> [!TIP]
> Use the `result('Scope_Name')` expression inside a **Filter Array** action to quickly isolate which action caused the failure without writing complex nested conditions.