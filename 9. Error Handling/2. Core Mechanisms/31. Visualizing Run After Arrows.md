# 31. Visualizing Run After Arrows

## 1. Flow Overview
- **Flow Name**: Standardized Error Handling and Branching Pattern (Visualizing Run After Logic)
- **Business Problem Statement**: In complex automation, standard linear execution fails to account for intermittent API outages, data validation errors, or timeouts. Without visualizing and configuring "Run After" paths, flows terminate prematurely, leaving data in an inconsistent state and providing no visibility into the root cause of failure.
- **Business Impact / Value**: Increases process resilience by 40-60% through automated recovery; reduces Mean Time to Repair (MTTR) by providing clear visual indicators of where and why a process diverted from the success path.
- **Trigger Type**: Automated
- **Trigger Source**: Platform Agnostic (typically Dataverse, SharePoint, or an HTTP Request)
- **Systems / Connectors Involved**: Core Logic Connectors (Scopes, Control), Monitoring Systems (Azure Log Analytics/Application Insights).
- **Expected Run Frequency**: High (used as a foundational pattern for all production-grade flows).
- **Estimated Data Volume**: N/A (Logic-heavy rather than data-heavy).

## 2. Trigger Design
- **Trigger Connector & Action**: Common Data Service (Dataverse) - When a row is added, modified, or deleted.
- **Why This Trigger Was Chosen**: To demonstrate how "Run After" arrows manage downstream failures triggered by real-world data changes.
- **Trigger Conditions Used**: Yes
- **Trigger Condition Logic**: Filters for specific status codes to prevent recursive loops or unnecessary execution.
- **Polling vs Event-Based**: Event-Based (Webhook-driven).
- **How Unnecessary Runs Are Avoided**: Using Trigger Conditions to ensure the flow only initiates when actionable data is present.

## 3. End-to-End Flow Narrative
The flow begins with a trigger that initiates a "Try" Scope. Inside this scope, the primary business logic (API calls, data transformations) is executed. 

- **What happens when the flow is triggered?** The "Try" scope begins execution. Each action within the scope is linked by default "Succeeded" Run After arrows (solid gray lines in the designer).
- **What are the key decision points?** The primary decision point is the transition from the "Try" Scope to the "Catch" Scope. This transition is governed by a "Run After" configuration set to "Has Failed," "Has Timed Out," or "Is Skipped."
- **How does the flow end?** The flow concludes with a "Finally" Scope (configured to run after the Catch scope regardless of success or failure) which performs cleanup tasks, such as closing connections or logging the final status to a dashboard.

> [!IMPORTANT]
> Visualizing Run After arrows is not just about error handling; it is about defining the state machine of the automation. A "Skipped" arrow is just as critical as a "Failed" arrow for understanding logic flow.

## 4. Key Actions and Connectors
Document only the actions that influence logic, performance, or reliability.

| Action Name | Connector | Purpose | Key Inputs | Key Outputs | Why This Action |
|------------|-----------|---------|------------|-------------|----------------|
| Try_Scope | Control | Encapsulates main logic | N/A | Success/Failure State | Groups actions for collective error handling. |
| Catch_Scope | Control | Error remediation | `result('Try_Scope')` | Error Details | Executes only if Try_Scope fails or times out. |
| Finally_Scope | Control | Cleanup/Final Logging | N/A | Final Status | Ensures execution regardless of previous outcomes. |
| Filter_Error_Array | Data Operations | Parses error messages | `result('Try_Scope')` | Failed Action List | Extracts specific failure reasons from the scope. |

## 5. Control Logic and Flow Structure
- **Conditions Used**: Minimal; "Run After" logic is preferred over nested conditions for cleaner visualization.
- **Switch Statements**: Used within the "Catch" scope to handle different error codes (e.g., 404 vs 500).
- **Loops (Apply to each / Do until)**: Used for processing arrays, with internal "Run After" logic to handle individual item failures without crashing the entire loop.
- **Nested Loops**: No, to maintain performance and readability.
- **Parallel Branches**: Used to execute independent actions simultaneously, where the "Run After" arrow of a subsequent action waits for all branches to complete.
- **Scope Usage**: Extensive. Scopes are the primary vehicle for visualizing "Run After" transitions.

## 6. Error Handling and Monitoring
- **Anticipated Failure Scenarios**: API Timeouts, Authentication expiration, Schema mismatches.
- **Try Scope Logic**: Contains the "Happy Path."
- **Catch Scope Logic**: Configured to run if Try Scope **Failed, Skipped, or Timed Out**.
- **Finally Scope Logic**: Configured to run if Catch Scope **Succeeded or Is Skipped**.
- **Run After Configuration**: Custom settings on the Catch and Finally scopes to deviate from the default "Succeeded" path.
- **Failure Notification Method**: Adaptive Cards to Microsoft Teams or an email to the DevOps alias.
- **Logging Strategy**: Using the `result()` expression to capture the JSON output of the Try Scope.
- **How to Debug a Failed Run**: Look for the red exclamation mark in the designer; the "Run After" arrows will visually guide the user to the specific action that triggered the Catch block.

> [!TIP]
> In the Power Automate designer, a "Run After" path that is not "Succeeded" is visually represented by a dashed line or a specific indicator in the settings menu, helping developers quickly identify non-linear paths.

## 7. Data Handling and Expressions
- **Variables Used**: `varErrorDetails` (Object), `varIsSuccess` (Boolean).
- **Key Expressions**: 
    - `result('Try_Scope')`: Returns an array of all action outputs within the scope.
    - `filter(result('Try_Scope'), x => x['status'] == 'Failed')`: Isolates the specific failure.
- **Data Operations (Select / Filter array / Compose)**: Used to parse the `result()` array to find the "ErrorMessage" property.
- **Why Expressions Were Used Instead of Actions**: Using `result()` in an expression is more efficient than multiple "Condition" actions to check the status of every individual step.

## 8. Performance and Scalability
- **Known Bottlenecks**: Large `result()` arrays in scopes with 50+ actions can slow down the designer.
- **Loop Optimization Strategy**: Enable "Concurrency Control" on loops, but ensure "Run After" logic inside the loop is thread-safe.
- **Pagination Handling**: Standardized on the connector level.
- **Concurrency Control**: Set to 20-50 depending on downstream system limits.
- **What Breaks at Higher Data Volumes**: The visual designer may struggle to render complex branching logic if too many parallel branches with custom "Run After" settings are used.
- **Redesign Approach for Scale**: Move complex "Run After" logic into Child Flows to keep the parent flow visually clean and maintainable.

## 9. Security and Governance
- **Connection Type (Personal / Service Account)**: Service Account (Principal-based).
- **Environment Strategy**: Development, UAT, and Production environments with Managed Solutions.
- **Secrets Handling**: Use Azure Key Vault for any sensitive strings used in the "Catch" block (e.g., logging to a secure DB).
- **DLP Considerations**: Ensure the "Control" connector and "Notifications" connector are in the same data group.
- **Access Control Notes**: Only owners of the flow can see the detailed "Run After" execution history.

## 10. Testing and Validation
- **Test Scenarios Covered**: 
    1. Full Success (Try -> Finally).
    2. Action Failure (Try [Fail] -> Catch -> Finally).
    3. Timeout (Try [Timeout] -> Catch -> Finally).
- **Edge Cases Considered**: What happens if the "Catch" scope itself fails? (Handled by a global "Run After" on the final termination step).
- **Failure Testing**: Manually passing invalid JSON or temporary disabling an API to force the "Run After" arrow to trigger the Catch path.
- **Rerun / Recovery Strategy**: Use the "Resubmit" feature from the point of failure.

## 11. Interview Question Mapping
- **Explain This Flow in 2â€“3 Minutes**: This flow implements a robust error-handling pattern using Scopes and "Run After" configurations. Instead of letting a flow fail globally, we catch errors at the scope level, log the specific failure using the `result()` expression, and ensure cleanup occurs in a "Finally" block.
- **How Failures Are Handled**: Failures are intercepted by the "Catch" scope, which is configured via the "Run After" settings to execute only when the "Try" scope is not successful.
- **How Performance Is Optimized**: By using Scopes, we reduce the number of conditional checks. We also use expressions to filter for errors rather than looping through every action's status.
- **One Trade-Off Made**: We chose to use a single "Catch" scope for the entire "Try" block rather than individual error handling for every action to maintain visual clarity and reduce development overhead.

## 12. Lessons Learned
- **Initial Issues**: Initially, we used "Conditions" after every action, which led to a "pyramid of doom" (deeply nested logic) that was impossible to read.
- **Improvements Made**: Transitioned to the Try-Catch-Finally pattern using "Run After" arrows, which flattened the flow structure.
- **What I Would Do Differently Now**: Implement a standardized "Error Logging" Child Flow that the "Catch" block calls, ensuring consistent error reporting across all enterprise flows.

> [!CAUTION]
> If you do not configure the "Finally" block to run after the "Catch" block (Succeeded OR Skipped), the "Finally" block will not execute if the "Catch" block is skipped during a successful run. Always verify the "Run After" settings for every terminal node.